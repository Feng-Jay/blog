<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/08/09/Data%20Lab%201(%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F)/"/>
    <url>/2020/08/09/Data%20Lab%201(%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F)/</url>
    
    <content type="html"><![CDATA[<h1 id="记录自己的学习过程！"><a href="#记录自己的学习过程！" class="headerlink" title="记录自己的学习过程！"></a>记录自己的学习过程！</h1><p> 程序内允许使用：<br> a. 运算符： ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;<br> b. 范围在0 - 255之间的常数<br> c. 局部变量<br> 程序内禁止以下行为：<br>  a. 声明和使用全局变量<br>  b. 声明和使用定义宏<br>  c. 声明和调用其他的函数<br>  d. 类型的强制转换<br>  e. 使用许可范围之外的运算符<br>  f. 使用控制跳转语句：if else switch do while for</p><p>  @[TOC]</p><h2 id="int-is-AsciiDIgit-int-x"><a href="#int-is-AsciiDIgit-int-x" class="headerlink" title="int is AsciiDIgit(int x)"></a>int is AsciiDIgit(int x)</h2><ol><li><p><strong>int isAsciiDigit(int x)</strong> <strong>主要考虑int型变量溢出情况</strong><br>功能：当0x30&lt;=x&lt;=0x39时（即字符0-9的ASCII码值）返回1；其他情况下返回0 </p><pre><code class="hljs cpp">  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isAsciiDigit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-comment">/*判断X-0x30与0x39-X的符号位的情况,同时也排除了int溢出的影响*/</span><span class="hljs-keyword">int</span> test1=x+(~(<span class="hljs-number">0x30</span>)+<span class="hljs-number">1</span>);<span class="hljs-keyword">int</span> test2=(~x+<span class="hljs-number">1</span>)+<span class="hljs-number">0x39</span>;<span class="hljs-comment">//若溢出，二者的符号位仍是不同的，可排除。</span>test1=(test1&gt;&gt;<span class="hljs-number">31</span>)+<span class="hljs-number">1</span>;test2=(test2&gt;&gt;<span class="hljs-number">31</span>)+<span class="hljs-number">1</span>;<span class="hljs-comment">//算数右移31bit,符号位填满。+1后只有0,1两种情况。</span><span class="hljs-keyword">return</span> test1&amp;test2;<span class="hljs-comment">//符号要求情况应该为二者都为1即1&amp;1;其余情况均为0</span>&#125;</code></pre><h2 id="int-anyEvenBit-int-x"><a href="#int-anyEvenBit-int-x" class="headerlink" title="int anyEvenBit(int x)"></a>int anyEvenBit(int x)</h2><ol start="2"><li><strong>int anyEvenBit(int x)</strong><br>功能：当x的任意偶数位为1时，返回1；其他情况下返回0 </li></ol><p><strong>没什么难度，主要是要知道这种方法</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">anyEvenBit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<span class="hljs-comment">/*对X的每个byte都进行 | 运算，只要有一个even-bit 为1，则&amp;0x55结果不为0。 !!运算后可转换为1 */</span><span class="hljs-keyword">int</span> test1=((x&gt;&gt;<span class="hljs-number">8</span>)|(x&gt;&gt;<span class="hljs-number">16</span>)|(x&gt;&gt;<span class="hljs-number">24</span>)|x)&amp;<span class="hljs-number">0x55</span>;<span class="hljs-comment">//even-bit 全为0时, test1=0, 否则不为0.</span><span class="hljs-keyword">return</span> !!test1;     <span class="hljs-comment">//将test通过!!运算转化为0或1的结果返回</span>&#125;</code></pre><h2 id="int-copyLSB-int-x"><a href="#int-copyLSB-int-x" class="headerlink" title="int copyLSB(int x)"></a>int copyLSB(int x)</h2><ol start="3"><li><strong>int copyLSB(int x)</strong><br>功能：将返回值中的所有位全部置位成x中的第0位的值 </li></ol></li></ol><p> <strong>主要考查掩码的应用</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">copyLSB</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;  <span class="hljs-comment">/*使用掩码0x01 获得x的最低位，通过左移到最高为, 进行算术右移,变为由32个符号位组成的int数据*/</span>  <span class="hljs-keyword">int</span> test1=x&amp;<span class="hljs-number">1</span>;<span class="hljs-comment">//获得least-bit;</span>  x=(test1&lt;&lt;<span class="hljs-number">31</span>)&gt;&gt;<span class="hljs-number">31</span>;<span class="hljs-comment">//将least-bit变为符号位，再使用算术右移, 补符号位(least-bit);</span>  <span class="hljs-keyword">return</span> x;&#125;</code></pre><h2 id="int-leastBitPos-int-x"><a href="#int-leastBitPos-int-x" class="headerlink" title="int leastBitPos(int x)"></a>int leastBitPos(int x)</h2><ol start="4"><li><strong>int leastBitPos(int x)</strong><br>功能：返回⼀个掩码，在该掩码中标识了⼆进制数x的所有位中，“1”所在的位权最 小的位</li></ol><p><strong>主要考虑（~x+1）和x的位级别关系</strong><br>若x=01 01 11 00，则<del>x=10 10 00 11，</del>x+1=10 10 01 00<br>可以看到<del>x+1和x(从右往左看)，在第一个‘1’出现之前位都是相同的，而‘1’之后位级别是取反的。<br>所以可以用(</del>x+1)&amp;x得到第一个‘1’。</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">leastBitPos</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;  <span class="hljs-comment">/*~x在0~目标位为1，在目标位为0. ~x+1后0~目标位保持不变，而其他位为原值的反</span><span class="hljs-comment">  故 (~x+1)&amp;x保留了0~目标位,而目标位~31都为0*/</span>  x=(~x+<span class="hljs-number">1</span>)&amp;x;  <span class="hljs-keyword">return</span> x;&#125;</code></pre><h2 id="int-divpwr2-int-x-int-n"><a href="#int-divpwr2-int-x-int-n" class="headerlink" title="int divpwr2(int x, int n)"></a>int divpwr2(int x, int n)</h2><ol start="5"><li><strong>int divpwr2(int x, int n)</strong><br>功能：计算 x / 2^n，并将结果取整 </li></ol><p><strong>主要考虑负数的情况</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">divpwr2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<span class="hljs-comment">/*对非负数只需要&gt;&gt;n bit;  对于负数,需要加上2^n-1,再&gt;&gt;n bit;所以需要得到一个正数为0，负数为2^n-1的偏移量*/</span><span class="hljs-comment">/*为什么要加2^n-1?   1.因为对于被二整除的负数,没有影响*/</span><span class="hljs-comment">/*                   2.对不可被二整除的负数,加它后会进位,即原来得数+1,即相当于向零取整*/</span>    <span class="hljs-keyword">int</span> test1=(<span class="hljs-number">0x01</span>&lt;&lt;n)+~<span class="hljs-number">0x00</span>;<span class="hljs-comment">//获得2^n-1</span>    <span class="hljs-keyword">int</span> test2=x&gt;&gt;<span class="hljs-number">31</span>;          <span class="hljs-comment">//让符号位占满32bit</span>    test1=test2&amp;test1;      <span class="hljs-comment">//若为负数,则偏移量为2^k-1. 若为正数,则偏移量为0</span>    x=(x+test1)&gt;&gt;n;    <span class="hljs-keyword">return</span> x;&#125;</code></pre><h2 id="int-bitCount-int-x"><a href="#int-bitCount-int-x" class="headerlink" title="int bitCount(int x)"></a>int bitCount(int x)</h2><ol start="6"><li><strong>int bitCount(int x)</strong><br>功能：计算二进制数x中，对应位值“1”的总位数</li></ol><p><strong>核心思想是将一个表示原来数字的01序列==&gt;一个表示1的个数的01序列</strong></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bitCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;    <span class="hljs-comment">/*为了统计为1的位数,我们必须把这个32-bit的数值,转化为一个统计1个数的数字*/</span>  <span class="hljs-keyword">int</span> test1=(<span class="hljs-number">0x55</span>&lt;&lt;<span class="hljs-number">8</span>)|(<span class="hljs-number">0x55</span>);  test1=(test1&lt;&lt;<span class="hljs-number">16</span>)|(test1);  x=(x&amp;test1)+((x&gt;&gt;<span class="hljs-number">1</span>)&amp;test1);<span class="hljs-comment">//首先将每两位看成一个整体，利用掩码0101...0101计算每两位中1的个数，并存入x的对应位置</span>                             <span class="hljs-comment">//例一个16-bit的数:10 11 00 11 11 00 01 10 --&gt;&gt; 01 10 00 10 10 00 01 01</span>   test1=(<span class="hljs-number">0x33</span>&lt;&lt;<span class="hljs-number">8</span>)|(<span class="hljs-number">0x33</span>);  test1=(test1&lt;&lt;<span class="hljs-number">16</span>)|(test1);  x=(x&amp;test1)+((x&gt;&gt;<span class="hljs-number">2</span>)&amp;test1);<span class="hljs-comment">/*再将每四位看成一个整体, 利用掩码0011...0011将每两位的1的个数变为</span><span class="hljs-comment">                               每四位的1的个数，存入x的对应位置*/</span>                             <span class="hljs-comment">//0110 0010 1000 0101 --&gt;&gt; 0011 0010 0010 0010</span>   test1=(<span class="hljs-number">0x0f</span>&lt;&lt;<span class="hljs-number">8</span>)|(<span class="hljs-number">0x0f</span>);  test1=(test1&lt;&lt;<span class="hljs-number">16</span>)|(test1);  x=(x&amp;test1)+((x&gt;&gt;<span class="hljs-number">4</span>)&amp;test1);<span class="hljs-comment">/*再将每八位看成一个整体, 利用掩码0000 1111...0000 1111将每4位的1的个数变为</span><span class="hljs-comment">                               每8位的1的个数，存入x的对应位置*/</span>                             <span class="hljs-comment">//0011 0010 0010 0010 --&gt;&gt; 0000 0101 0000 0100</span>   test1=(<span class="hljs-number">0xff</span>&lt;&lt;<span class="hljs-number">16</span>)|(<span class="hljs-number">0xff</span>);  x=(x&amp;test1)+((x&gt;&gt;<span class="hljs-number">8</span>)&amp;test1);<span class="hljs-comment">/*再将每16位看成一个整体, 利用掩码 0000 0000 1111 1111 0000 0000 1111 1111将每8位的1的个数变为</span><span class="hljs-comment">                               每16位的1的个数，存入x的对应位置*/</span>                             <span class="hljs-comment">//0000 0101 0000 0100 --&gt;&gt; 0000 0000 0000 1001 = (9)与原数吻合</span>   test1=(<span class="hljs-number">0xff</span>&lt;&lt;<span class="hljs-number">8</span>)|(<span class="hljs-number">0xff</span>);  x=(x&amp;test1)+((x&gt;&gt;<span class="hljs-number">16</span>)&amp;test1);<span class="hljs-comment">/*再将这32位看成一个整体, 利用掩码 0000 0000 0000 0000 1111 1111 1111 1111将每16位的1的个数变为</span><span class="hljs-comment">                               每32位的1的个数，存入x的对应位置*/</span>                               <span class="hljs-comment">//此时x的数值就变为了原x中所有1的个数</span>  <span class="hljs-keyword">return</span> x;&#125;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/08/09/Hello-World-0/"/>
    <url>/2020/08/09/Hello-World-0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/08/09/hello-world/"/>
    <url>/2020/08/09/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>

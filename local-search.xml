<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>和我一起学PostgreSQL</title>
    <link href="/2021/03/21/%E5%92%8C%E6%88%91%E4%B8%80%E8%B5%B7%E5%AD%A6PostgreSQL/"/>
    <url>/2021/03/21/%E5%92%8C%E6%88%91%E4%B8%80%E8%B5%B7%E5%AD%A6PostgreSQL/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>DataBase</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PostgreSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux-进程</title>
    <link href="/2021/01/01/Operating%E2%80%94-System/"/>
    <url>/2021/01/01/Operating%E2%80%94-System/</url>
    
    <content type="html"><![CDATA[<p>Basic knowledge about OS &amp;&amp; Linux. Solutions about MIT 6.828</p><a id="more"></a><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h2><p>进程是一个正在执行程序的实例，包括了程序代码和它当前的状态（寄存器…）</p><p>一个进程包括三个部分</p><p><img src="/2021/01/01/Operating%E2%80%94-System/Process.png" alt="process contains"></p><p><em>Tips: The differences between process and program</em></p><p><em>Program is just the static text</em></p><p><em>Process is an dynamic entity being executed and has lifecycle</em></p><p><em>So if a program exec two times ,there should be two processes</em></p><h2 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h2><p>四种事件会导致进程的创建:</p><p>1.系统初始化</p><p>2.正在运行的程序执行了创建进程的系统调用</p><p>3.用户请求创建一个新进程</p><p>4.批处理作业的初始化</p><p>新进程都是由一个已存在的进程执行了一个用于创建进程的系统调用而创建。</p><p>在Linux中，只有fork这个系统调用可用来创建进程。</p><p>fork后，创建的子进程会和父进程拥有相同的内存映像、环境变量。通常，子进程会接着执行一个execve之类的系统调用来修改内存映像从而运行一个新的程序。</p><h2 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h2><p>进程终止的条件：</p><p>1.正常退出(自愿的)</p><p>2.出错退出(自愿的) 自愿时通常调用exit系统调用</p><p>3.严重错误(非自愿)</p><p>4.被其他进程杀死(非自愿)//在Linux和Windows中，如果一个进程被杀死，但他创建的进程不会被全部杀死</p><h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><p><img src="/2021/01/01/Operating%E2%80%94-System/%E7%8A%B6%E6%80%81.png" alt="进程状态"></p><p>处于阻塞状态的进程不会参与进程调度，处在运行和就绪状态的进程会在就绪队列中。</p><p>Running-&gt;Block：进程需要等待数据(自发)</p><p>Running-&gt;Ready：调度程序造成(优先级调度、时间片流转…)</p><p>Ready-&gt;Running：调度程序造成</p><p>Block-&gt;Ready：1.进程发起。2.OS发起。</p><h2 id="进程的生命周期"><a href="#进程的生命周期" class="headerlink" title="进程的生命周期"></a>进程的生命周期</h2><img src="/2021/01/01/Operating%E2%80%94-System/lifeline.png" alt="image-20201114151211842" style="zoom: 67%;"><p><strong>I (Idle) state</strong>（空闲状态）</p><p>进程在被创造前需要在进程/线程表中申请一个空间，这时处于SNONE状态</p><p>进程正在被创作时，需要向内存申请存储空间，此时处于SIDL状态。</p><p><strong>A (active) state</strong>（活跃状态）</p><p>当进程处于A状态时，他会有一个或多个线程处于R(ready to run)状态。这些线程必须和其他处于R态的线程共用CPU。CPU同时只能跑一个线程(不考虑多处理器)</p><p>当线程需要等待事件发生或者输入输出时，为了不浪费CPU，他会进入sleep状态并且放弃CPU使用权。当输入/输出结束，线程会被唤醒进入R状态。</p><p>线程可能会被一些信号终止或者开启。当线程被挂起时，他处于T状态，无法执行。</p><p><strong>Z (zombie) state</strong>（僵尸状态）</p><p>当一个进程死亡(结束）时，他会变成僵尸进程。</p><p>僵尸进程除了进程/线程表外不占用其他资源。他只会存活很短的时间，直到他的父进程发出信号，清理进线程表。</p><p>但是当一个进程的父进程先于子进程死亡时/或者无法发出信号时，就会在OS中留下僵尸进程。</p><p>如果OS长时间运行，进程表可能会被僵尸进程塞满，无法再开启新的进程(重启系统)。</p><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="我们为什么需要线程？"><a href="#我们为什么需要线程？" class="headerlink" title="我们为什么需要线程？"></a>我们为什么需要线程？</h2><p>进程模型的抽象让我们不必再考虑CPU中断，时钟周期，上下文切换之类的底层内容，只要考虑并行进程即可。</p><p>但对于很多进程来说，他们还需要一种能够共享存储空间与数据的能力(例如word文档，他需要有定时保存，同时修改多页内容等功能)</p><p>而且使用线程后可以将某些阻塞的活动(IO)的时间用来进行其他功能，可增大CPU利用率。</p><p>而且线程相对于进程来说是一个更加轻量级的模型，更容易被创建、结束。</p><p>典型的例子就是word、web服务器…</p><hr><p>在没有多线程的情况下，我们通过有限状态机这样的设计实现Web服务器</p><p>即使用非阻塞版本的系统调用来进行IO，再有需求进来时，会进行新工作。</p><p>在这种设计中，“顺序进程”模型消失了，但进程每次切换工作时都要将先前内容进行存储。</p><p>可以认为我们模拟了线程及其堆栈。</p><table><thead><tr><th align="center">模型</th><th align="center">特性</th></tr></thead><tbody><tr><td align="center">多线程</td><td align="center">并行、阻塞系统调用</td></tr><tr><td align="center">单线程进程</td><td align="center">无并行性、阻塞系统调用</td></tr><tr><td align="center">有限状态机</td><td align="center">并行性、非阻塞系统调用、中断</td></tr></tbody></table><h2 id="经典线程、POSIX线程"><a href="#经典线程、POSIX线程" class="headerlink" title="经典线程、POSIX线程"></a>经典线程、POSIX线程</h2><img src="/2021/01/01/Operating%E2%80%94-System/传统线程.png" alt="传统线程" style="zoom: 67%;"><p>在图a中可以看到三个传统的进程，每个进程有自己的地址空间和一个控制线程。</p><p>图b中可以看到一个进程拥有三个控制线程，且运行在同一地址空间。</p><p>在多线程进程中，所有线程都共享完全一样的地址空间，也就是共享同样的全局变量，且线程之间是不存在保护的。</p> <img src="/2021/01/01/Operating%E2%80%94-System/进线程内容.png" style="zoom:67%;"><p>上图给出了进线程中所包含的内容。</p><p>有了线程的概念后，<strong>可以把进程当作资源管理的单位，线程当做执行的单位</strong>。</p><hr><p><strong>每个线程都有自己的堆栈</strong></p><p>假设有下面这样的情况：过程X调用Y，Y调用Z，当Z执行时，XYZ使用的栈帧都会存在堆栈中。而每个线程往往会执行不同的过程，这就让他们有各自不同的历史，也就是每个线程都要有自己的堆栈。</p><p><em>线程也可以创造线程，且线程间一般不会存在父子关系</em></p><hr><p><strong>POSIX线程</strong></p><p><a href="https://blog.csdn.net/dreams_deng/article/details/104201715">POSIX提供了很多系统调用来实现线程</a></p><p> 通过一个求PI的程序来说明。    </p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pthread.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><span class="hljs-keyword">double</span> PI;<span class="hljs-keyword">long</span> num_thread;<span class="hljs-keyword">long</span> N;<span class="hljs-keyword">double</span> tim;<span class="hljs-keyword">pthread_t</span>* threads;<span class="hljs-keyword">pthread_mutex_t</span> lock;<span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* ID)</span></span><span class="hljs-function"></span>&#123;      <span class="hljs-keyword">long</span> id=(<span class="hljs-keyword">long</span>)ID;<span class="hljs-keyword">int</span> length=N/num_thread;<span class="hljs-keyword">int</span> i;pthread_mutex_lock(&amp;lock);<span class="hljs-keyword">for</span>(i=id*length;i&lt;(id+<span class="hljs-number">1</span>)*length;i++)&#123;PI+=(<span class="hljs-number">4.0</span>/N)*(<span class="hljs-number">1.0</span>/(<span class="hljs-number">1</span>+((i+<span class="hljs-number">0.5</span>)/N)*((i+<span class="hljs-number">0.5</span>)/N)));&#125;pthread_mutex_unlock(&amp;lock);&#125;      <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Please input the num of threads\n&quot;</span>);<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%ld&quot;</span>,&amp;num_thread);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Please input the N of calculator\n&quot;</span>);<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%ld&quot;</span>,&amp;N);<span class="hljs-keyword">clock_t</span> start,<span class="hljs-built_in">end</span>;start=clock();threads=(<span class="hljs-keyword">pthread_t</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">pthread_t</span>)*num_thread);<span class="hljs-keyword">long</span> i;<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;num_thread;i++)&#123;        pthread_create(&amp;threads[i],<span class="hljs-literal">NULL</span>,thread,(<span class="hljs-keyword">void</span>*)i);&#125;<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;num_thread;i++)&#123;pthread_join(threads[i],<span class="hljs-literal">NULL</span>);&#125;<span class="hljs-built_in">end</span>=clock();tim=(<span class="hljs-keyword">double</span>)(<span class="hljs-built_in">end</span>-start)/CLOCKS_PER_SEC;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Running Time: %fs\n&quot;</span>,tim);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;PI= %.15f\n&quot;</span>,PI);        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;  </code></pre><h2 id="在用户-内核中实现线程"><a href="#在用户-内核中实现线程" class="headerlink" title="在用户/内核中实现线程"></a>在用户/内核中实现线程</h2><p><strong>1.在用户空间实现线程</strong></p><p>此时内核并没有线程的概念，他仍然只会对进程进行调度。此时线程的实现需要用户级程序去完成。</p><p>其实现大都使用pthread的系统调用。</p><p>同时，在用户空间管理线程时，每个进程也要有对应的线程表来记录进程中的线程。</p><p><strong>优点：</strong></p><p><strong>1.线程间切换很快</strong></p><p>当一个线程引发了自己的阻塞，那么他就会存储自己的状态，并在线程表中查看可运行的线程，将新线程的保存值重新装入机器的寄存器中。</p><p>因此，只要堆栈指针和程序计数器一被切换，新的线程就会自动运行。</p><p>这样的切换要比陷入内核来说更快。</p><p><strong>2.每个进程可以有自己的调度算法，且扩展性强</strong></p><p>可让用户程序自定义线程的运行状态。内核线程需要一些固定的表格空间和堆栈，如果内核线程数量很大就会出现问题。</p><hr><p><strong>缺点：</strong></p><p>1.如何实现阻塞系统调用</p><p>线程的目标是允许每个线程使用阻塞调用，且要避免被阻塞的线程影响其他线程。</p><p>2.starvation问题</p><p>如果一个线程开始运行，那么在该进程中的其他线程都无法运行。除非该线程主动放弃CPU。</p><p>由于在进程中不会有中断的概念，所以无法使用轮转调度的方法调度线程。</p><p>3.最大问题出现在本身</p><p>程序员通常会在经常发生线程阻塞的应用中才希望使用多线程。</p><p>但在一个服务器中，线程一直在进行着系统调用，如果原有线程阻塞，就很难让内核进行线程切换。否则就一直使用select系统调用。</p><p>但这样的话多线程的意义就不大了，并没有什么实质性的好处。</p><h1 id="调度程序-Important"><a href="#调度程序-Important" class="headerlink" title="调度程序(Important)"></a>调度程序(Important)</h1><p>在计算机中，如果有多个进程处于就绪状态，而只有一个CPU可用，那么OS就必须对下一个要运行的进程进行选择。完成这个工作的就是调度程序。</p><p>早期的批处理系统中的调度程序就是：顺序执行磁带上的每一个作业。由于那时CPU是稀缺资源，所以调度程序的作用十分重要。</p><p>但随着PC的普及以及CPU速度的快速增长，OS中多数时间只有一个活动进程，而且时间大多花费在等待用户输入，而非等待CPU计算。</p><p>但在Web服务器中，经常会有多个进程抢占CPU，此时的调度程序又十分重要。</p><p><strong>为什么要好的调度程序？</strong></p><p>因为进程切换的代价是十分高昂的：要先从用户态切换到内核态；保存进程状态；调度选择新进程；将新进程的内存印象装入MMU，开始运行。</p><p>如果调度程序每秒切换进程次数太多，会耗费大量CPU时间。</p><h2 id="何时调度进程？"><a href="#何时调度进程？" class="headerlink" title="何时调度进程？"></a>何时调度进程？</h2><p>1.在创建一个新进程后，需要决定是运行父进程还是子进程</p><p>2.在一个进程退出时必须调度</p><p>3.进程阻塞时必须调度</p><p>4.一个IO中断发生时必须调度</p><h2 id="调度算法分类及其目标"><a href="#调度算法分类及其目标" class="headerlink" title="调度算法分类及其目标"></a>调度算法分类及其目标</h2><p>对于所有系统，使用调度程序的目标都是要实现：公平(每个进程有公平的CPU份额)、策略强制执行(规定的策略被执行)、平衡(系统的所有部分都忙碌)</p><p>在不同系统中，需要的调度程序的类型、目标也不同，可划分为三组环境：</p><p>1.批处理(Batch System)</p><p>其目标要实现：吞吐量、周转时间、CPU利用率的最优。</p><p>2.交互式(Interactive System)</p><p>其目标为：实现响应时间、均衡性的最优。</p><p>3.实时(Real-time System)</p><p>其目标为：满足截止时间(避免丢失数据)、可预测性</p><h2 id="批处理系统中的调度-Important"><a href="#批处理系统中的调度-Important" class="headerlink" title="批处理系统中的调度(Important)"></a><font color="red">批处理系统中的调度(Important)</font></h2><h3 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h3><p>按照进程请求CPU的顺序来使用CPU。类似于队列的FIFO机制，优点在于公平且思路简单。</p><p>但缺点也很明显：<strong>护航效应</strong>。</p><p>假如此时有一个CPU密集型和一个IO密集型的进程在就绪队列中，CPU密集型的进程在CPU中执行一段时间，进入IO；此时IO密集型进程进入CPU，执行很短很短的时间也进入IO；此时CPU空闲，CPU密集型进程再次进入就绪队列，IO进程又会等待CPU密集型进程完成。</p><p>可以看到，在这种情况下，IO进程总是在等待着计算密集型进程使用完CPU，从而导致运行时间很长。</p><p>如果有可能让IO进程直接单独抢占一段时间，那么运行时间会大大减少。</p><p><em>可通过下图理解进程执行的过程，并不是一直使用CPU然后一直使用IO就结束了，而是交错着的</em></p><img src="/2021/01/01/Operating%E2%80%94-System/密集型.png" style="zoom:50%;"><h3 id="最短作业优先"><a href="#最短作业优先" class="headerlink" title="最短作业优先"></a>最短作业优先</h3><p><em>由于需要知道运行时间，因此多用于专用OS，但可能出现starvation问题</em></p><h3 id="最短剩余时间优先"><a href="#最短剩余时间优先" class="headerlink" title="最短剩余时间优先"></a>最短剩余时间优先</h3><p><em>由于需要知道剩余运行时间，只能在专用OS使用</em></p><h3 id="高响应比优先"><a href="#高响应比优先" class="headerlink" title="高响应比优先"></a>高响应比优先</h3><p>响应比的计算:Response Radio = Turnaround time / Executing time = 1 + Waiting Time/ Executing Time</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>在一单道批处理系统中，一组作业的提交时刻和运行时间如下表所示。试计算一下三种作业调度算法的平均周转时间 T 和平均带权周转时间 W。 (1) 先来先服务; (2) 短作业优先 (3) 高响应比优先。作业提交时刻和运行时间如下表</p><p><img src="/2021/01/01/Operating%E2%80%94-System/%E4%BE%8B%E9%A2%98.png" alt="例题"></p><p>1.先来先服务</p><p>根据题目可得到以下数据</p><table><thead><tr><th>作业</th><th>提交时刻</th><th>运行时间</th><th align="left">开始时间</th><th>完成时间</th><th>周转时间</th><th>带权周转时间</th></tr></thead><tbody><tr><td>1</td><td>8.0</td><td>1.0</td><td align="left">8.0</td><td>9.0</td><td>1.0</td><td>1.0</td></tr><tr><td>2</td><td>8.5</td><td>0.5</td><td align="left">9.0</td><td>9.5</td><td>1.0</td><td>2.0</td></tr><tr><td>3</td><td>9.0</td><td>0.2</td><td align="left">9.5</td><td>9.7</td><td>0.7</td><td>3.5</td></tr><tr><td>4</td><td>9.1</td><td>0.1</td><td align="left">9.7</td><td>9.8</td><td>0.7</td><td>7.0</td></tr></tbody></table><p>所以平均周转时间T=(1.0+1.0+0.7+0.7)/4=0.85</p><p>平均带权周转时间W=(1.0+2.0+3.5+7.0)/4=3.375</p><p>2.短作业优先</p><p>可知在8.0时系统中只有作业1，所以作业1仍为第一个执行的。</p><p>作业1执行完成时间为9.0</p><p>此时系统中有作业2,3两个作业，短作业优先选择作业3</p><p>作业3执行完成时间为9.2</p><p>此时系统中有作业2,4两个作业，短作业优先选择作业4</p><p>作业4执行完成时间为9.3</p><p>此时只有作业2</p><p>作业2执行完成时间为9.8</p><p>表格如下</p><table><thead><tr><th>作业</th><th>提交时刻</th><th>运行时间</th><th align="left">开始时间</th><th>完成时间</th><th>周转时间</th><th>带权周转时间</th></tr></thead><tbody><tr><td>1</td><td>8.0</td><td>1.0</td><td align="left">8.0</td><td>9.0</td><td>1.0</td><td>1.0</td></tr><tr><td>3</td><td>9.0</td><td>0.2</td><td align="left">9.0</td><td>9.2</td><td>0.2</td><td>1.0</td></tr><tr><td>4</td><td>9.1</td><td>0.1</td><td align="left">9.2</td><td>9.3</td><td>0.2</td><td>2.0</td></tr><tr><td>2</td><td>8.5</td><td>0.5</td><td align="left">9.3</td><td>9.8</td><td>1.3</td><td>2.6</td></tr></tbody></table><p>可以得到</p><p>平均周转时间T=(1+0.2+0.2+1.3)/4=0.675</p><p>平均带权周转时间W=(1.0+1.0+2.0+2.6)/4=1.65</p><p>3.高响应比优先</p><p>同样8.0时系统只有作业1，执行作业1</p><p>作业1执行完成时间为9.0</p><p>此时系统中有作业2,3</p><p>此时作业2 response radio=(1+0.5/0.5)=2; 作业3 response radio=1</p><p>所以先执行作业2</p><p>作业2执行完成时间为9.5</p><p>此时系统中有作业3,4</p><p>此时作业3的response radio=(1+0.5/0.2)=3.5</p><p>作业4的response radio =（1+0.4/0.1）=5</p><p>所以先执行作业4</p><p>作业4执行完时间为9.6</p><p>执行作业3</p><p>执行完成时间为9.8</p><p>可列为如下表格</p><table><thead><tr><th>作业</th><th>提交时刻</th><th>运行时间</th><th align="left">开始时间</th><th>完成时间</th><th>周转时间</th><th>带权周转时间</th></tr></thead><tbody><tr><td>1</td><td>8.0</td><td>1.0</td><td align="left">8.0</td><td>9.0</td><td>1.0</td><td>1.0</td></tr><tr><td>2</td><td>8.5</td><td>0.5</td><td align="left">9.0</td><td>9.5</td><td>1.0</td><td>2.0</td></tr><tr><td>4</td><td>9.1</td><td>0.1</td><td align="left">9.5</td><td>9.6</td><td>0.5</td><td>5.0</td></tr><tr><td>3</td><td>9.0</td><td>0.2</td><td align="left">9.6</td><td>9.8</td><td>0.8</td><td>4.0</td></tr></tbody></table><p>可知平均周转时间T=(1+1+0.5+0.8)/4=0.825</p><p>平均带权周转时间W=(1+2+5+4)/4=3</p><h3 id="区分一下带权周转时间和响应比的概念"><a href="#区分一下带权周转时间和响应比的概念" class="headerlink" title="区分一下带权周转时间和响应比的概念"></a>区分一下带权周转时间和响应比的概念</h3><p><strong>二者虽然看上去计算公式相同，但他们的性质是不同的</strong></p><p><strong>带权周转时间是在调度完成后评价该调度程序的一个指标，是静态的</strong></p><p><strong>而响应比是作为调度的一个条件来使用的，每当调度一次后，每个作业的响应比都会变化。是动态的。</strong></p><h2 id="交互式系统中的调度-Important"><a href="#交互式系统中的调度-Important" class="headerlink" title="交互式系统中的调度(Important)"></a><font color="red">交互式系统中的调度(Important)</font></h2><h3 id="Round-robin-scheduling-轮转调度"><a href="#Round-robin-scheduling-轮转调度" class="headerlink" title="Round-robin scheduling (轮转调度)"></a>Round-robin scheduling (轮转调度)</h3><p>这是最简单、公平、使用最广的调度算法.</p><p>每个进程被分配一个<strong>时间片</strong>，即允许该进程在该时间段中运行。如果进程在时间片结束时还在运行，那就夺走CPU分配给下一个进程。如果进程在时间片结束前就完成或者阻塞，CPU就立即进行切换。</p><p>调度程序要做的就是维护一个可运行程序列表，并对使用完时间片的程序进行调整。</p><p><strong>唯一要考虑的就是时间片的长度</strong></p><p>时间片太短会导致进程切换过于频繁，降低CPU效率。太长又会引起对短的交互请求的不响应。</p><p>常将时间片设置在20~50ms之间</p><h3 id="Priority-scheduling-优先级调度"><a href="#Priority-scheduling-优先级调度" class="headerlink" title="Priority scheduling (优先级调度)"></a>Priority scheduling (优先级调度)</h3><p>在Round-robin中，我们把每个进程都看作同等重要，而优先级调度就是要改变这种想法，给每个进程赋予一个优先级，优先级高的进程会先运行。</p><p>为了防止高优先级进程一直运行下去，调度程序可能在每个时钟中断时降低其优先级，如果有高于其的进程，就开始调度。</p><p>也可以给每个进程设置一个允许允许的最大时间片，超过时间片后次高级进程就会运行。</p><img src="/2021/01/01/Operating%E2%80%94-System/优先级.png" style="zoom:67%;"><h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><h3 id="用户态线程"><a href="#用户态线程" class="headerlink" title="用户态线程"></a>用户态线程</h3><p>内核并不知道线程的存在，因此还是会直接对线程使用调度程序。</p><p>此时由进程中的线程调度程序来决定线程的运行。由于这里面并不存在时钟中断，所以线程可以按其意愿任意运行直到进程时间用完。</p><h3 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h3><p>此时内核选择特定的线程运行，且不用考虑线程属于哪个进程。可以分配时间…</p><p>&nbsp;</p><p>二者的差别主要在于性能。</p><p>用户级线程的切换只需要少量指令，但内核级线程切换需要上下文切换,修改内存，高速缓存…</p><p>但内核级线程如果阻塞，并不用直接将整个进程挂起。</p><p><em>另外，从A的线程切换到B的线程的代价高于在一个进程中切换线程，因此，在有多种选择的情况下，倾向于在相同进程中切换线程。</em></p><h1 id="进程间通信（Inter-Process-Communication-IPC）"><a href="#进程间通信（Inter-Process-Communication-IPC）" class="headerlink" title="进程间通信（Inter Process Communication, IPC）"></a><font color="red">进程间通信（Inter Process Communication, IPC）</font></h1><p>进程间往往需要相互传递信息（例如你使用shell中的管道，她将一个进程的输出传递给另一个进程）。</p><h2 id="IPC的三个问题"><a href="#IPC的三个问题" class="headerlink" title="IPC的三个问题"></a>IPC的三个问题</h2><ol><li>一个进程如何把信息传递给另一个。</li><li>如何确保两个/多个进程在关键活动中不会出现交叉。（比如12306的购票系统）</li><li>如何确保多个进程之间有正确的执行顺序（一个更改数据的操作和一个print操作，当数据更改后再print才是正确的）</li></ol><p><strong>下面我们来解决这三个问题</strong></p><h2 id="基础概念（竞争条件-amp-临界区）"><a href="#基础概念（竞争条件-amp-临界区）" class="headerlink" title="基础概念（竞争条件&amp;临界区）"></a>基础概念（竞争条件&amp;临界区）</h2><p><strong>竞争条件</strong>：<strong>多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序的情况</strong>。</p><p>我们要实现IPC就要思考如何避免竞争条件？</p><p>关键是使用一种方法来<strong>阻止多个进程同时读写共享的数据</strong>。即实现<strong>mutual exclusion</strong>（互斥）：一个进程使用共享数据时，其他进程不能做同样的操作。</p><p>我们可以把阻止多进程同时读写共享数据的问题进行抽象，把对共享内存进行访问的<strong>程序片段</strong>称为<strong>临界区域/临界区</strong>（critical region）。</p><p>All we need to do is 是<strong>两个进程不可能同时处于临界区。</strong></p><p>更进一步，为了确保进程能够正确且高效地协作，我们对于一个好的解决方法<strong>提出4个要求：</strong></p><p><strong>1）任何两个进程不能同时在临界区中</strong></p><p>2）不对CPU的速度和数量做任何假设</p><p><strong>3）临界区外运行的进程不得阻塞其他进程</strong></p><p>4）不得使进程无限期等待进入临界区</p><hr><h2 id="忙等待-busy-waiting-的互斥"><a href="#忙等待-busy-waiting-的互斥" class="headerlink" title="忙等待(busy waiting)的互斥"></a>忙等待(busy waiting)的互斥</h2><p>本部分可行的解决方案都有一个<strong>特征</strong>：在无法进入临界区时，他们都会<strong>持续地占据CPU时间直到被调度（不会主动放弃）</strong>。所以称为busy waiting。</p><h3 id="一、屏蔽中断"><a href="#一、屏蔽中断" class="headerlink" title="一、屏蔽中断"></a>一、屏蔽中断</h3><p><strong>这是最简单粗暴的方法</strong></p><p>对于单处理器来说，在进程进入临界区后立即屏蔽所有中断，在离开前打开中断是最直接的方法。因为屏蔽中断后，时钟中断也被屏蔽——CPU不会调度其他进程。</p><p>其<strong>缺点</strong>在于给了<strong>用户程序太大的权力</strong>，一旦一个进程不再打开中断，那么整个OS/多核中的一个核就会终止运行。</p><p>屏蔽中断对于OS来说很好，在更新数据时屏蔽中断可以确保短时间内完成，同时也确保执行的正确。</p><p>总的来说：屏蔽中断对OS来说很有用，但对于用户程序来说并不是一个明智的解决方法。</p><h3 id="二、锁变量"><a href="#二、锁变量" class="headerlink" title="二、锁变量"></a>二、锁变量</h3><p>一种软件解决方法。设置一个共享锁变量，进入临界区前要先开锁才能进入。</p><p>但这种解决方法是不行的，只是一个<strong>套娃的方法</strong>。设想下面的情况：</p><p>如果一个进程在读锁变量为0后，在准备将其<strong>设置为1之前被调度</strong>；新调度的<strong>进程将其设置为1</strong>，<strong>进入临界区</strong>。</p><p>此时再返回第一个进程，他也会将锁变量设为1，也进入临界区。</p><p>此时临界区中有两个程序。</p><p>So，这种方法只<strong>是转移了矛盾，并没有根本解决矛盾</strong>。</p><h3 id="三、严格轮换法"><a href="#三、严格轮换法" class="headerlink" title="三、严格轮换法"></a>三、严格轮换法</h3><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> turn=<span class="hljs-number">0</span>;<span class="hljs-comment">/*进程 0*/</span><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;    <span class="hljs-keyword">while</span>(turn!=<span class="hljs-number">0</span>)    critical_region();    turn=<span class="hljs-number">1</span>;    noncritical_region();&#125;<span class="hljs-comment">/*进程 1*/</span><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;    <span class="hljs-keyword">while</span>(turn!=<span class="hljs-number">1</span>)    critical_region();    turn=<span class="hljs-number">0</span>;    noncritical_region();&#125;</code></pre><p><em>功能描述：</em> 进程0首先检查turn为0，进入临界区；进程1检查turn为0，执行循环一直检查turn直至为1.（busy waiting!）</p><p><em>但这种解法也是存在问题的。</em></p><p>如果进程0是一个临界区密集型进程，进程1是一个非临界区密集型进程。</p><p>当进程0结束临界区操作，将turn设置为1。进程0迅速完成非临界区操作，而进程1正在忙于非临界区操作。此时进程0无法进入临界区(此时turn==1),进程1也不进入临界区。</p><p>这就<strong>违背了前面4个要求中的第3个：进程0被在临界区外的进程1阻塞无法进入临界区。</strong></p><p><strong>说明在一个进程比另一个慢得多的情况下，该严格轮换法并不太好。</strong></p><h3 id="四、Peterson解法-针对两个进程"><a href="#四、Peterson解法-针对两个进程" class="headerlink" title="四、Peterson解法   (针对两个进程)"></a>四、Peterson解法   (针对两个进程)</h3><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FALSE 0</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TRUE 1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 2 <span class="hljs-comment">//进程数量</span></span><span class="hljs-keyword">int</span> turn; <span class="hljs-comment">//轮到谁？</span><span class="hljs-keyword">int</span> interested[N]=&#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">//所有值初始化为0</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enter_region</span><span class="hljs-params">(<span class="hljs-keyword">int</span> process)</span><span class="hljs-comment">/*进程号*/</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> other;    <span class="hljs-comment">/*另一进程号*/</span>    other=<span class="hljs-number">1</span>-process;    interested[process]=TRUE;<span class="hljs-comment">/*表示感兴趣*/</span>    turn = process;<span class="hljs-comment">/*设置标志*/</span>    <span class="hljs-keyword">while</span>(turn==process&amp;&amp;interested[other]==TRUE); <span class="hljs-comment">/*空语句*/</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">leave_region</span><span class="hljs-params">(<span class="hljs-keyword">int</span> process)</span> <span class="hljs-comment">/*离开的进程*/</span></span><span class="hljs-function"></span>&#123;    interested[process]=FALSE;<span class="hljs-comment">/*离开临界区*/</span>&#125;</code></pre><p>在<strong>进入临界区之前</strong>，各个进程使用自己的进程号（0/1）**调用enter_region()**。</p><p>在<strong>完成临界区操作</strong>后，**调用leave_region()**。</p><p>即当turn==自己 且 另一个进程没有离开临界区时，自己不能进入。</p><p>如果两个进程几乎同时调用enter_region, 但进程0比1先存turn，那么最后turn==1。此时进程0可以进入临界区，进程1只能等待。</p><p><strong>Attention：enter_region中的 turn 和 interest 设置顺序不能颠倒</strong></p><p>假设现在已经颠倒 <em>变成酱紫 ↓↓↓</em></p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enter_region</span><span class="hljs-params">(<span class="hljs-keyword">int</span> process)</span><span class="hljs-comment">/*进程号*/</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> other;    <span class="hljs-comment">/*另一进程号*/</span>    other=<span class="hljs-number">1</span>-process;    turn = process;<span class="hljs-comment">/*设置标志*/</span>    interested[process]=TRUE;<span class="hljs-comment">/*表示感兴趣*/</span>    <span class="hljs-keyword">while</span>(turn==process&amp;&amp;interested[other]==TRUE); <span class="hljs-comment">/*空语句*/</span>&#125;</code></pre><p>如果进程0在将turn设置为0后被调度，进程1发现进程0没有interested，进入临界区。</p><p>此时调度回进程0，进程0发现turn！=0, 进入临界区。</p><p>此时有两个进程同时在临界区里，so… 出问题了。</p><p><strong>进一步，我们思考一下peterson算法背后的思想以及为什么交换顺序后就不行</strong></p><p>peterson算法的思想就是：类似孔融让梨，<strong>使用一个数组来表达每个进程想进入临界区的意图。每个进程要先表明自己的意图。最后一个进程要“让梨”，即如果turn是自己且对方想进入临界区，那自己就等待，让对方使用。</strong></p><p>那么我们交换顺序后，就会出现一种情况：对方还没来得及表明意图，另一个进程就抢先看自己让不让梨（有些虚伪的感觉），结果对方还没说话你就抢过来话筒当然就不用让了，直接进入临界区。但此时对方却认为另一个人会让梨，于是自己也进入临界区。</p><p>so…. 就出现了如此的尴尬局面。</p><h3 id="五、TSL指令"><a href="#五、TSL指令" class="headerlink" title="五、TSL指令"></a>五、TSL指令</h3><p><strong>这是一种硬件支持方案</strong></p><pre><code class="hljs bash">TSL RX, LOCK</code></pre><p>称为测试并加锁(test and set lock) 是一个<strong>原语操作</strong>，作用是将一个内存字lock读到寄存器RX中，同时写lock=1。然后在该内存地址上存一个非零值。</p><p>执行TSL指令的CPU将<strong>锁住内存总线</strong>，禁止其他CPU在本指令结束前访问内存。</p><pre><code class="hljs bash">enter_region:TSL REGISTER,LOCK|复制锁到寄存器并将锁设为1CMP REGISTER,<span class="hljs-variable">$0</span> |判断锁是否为0JNE enter_region|若非0，说明锁已被设置，进入busy waiting的循环RETleave_region:MOVE LOCK,<span class="hljs-variable">$0</span>|锁中存0RET        |<span class="hljs-built_in">return</span></code></pre><p>与peterson的使用类似</p><p>在进入临界区前，调用enter_region，将导致busy waiting直到锁空闲为止。</p><p>在离开临界区时，调用leave_region，将lock设置为0；</p><p>在intel的指令集中也有这样的操作：XCHG</p><h2 id="睡眠与唤醒（Sleep-and-wakeup）的互斥"><a href="#睡眠与唤醒（Sleep-and-wakeup）的互斥" class="headerlink" title="睡眠与唤醒（Sleep and wakeup）的互斥"></a>睡眠与唤醒（Sleep and wakeup）的互斥</h2><p>peterson算法和TSL解法都是正确的，但他们都有忙等待的缺点——不仅会浪费时间，还会可能引起意外的结果。</p><p>设想一台计算机有两个进程：H与L，H优先级高于L。调度规则是：只要H处于就绪状态就可运行。若此时，L在critical region 那么H就处于就绪态，开始busy waiting。但由于H就绪时，L不会被调度(OS认为H就绪时就会运行，而且H优先级高于L，因此OS也不会主动对运行的H进行调度)，L也就无法离开临界区。H将永远等待下去。</p><p>上述情况称为 <strong>优先级反转问题</strong>。</p><p>所以，我们需要一种新的不同于busy waiting的解决方案来进行IPC。</p><p><strong>所以有了sleep和wakeup这几条IPC原语，他们在无法进入临界区时将阻塞而不是busy waiting</strong></p><p>sleep是一个引起调用进程阻塞的系统调用，即背挂起，直到被其他进程唤醒。</p><p>wakeup就是唤醒的进程咯QWQ！</p><p><em>呜，2021/1/1日的早上图书馆是真没人啊，哈哈哈哈，好喜欢这种感觉！！！哈哈哈哈哈哈哈哈哈哈！</em></p><p>使用sleep和wakeup来解决一下生产者-消费者问题。</p><p>问题描述：两个进程共享一个公共的固定大小的缓冲区，其中一个是<strong>生产者</strong>：将信息放入缓冲区。另一个是<strong>消费者</strong>：从缓冲区中读取信息。</p><p>要解决的主要问题是<strong>当缓冲区已满，生产者无法在放入新数据，让他睡眠。当缓冲区为空时，消费者睡眠直到生产者向其中放入一些数据后再将其唤醒。</strong></p><p><em>code here ↓↓↓</em></p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 100</span><span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">producer</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> item;    <span class="hljs-keyword">while</span>(TRUE)&#123;        item=produce_item();        <span class="hljs-keyword">if</span>(count==N)        sleep();        insert_item(item);        count=count+<span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(count==<span class="hljs-number">1</span>)        wakeup(consumer);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> item;    <span class="hljs-keyword">while</span>(TRUE)&#123;        <span class="hljs-keyword">if</span>(count==<span class="hljs-number">0</span>)        sleep();        item=remove_item();        count=count<span class="hljs-number">-1</span>;        <span class="hljs-keyword">if</span>(count==N<span class="hljs-number">-1</span>)        wakeup(producer);        consume_item(item);    &#125;&#125;</code></pre><p><strong>但这里还是会有竞争条件的——因为没有对count访问加限制。</strong>设想下面这种情况：</p><p>缓冲区为空，消费者发现count==0，正准备sleep并叫醒生产者。但OS此时调度生产者，生产者产生数据，count=1。生产者认为消费者现在一定在sleep，于是wakeup他，但此时消费者并没有睡眠。所以造成了一个wakeup信号丢失。</p><p>当消费者下次运行时，直接睡眠，生产者在数据产生完后也睡眠。</p><p>emmm，他们就这样一起睡下去了。</p><p><em>一种简单的解决方法是给消费者加一个唤醒等待位。类似spooling，就是wakeup信号的一个存储区。</em></p><h2 id="信号量-Semaphore-的互斥与同步"><a href="#信号量-Semaphore-的互斥与同步" class="headerlink" title="信号量(Semaphore)的互斥与同步"></a><font color="red">信号量(Semaphore)的互斥与同步</font></h2><p>信号量是0或者大于0的整数。</p><p>信号量只能被PV操作控制 (初始化除外；即使只想要读信号量的值也要通过PV)</p><p><em>PV操作是原子操作</em>&emsp;</p><p>P操作检查信号量，若大于0则将其减1。若等于0，则进程睡眠，且此时P操作并未结束。</p><p>V操作对信号量的值增加1,若一个或多个进程在该信号量上睡眠，则挑选一个允许完成其P操作。</p><p><strong>PV在sleep wakeup的实现</strong></p><pre><code class="hljs c++"><span class="hljs-comment">/*P operation*/</span>P(Semaphore S)&#123;S=S<span class="hljs-number">-1</span>;    <span class="hljs-keyword">if</span>(S&lt;<span class="hljs-number">0</span>)&#123;        added to the semaphore<span class="hljs-number">&#x27;</span>s <span class="hljs-built_in">queue</span> <span class="hljs-keyword">and</span> sleep;    &#125;&#125;<span class="hljs-comment">/*V operation*/</span>V(Semaphore S)&#123;    S=S+<span class="hljs-number">1</span>;    <span class="hljs-keyword">if</span>(S&lt;<span class="hljs-number">0</span>)&#123;        wake up waiting <span class="hljs-built_in">process</span> in the semaphore<span class="hljs-number">&#x27;</span>s <span class="hljs-built_in">queue</span>;    &#125;&#125;</code></pre><p><strong>PV在忙等待中的实现</strong></p><pre><code class="hljs c++"><span class="hljs-comment">/*P operation*/</span>P(Semaphore S)&#123;    <span class="hljs-keyword">while</span>(!S&gt;<span class="hljs-number">0</span>)    <span class="hljs-built_in">yield</span> the CPU;    S--;&#125;<span class="hljs-comment">/*V operation*/</span>V(Semaphore S)&#123;    S++;&#125;</code></pre><p><strong>下面使用信号量来解决生产者消费者问题</strong></p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 100</span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> semaphore;semaphore mutex=<span class="hljs-number">1</span>;semaphore empty=N;semaphore full=<span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">producer</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> item;    <span class="hljs-keyword">while</span>(TRUE)&#123;        item=prodece_item();<span class="hljs-comment">//产生数据</span>        P(&amp;empty);<span class="hljs-comment">//空槽--</span>        P(&amp;mutex);<span class="hljs-comment">//进入临界区</span>        inster_item();<span class="hljs-comment">//数据放入临界区</span>        V(&amp;mutex);<span class="hljs-comment">//离开临界区</span>        V(&amp;full);<span class="hljs-comment">//满槽++</span>    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> item;    <span class="hljs-keyword">while</span>(TRUE)&#123;        P(&amp;full);<span class="hljs-comment">//满槽--</span>        P(&amp;mutex);<span class="hljs-comment">//进入临界区</span>        item=remove_item();<span class="hljs-comment">//从缓冲区读出数据</span>        V(&amp;mutex);<span class="hljs-comment">//离开临界区</span>        V(&amp;empty);<span class="hljs-comment">//空槽++</span>        consume_item(item);<span class="hljs-comment">//处理数据</span>    &#125;&#125;</code></pre><p><strong>注意，对full和empty的P操作必须在mutex之前</strong></p><p>设想以下情况：假如生产者已经将缓存填满，若先对mutex进行P操作，在执行P(empty)会被阻塞，希望消费者唤醒它。但消费者先执行P(mutex)也被阻塞，此时二者都被阻塞。</p><p>但在V操作时，并没有先后顺序。</p><h2 id="哲学家就餐问题-同步"><a href="#哲学家就餐问题-同步" class="headerlink" title="哲学家就餐问题(同步)"></a><font color="red">哲学家就餐问题(同步)</font></h2><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 5 <span class="hljs-comment">/*哲学家数目*/</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LEFT (i+N-1)%N <span class="hljs-comment">/*i的左邻居编号*/</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RIGHT (i+1)%N <span class="hljs-comment">/*i的右邻居编号*/</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> THINKING 0 <span class="hljs-comment">/*哲学家在思考*/</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HUNGRY 1 <span class="hljs-comment">/*哲学家试图拿起叉子*/</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EATING 2 <span class="hljs-comment">/*哲学家进餐*/</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> semaphore;<span class="hljs-keyword">int</span> state[N];<span class="hljs-comment">/*记录每位哲学家的状态*/</span>semaphore mutex=<span class="hljs-number">1</span>;<span class="hljs-comment">/*临界区互斥*/</span>semaphore s[N];<span class="hljs-comment">/*每个哲学家一个信号量*/</span><span class="hljs-comment">/*检查哲学家是否可以就餐*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i<span class="hljs-comment">/*每个哲学家编号*/</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(state[i]==HUNGRY&amp;&amp;state[LEFT]!=EATING&amp;&amp;state[RIGHT]!=EATING)&#123;        state[i]=EATING;        V(&amp;s[i]);    &#125;&#125;<span class="hljs-comment">/*拿叉子，一次拿两个*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">take_forks</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span><span class="hljs-function"></span>&#123;    P(&amp;mutex);    state[i]=HUNGRY;<span class="hljs-comment">/*记录哲学家i处于饥饿状态*/</span>    test(i);<span class="hljs-comment">/*尝试获取两把叉子*/</span>    V(&amp;mutex);    P(&amp;s[i]);<span class="hljs-comment">/*得不到需要的叉子就阻塞*/</span>&#125;<span class="hljs-comment">/*放下叉子*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">put_forks</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span><span class="hljs-function"></span>&#123;    P(&amp;mutex);    state[i]=THINKING;<span class="hljs-comment">/*哲学家就餐完毕*/</span>    test(LEFT);    test(RIGHT);<span class="hljs-comment">/*检查左右是否可吃*/</span>    V(&amp;mutex);&#125;<span class="hljs-comment">/*主函数*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">philosopher</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;        think();        take_forks(i);<span class="hljs-comment">/*获取两把叉子或阻塞*/</span>        eat();        put_forks(i);<span class="hljs-comment">/*放回两把叉子*/</span>    &#125;&#125;</code></pre><h2 id="读者—写者问题-互斥"><a href="#读者—写者问题-互斥" class="headerlink" title="读者—写者问题(互斥)"></a><font color="red">读者—写者问题(互斥)</font></h2><p><strong>读者优先</strong></p><p>解决多个进程读写数据的情况：读者无互斥，读写，写写，有互斥。</p><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> semaphore;semaphore mutex=<span class="hljs-number">1</span>;<span class="hljs-comment">/*控制对reader的访问*/</span>semaphore database=<span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> reader=<span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reader</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;P(&amp;mutex);reader++;<span class="hljs-keyword">if</span>(reader==<span class="hljs-number">1</span>)<span class="hljs-comment">//只需要让第一个读者获取数据库访问权限，其他读者仅需要reader++即可</span>P(&amp;database);V(&amp;mutex);read_database();P(mutex);reader--;<span class="hljs-keyword">if</span>(reader==<span class="hljs-number">0</span>)V(&amp;database);V(&amp;mutex);use_data();&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">writer</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><span class="hljs-function"></span>&#123;<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;P(&amp;database);<span class="hljs-comment">//写者只关心数据库权限是否拥有即可。</span>write_data();V(&amp;database);&#125;&#125;</code></pre><p><strong>只需要让第一个读者获取数据库访问权限</strong>，<strong>其他读者仅需要</strong> <strong>reader++</strong> <strong>即可</strong>。</p><p>而写者关心的问题就比较少了，只需要看是否有其他进程有数据库权限即可(写者和写者、读者间都要互斥)</p><hr><p><strong>写者优先</strong></p><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> semaphore;<span class="hljs-keyword">int</span> rc=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> wc=<span class="hljs-number">0</span>;semaphore db=<span class="hljs-number">1</span>;semaphore rcmutex=<span class="hljs-number">1</span>;semaphore wcmutex=<span class="hljs-number">1</span>;semaphore readable=<span class="hljs-number">1</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reader</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    P(&amp;readable);    P(&amp;rcmutex);    <span class="hljs-keyword">if</span>(rc==<span class="hljs-number">0</span>) P(&amp;db);    rc++;    V(&amp;rcmutex);    V(&amp;readable);    read_data();    P(&amp;rcmutex);    rc--;    <span class="hljs-keyword">if</span>(rc==<span class="hljs-number">0</span>) V(&amp;db);    V(&amp;rcmutex);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">writer</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    P(&amp;wcmutex);    <span class="hljs-keyword">if</span>(wc==<span class="hljs-number">0</span>) P(&amp;readable);    wc++;    V(&amp;wcmutex);    P(&amp;db);    write_data();    V(&amp;db);    P(&amp;wcmutex);    wc--;    <span class="hljs-keyword">if</span>(wc==<span class="hljs-number">0</span>) V(&amp;readable);    V(&amp;wcmutex);&#125;</code></pre><p><strong>读写公平</strong></p><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> semaphore;<span class="hljs-keyword">int</span> rc=<span class="hljs-number">0</span>;semaphore mutex=<span class="hljs-number">1</span>;semaphore db=<span class="hljs-number">1</span>;semaphore fair=<span class="hljs-number">1</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reader</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;        P(&amp;fair);        P(&amp;mutex);        <span class="hljs-keyword">if</span>(rc==<span class="hljs-number">0</span>) P(&amp;db);        rc++;        V(&amp;mutex);        V(&amp;fair);        read_data();        P(&amp;mutex);        rc--        <span class="hljs-keyword">if</span>(rc==<span class="hljs-number">0</span>) V(&amp;db);        V(&amp;mutex);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">writer</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;        P(&amp;fair);        P(&amp;db);        write_data();        V(&amp;db);        V(&amp;fair);    &#125;&#125;</code></pre><h1 id="PV题"><a href="#PV题" class="headerlink" title="PV题"></a>PV题</h1><h2 id="一、嗜睡的理发师"><a href="#一、嗜睡的理发师" class="headerlink" title="一、嗜睡的理发师"></a>一、嗜睡的理发师</h2><p>有一个理发师，一把理发椅和 N 把供等候理发的顾客坐的椅子。如果没有顾客，则理发师便在理发师椅子上睡觉；当一个顾客到来时，必须唤醒理发师进行理发；如果理发师正在理发时又有顾客来到，则如果有空椅子可坐，他就坐下来等，如果没有空椅子，他就离开。为理发师和顾客各编一段程序（伪代码）描述他们的行为，要求不能带有竞争条件。</p><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> semaphore;<span class="hljs-keyword">int</span> waiting=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> chair=N;semaphore barber=<span class="hljs-number">0</span>,customer=<span class="hljs-number">0</span>,mutex=<span class="hljs-number">1</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Barber</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;        P(customer);<span class="hljs-comment">//无顾客，则睡眠</span>        P(mutex);        waiting--;        V(mutex);        V(barber);<span class="hljs-comment">//一个理发师开始理发</span>        cut_hair();    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Customer</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;        P(mutex);        <span class="hljs-keyword">if</span>(waiting&lt;chair)&#123;        waiting++;        V(mutex);        V(customer);<span class="hljs-comment">//唤醒理发师</span>        P(barber);<span class="hljs-comment">//没人理发，就睡</span>        get_hair_cut();<span class="hljs-comment">//理发</span>        &#125;<span class="hljs-keyword">else</span>&#123;            V(mutex);        &#125;    &#125;&#125;</code></pre><h2 id="二、吸烟者问题"><a href="#二、吸烟者问题" class="headerlink" title="二、吸烟者问题"></a>二、吸烟者问题</h2><p>三个吸烟者在一间房间内，还有一个香烟供应者。为了制造并抽掉香烟，每个吸烟者需要三样东西：烟草、纸和火柴。供应者有丰富的货物提供。三个吸烟者中，<br>第一个有自己的烟草，第二个有自己的纸，第三个有自己的火柴。供应者将两样东西放在桌子上，允许一个吸烟者进行对健康不利的吸烟。当吸烟者完成吸烟后唤醒供应者，供应者再放两样东西（随机地）在桌面上，然后唤醒另一个吸烟者。试为吸烟者和供应者编写程序解决问题。</p><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> semaphore;semaphore s=<span class="hljs-number">1</span>;semaphore s1=<span class="hljs-number">0</span>,s2=<span class="hljs-number">0</span>,s3=<span class="hljs-number">0</span>;<span class="hljs-keyword">bool</span> material[<span class="hljs-number">3</span>]=&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">supply</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;        P(s);        <span class="hljs-keyword">int</span> i=rand()%<span class="hljs-number">3</span>;        material[(i+<span class="hljs-number">1</span>)%<span class="hljs-number">3</span>]=<span class="hljs-number">1</span>;        material[(i+<span class="hljs-number">3</span><span class="hljs-number">-1</span>)%<span class="hljs-number">3</span>]=<span class="hljs-number">1</span>;        <span class="hljs-keyword">if</span>(material[<span class="hljs-number">0</span>]&amp;&amp;material[<span class="hljs-number">1</span>])        &#123;            V(s3);        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(material[<span class="hljs-number">0</span>]&amp;&amp;material[<span class="hljs-number">2</span>])&#123;            V(s2);        &#125;<span class="hljs-keyword">else</span>&#123;            V(s1);        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Smoker1</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;        P(s1);        smoke();        V(s);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Smoker2</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;        P(s2);        somke();        V(s);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Smoker3</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;        P(s3);        somke();        V(s);    &#125;&#125;</code></pre><h2 id="三、面包师问题"><a href="#三、面包师问题" class="headerlink" title="三、面包师问题"></a>三、面包师问题</h2><p>面包师有很多面包和蛋糕，由 n 个销售人员销售。每个顾客进店后先取一个号，并且等着叫号。当一个销售人员空闲下来，就叫下一个号。请分别编写销售人<br>员和顾客进程的程序。</p><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> semaphore;semaphore customer=<span class="hljs-number">0</span>;semaphore seller=n;semaphore c_mutex=<span class="hljs-number">1</span>;semaphore s_mutex=<span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> number_c=<span class="hljs-number">0</span>,number_s=<span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Customer</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    P(&amp;c_mutex);    number_c++;    V(&amp;c_mutex);    V(customer);    P(seller);    Buy <span class="hljs-keyword">and</span> go ;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Seller</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;        P(&amp;customer);        P(&amp;s_mutex);        call the number_s customer;        number_s++;        V(&amp;s_mutex);        V(&amp;seller);    &#125;    &#125;</code></pre><h2 id="四、水果！"><a href="#四、水果！" class="headerlink" title="四、水果！"></a>四、水果！</h2><p>桌上有一空盘，运行存放一只水果，爸爸可向盘中放苹果，也可放桔子，儿子专等吃盘中的桔子，女儿专等吃盘中的苹果。规定当盘中空时一次只能放一个水果供吃者取用，用 P,V 原语实现爸爸儿子和女儿 3 个并发进程的同步。</p><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> semaphore;semaphore empty=<span class="hljs-number">0</span>;semaphore mutex=<span class="hljs-number">1</span>;semaphore apple=<span class="hljs-number">0</span>;semaphore orange=<span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dad</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;        P(&amp;empty);        P(&amp;mutex);        put_fruit();        V(apple <span class="hljs-keyword">or</span> orange);        V(&amp;mutex);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">son</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;        P(&amp;orange);        P(&amp;mutex);        get orange!        V(&amp;mutex);        V(&amp;empty);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">daugther</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;        P(&amp;apple);        P(&amp;mutex);        get apple!        V(&amp;mutex);        V(&amp;empty);    &#125;&#125;</code></pre><h2 id="五、仓库问题"><a href="#五、仓库问题" class="headerlink" title="五、仓库问题"></a>五、仓库问题</h2><p> 有一个仓库，可以存放 A 和 B 两种产品，仓库的存储空间足够大，但要求：</p><p>（ 1）一次只能存入一种产品（ A 或 B）；<br>（ 2） -N &lt; (A 产品数量-B 产品数量) &lt; M。<br>其中， N 和 M 是正整数。试用“存放 A”和“存放 B”以及 P、 V 操作描述产品 A 与产品 B 的入库过程。</p><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> semaphore;semaphore mutex=<span class="hljs-number">1</span>;semaphore a=M<span class="hljs-number">-1</span>;semaphore b=N<span class="hljs-number">-1</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">putA</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    P(&amp;a);    P(&amp;mutex);    PUT IN THE STORAGE!    V(&amp;mutex);    V(&amp;b);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">putB</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    P(&amp;b);    P(&amp;mutex);    PUT IN THE STORAGE!    V(&amp;mutex);    V(&amp;a);&#125;</code></pre><h2 id="六、数字问题"><a href="#六、数字问题" class="headerlink" title="六、数字问题"></a>六、数字问题</h2><p>三个进程 P1、 P2、 P3 互斥使用一个包含 N(N&gt;0)个单元的缓冲区。 P1 每次用 produce()生成一个正整数并用 put()送入缓冲区某一空单元中;P2 每次用 getodd()从该缓冲区中取出一个奇数并用 countodd()统计奇数个数;P3 每次用 geteven()从该缓冲区中取出一个偶数并用 counteven()统计偶数个数。请用信号量机制实现这三个进程的同步与互斥活动,并说明所定义信号量的含义。要求用伪代码描述。</p><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> semaphore;semaphore mutex=<span class="hljs-number">1</span>;semaphore empty=N;semaphore even=<span class="hljs-number">0</span>;semaphore odd=<span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">P1</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;        <span class="hljs-keyword">int</span> data=produce();        P(&amp;empty);        P(mutex);        PUT DATA!        V(&amp;mutex);        <span class="hljs-keyword">if</span>(data%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)        V(&amp;even);        <span class="hljs-keyword">else</span>        V(&amp;odd);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">P2</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;        P(&amp;odd);        P(&amp;mutex);        getodd();        V(&amp;mutex);        V(&amp;empty);        countodd();    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">P3</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;        P(&amp;even);        P(&amp;mutex);        geteven();        V(&amp;mutex);        V(&amp;empty);        counteven();    &#125;    &#125;</code></pre><h2 id="七、窄桥问题"><a href="#七、窄桥问题" class="headerlink" title="七、窄桥问题"></a>七、窄桥问题</h2><p>有桥如下图所示，</p><p><img src="/2021/01/01/Operating%E2%80%94-System/bridge.png"></p><p>车流如箭头所示，桥上不允许两车交汇，但允许同方向多辆车依次通 过（即桥上可以有多个同方向的车）。用 P、V 操作实现交通管理以防止桥上堵塞。</p><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> semaphore;semaphore bridge=<span class="hljs-number">1</span>;semaphore NS_mutex=<span class="hljs-number">1</span>;semaphore SN_mutex=<span class="hljs-number">1</span>;<span class="hljs-keyword">int</span> NSC=<span class="hljs-number">0</span>,SNC=<span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">N2S</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;        P(&amp;NS_mutex);        NSC++;        <span class="hljs-keyword">if</span>(NSC==<span class="hljs-number">1</span>) P(&amp;bridge);        V(&amp;NS_mutex);        GETTHROUGH!        P(&amp;NS_mutex);        NSC--;        <span class="hljs-keyword">if</span>(NSC==<span class="hljs-number">0</span>) V(&amp;bridge);        V(&amp;NS_mutex);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">S2N</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;        P(&amp;SN_mutex);        SNC++;        <span class="hljs-keyword">if</span>(SNC==<span class="hljs-number">1</span>) P(&amp;bridge);        V(&amp;SN_mutex);        GETTHROUGH!        P(NS_mutex);        SNC--;        <span class="hljs-keyword">if</span>(SNC==<span class="hljs-number">0</span>) V(&amp;bridge);        V(&amp;NS_mutex)；    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Operating System</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020：迷雾中的一场奔赴</title>
    <link href="/2020/12/31/2020%E5%B9%B4%E7%BB%88%E5%9B%9E%E9%A1%BE/"/>
    <url>/2020/12/31/2020%E5%B9%B4%E7%BB%88%E5%9B%9E%E9%A1%BE/</url>
    
    <content type="html"><![CDATA[<p><strong>这个世界存在丑恶混乱，但我选择看见美好。</strong></p><a id="more"></a><p>&emsp;</p><p>2020是值得铭记的一年。</p><p>这一年很特殊：在家渡过了大一下学期；第一次想出门但不能出去；写了第一篇博客，找到了久违的写作的快乐；初步找到自己的方向与目标。</p><p>但这一切也还是平平凡凡，我只是万千少年中的一个，是一个平平无奇的学生，仍在为充实自己努力，依旧是一个”自闭”男孩。</p><p>对我而言，这一年有欣喜、期待，也有紧张、沮丧。(emmm, 我知道这句话是废话)</p><p>如果说相比去年，今年多了什么，那就是思考——一个初入大学的人的思考。</p><p><strong>如果说有什么是我庆幸且十分高兴的，那就是我守住了自己的理想。</strong></p><p>成年带来的蜕变似乎没有在当时显现，反是今年，让我想明白了很多东西。</p><p>我是一个INFJ，理想主义者。一旦我所做的事情在我看来没有意义，我就会没有继续干下去的动力。初入大学的社会，我发现有些事情并没有我想象地那么美好纯洁，也没有那么美好浪漫。仿佛外部的喧嚣与浮华也渗透进了象牙塔，似乎人的初心也有了改变。</p><p>我也被他所擒获、感染。而且至今无法置之度外。<strong>仿佛就像迷雾中的旅人一样，只能在其中摸索前行</strong>。但我很庆幸，自己能够意识到这点。</p><p>我十分了解，跟随自己的理想走可能不会取得当前人们所认为的成功。但我还是无法背叛自己的内心。《心灵奇旅》中的一句话我很有感触“Spark并不是灵魂的目的，只是当你准备生活时的填上的最后一个框。”<strong>这可能就是我这个该死的理想主义者内心的底线吧。</strong></p><p>但我还是很高兴，自己选择了CS；我也很高兴，自己能够对自己未来的路感兴趣。</p><p>最近听司南的《奔赴》很有感觉，仿佛说出了我目前内心的感觉，这也是为什么这篇文章叫《2020：迷雾中的一场奔赴》的原因吧。</p><p>2021就要来了，希望在新的一年里，我能够守住理想。毕竟最残酷的事莫过于没有将理想贯彻到底。</p><p>也祝看到这里的你能在新的一年中不再迷茫，向自己的理想奔赴。</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Life</tag>
      
      <tag>Thinking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Divide and Conquer</title>
    <link href="/2020/12/15/Divide-and-Conquer/"/>
    <url>/2020/12/15/Divide-and-Conquer/</url>
    
    <content type="html"><![CDATA[<p>Try to be a good coder and emmm… review algorithm class.XD</p><a id="more"></a><h1 id="残缺棋盘"><a href="#残缺棋盘" class="headerlink" title="残缺棋盘"></a>残缺棋盘</h1><pre><code class="hljs cpp"><span class="hljs-comment">/*A great number of recrusive...XD*/</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">char</span> mylist[<span class="hljs-number">100</span>][<span class="hljs-number">100</span>];<span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">makeup_board</span><span class="hljs-params">(<span class="hljs-keyword">int</span> tr,<span class="hljs-keyword">int</span> tc, <span class="hljs-keyword">int</span> dr, <span class="hljs-keyword">int</span> dc, <span class="hljs-keyword">int</span> size)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> t,s;    <span class="hljs-keyword">if</span>(size&lt;<span class="hljs-number">2</span>)    <span class="hljs-keyword">return</span> ;    ans+=<span class="hljs-number">1</span>;    t=ans;    s=size/<span class="hljs-number">2</span>;    <span class="hljs-keyword">if</span>(dr&lt;tr+s&amp;&amp;dc&lt;tc+s)&#123;        <span class="hljs-comment">//show that the defective part is in the up-left area</span>        makeup_board(tr,tc,dr,dc,s);        mylist[tr+s][tc+s]=t+<span class="hljs-string">&#x27;A&#x27;</span>;<span class="hljs-comment">//emmm, when chessboard big enough, it will beyond &#x27;Z&#x27;and there might have amazing thing</span>        mylist[tr+s<span class="hljs-number">-1</span>][tc+s]=t+<span class="hljs-string">&#x27;A&#x27;</span>;<span class="hljs-comment">//and there might have amazing thing.</span>        mylist[tr+s][tc+s<span class="hljs-number">-1</span>]=t+<span class="hljs-string">&#x27;A&#x27;</span>;<span class="hljs-comment">//so,if you want try a big chessboard, please use numbers.</span>        makeup_board(tr,tc+s,tr+s<span class="hljs-number">-1</span>,tc+s,s);        makeup_board(tr+s,tc,tr+s,tc+s<span class="hljs-number">-1</span>,s);        makeup_board(tr+s,tc+s,tr+s,tc+s,s);    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dr&lt;tr+s&amp;&amp;dc&gt;=tc+s)&#123;<span class="hljs-comment">//up-right</span>        makeup_board(tr,tc+s,dr,dc,s);        mylist[tr+s][tc+s]=t+<span class="hljs-string">&#x27;A&#x27;</span>;        mylist[tr+s][tc+s<span class="hljs-number">-1</span>]=t+<span class="hljs-string">&#x27;A&#x27;</span>;        mylist[tr+s<span class="hljs-number">-1</span>][tc+s<span class="hljs-number">-1</span>]=t+<span class="hljs-string">&#x27;A&#x27;</span>;        makeup_board(tr,tc,tr+s<span class="hljs-number">-1</span>,tc+s<span class="hljs-number">-1</span>,s);        makeup_board(tr+s,tc,tr+s,tc+s<span class="hljs-number">-1</span>,s);        makeup_board(tr+s,tc+s,tr+s,tc+s,s);    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dr&gt;=tr+s&amp;&amp;dc&lt;tc+s)&#123;<span class="hljs-comment">//down-left</span>        makeup_board(tr+s,tc,dr,dc,s);        mylist[tr+s][tc+s]=t+<span class="hljs-string">&#x27;A&#x27;</span>;        mylist[tr+s<span class="hljs-number">-1</span>][tc+s]=t+<span class="hljs-string">&#x27;A&#x27;</span>;        mylist[tr+s<span class="hljs-number">-1</span>][tc+s<span class="hljs-number">-1</span>]=t+<span class="hljs-string">&#x27;A&#x27;</span>;        makeup_board(tr,tc,tr+s<span class="hljs-number">-1</span>,tc+s<span class="hljs-number">-1</span>,s);        makeup_board(tr,tc+s,tr+s<span class="hljs-number">-1</span>,tc+s,s);        makeup_board(tr+s,tc+s,tr+s,tc+s,s);    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(dr&gt;=tr+s&amp;&amp;dc&gt;=tc+s)&#123;        makeup_board(tr+s,tc+s,dr,dc,s);        mylist[tr+s<span class="hljs-number">-1</span>][tc+s<span class="hljs-number">-1</span>]=t+<span class="hljs-string">&#x27;A&#x27;</span>;        mylist[tr+s][tc+s<span class="hljs-number">-1</span>]=t+<span class="hljs-string">&#x27;A&#x27;</span>;        mylist[tr+s<span class="hljs-number">-1</span>][tc+s]=t+<span class="hljs-string">&#x27;A&#x27;</span>;        makeup_board(tr,tc,tr+s<span class="hljs-number">-1</span>,tc+s<span class="hljs-number">-1</span>,s);        makeup_board(tr+s,tc,tr+s,tc+s<span class="hljs-number">-1</span>,s);        makeup_board(tr,tc+s,tr+s<span class="hljs-number">-1</span>,tc+s,s);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Please input the value of k (used to calculate 2^k)&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">int</span> k,size=<span class="hljs-number">1</span>,x,y;    <span class="hljs-built_in">cin</span>&gt;&gt;k;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;k;i++)    size*=<span class="hljs-number">2</span>;    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Please input the defective location (x,y) from 1~2^k&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cin</span>&gt;&gt;x&gt;&gt;y;    <span class="hljs-built_in">memset</span>(mylist,<span class="hljs-string">&#x27;#&#x27;</span>,<span class="hljs-keyword">sizeof</span>(mylist));    makeup_board(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,x<span class="hljs-number">-1</span>,y<span class="hljs-number">-1</span>,size);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;size;j++)        <span class="hljs-built_in">cout</span>&lt;&lt;mylist[i][j]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><hr><h1 id="Merge-Sort"><a href="#Merge-Sort" class="headerlink" title="Merge Sort"></a>Merge Sort</h1><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">meger</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *mylist,<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> right)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> i=left, j=mid+<span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> counter=<span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> * ans =<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [right-left+<span class="hljs-number">1</span>];    <span class="hljs-keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=right)    &#123;        <span class="hljs-keyword">if</span>(mylist[i]&lt;=mylist[j])&#123;            ans[counter++]=mylist[i++];        &#125;        <span class="hljs-keyword">else</span>         ans[counter++]=mylist[j++];    &#125;    <span class="hljs-keyword">while</span>(i&lt;=mid)    &#123;        ans[counter++]=mylist[i++];    &#125;    <span class="hljs-keyword">while</span>(j&lt;=right)    ans[counter++]=mylist[j++];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=left,k=<span class="hljs-number">0</span>;i&lt;=right;i++,k++)    mylist[i]=ans[k];&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">meger_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *mylist,<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(left&lt;right)    &#123;        <span class="hljs-keyword">int</span> mid=(left+right)/<span class="hljs-number">2</span>;        meger_sort(mylist, left,mid);        meger_sort(mylist,mid+<span class="hljs-number">1</span>,right);        meger(mylist,left,mid,right);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> lenght, *mylist, *ans;    <span class="hljs-built_in">cin</span>&gt;&gt;lenght;    mylist= <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[lenght];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;lenght;i++)    <span class="hljs-built_in">cin</span>&gt;&gt;mylist[i];    meger_sort(mylist,<span class="hljs-number">0</span>,lenght<span class="hljs-number">-1</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;lenght;i++)    <span class="hljs-built_in">cout</span>&lt;&lt;mylist[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><hr><h1 id="金块问题"><a href="#金块问题" class="headerlink" title="金块问题"></a>金块问题</h1><pre><code class="hljs cpp">Max-Min(A[<span class="hljs-number">1</span>,n], max, min)<span class="hljs-keyword">if</span> n==<span class="hljs-number">1</span>  max&lt;- min&lt;- a[<span class="hljs-number">1</span>]; <span class="hljs-keyword">return</span> ;<span class="hljs-keyword">if</span> n==<span class="hljs-number">2</span> 比较a[<span class="hljs-number">1</span>] a[<span class="hljs-number">2</span>]大小<span class="hljs-keyword">else</span>m&lt;- n/<span class="hljs-number">2</span>Max-Min (A[<span class="hljs-number">1</span>,m], max1 , min1 )Max - Min(A[m+<span class="hljs-number">1</span>, n] ,max2 , min2 )max &lt;- max(max1, max2)min&lt; - min (min1 , min2)<span class="hljs-keyword">return</span> ;</code></pre><pre><code class="hljs cpp"><span class="hljs-comment">/*Easy code without recursive*/</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Minmax</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *mylist,<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> &amp;maxx, <span class="hljs-keyword">int</span> &amp;minn)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(n&lt;<span class="hljs-number">1</span>)    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)    &#123;        maxx=minn=<span class="hljs-number">0</span>;        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    &#125;    <span class="hljs-keyword">int</span> start;    <span class="hljs-keyword">if</span>(n%<span class="hljs-number">2</span>)&#123;        maxx=minn=<span class="hljs-number">0</span>;        start=<span class="hljs-number">1</span>;    &#125;<span class="hljs-keyword">else</span>&#123;        mylist[<span class="hljs-number">0</span>]&gt;mylist[<span class="hljs-number">1</span>]?maxx=<span class="hljs-number">0</span>,minn=<span class="hljs-number">1</span> : minn=<span class="hljs-number">0</span>,maxx=<span class="hljs-number">1</span>;        start=<span class="hljs-number">2</span>;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=start;i&lt;n;i+=<span class="hljs-number">2</span>)&#123;        <span class="hljs-keyword">if</span>(mylist[i]&gt;mylist[i+<span class="hljs-number">1</span>])&#123;            <span class="hljs-keyword">if</span>(mylist[i]&gt;mylist[maxx])                maxx=i;            <span class="hljs-keyword">if</span>(mylist[i+<span class="hljs-number">1</span>]&lt;mylist[minn])                minn=i+<span class="hljs-number">1</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">if</span>(mylist[i+<span class="hljs-number">1</span>]&gt;mylist[maxx])            maxx=i+<span class="hljs-number">1</span>;            <span class="hljs-keyword">if</span>(mylist[i]&lt;mylist[minn])            minn=i;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> len;    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Input the length of array&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cin</span>&gt;&gt;len;    <span class="hljs-keyword">int</span> *mylist=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [len];    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Input the elements of array&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)    <span class="hljs-built_in">cin</span>&gt;&gt;mylist[i];    <span class="hljs-keyword">int</span> maxx=<span class="hljs-number">0</span>,minn=<span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(Minmax(mylist,len,maxx,minn))&#123;        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;the biggest is &quot;</span>;        <span class="hljs-built_in">cout</span>&lt;&lt;mylist[maxx]&lt;&lt;<span class="hljs-string">&quot; the min is &quot;</span>&lt;&lt;mylist[minn]&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>n==2^k^时复杂度分析</p><p>&emsp;&emsp;&emsp;&emsp; 0,  n==1</p><p>C(n)=&emsp; &nbsp; 1, n==2</p><p>&emsp;&emsp;&emsp;&emsp; 2xC(n/2) + 2 ,  其他</p><p>C(n)=（3n/2）-2</p><p>主项法：a=2，b=2，log<del>b</del>a=1，n^1^=n，f(n)==2==θ(1)</p><p>C(n)=θ(n)</p><hr><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partation</span><span class="hljs-params">(<span class="hljs-keyword">int</span> * mylist, <span class="hljs-keyword">int</span> left ,<span class="hljs-keyword">int</span> right)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> povit=mylist[left];    <span class="hljs-keyword">while</span>(left&lt;right)&#123;        <span class="hljs-keyword">while</span> (left&lt;right&amp;&amp;mylist[right]&gt;=povit)            right--;        mylist[left]=mylist[right];        <span class="hljs-keyword">while</span> (left&lt;right&amp;&amp;mylist[left]&lt;=povit)            left++;        mylist[right]=mylist[left];    &#125;    mylist[left]=povit;    <span class="hljs-keyword">return</span> left;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* mylist,<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(left&gt;right)    <span class="hljs-keyword">return</span> ;    <span class="hljs-keyword">int</span> j=partation(mylist,left,right);    quicksort(mylist,left,j<span class="hljs-number">-1</span>);    quicksort(mylist,j+<span class="hljs-number">1</span>,right);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> mylist[<span class="hljs-number">6</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>&#125;;    quicksort(mylist,<span class="hljs-number">0</span>,<span class="hljs-number">5</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">6</span>;i++)    <span class="hljs-built_in">cout</span>&lt;&lt;mylist[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>时间复杂度分析</strong></p><p>最坏情况下</p><p>T<del>max</del>(n)=O(1)，n&lt;=1</p><p>&emsp;&emsp;&emsp;=T(n-1)+O(n)=O(n^2^)，n&gt;1。即产生的区域分别包括n-1和n个元素</p><p>最好情况下</p><p>T<del>min</del>(n)=O(1)，n&lt;=1</p><p>&emsp;&emsp;&emsp;=2T(n/2)+O(n)=O(nlogn)，n&gt;1。即产生的区域每次都为n/2</p><p><strong>平均时间复杂度为θ(nlogn)</strong></p><p>证明：</p><p>每轮快排将数组分成两部分，用S代表左数据段元素个数，右数据段元素个数为n-s-1，S取0~n-1中任何数的概率为 1/n</p><p>T(n)=1/n Σ<del>s=0</del>^n-1^ (T(s)+T(n-s-1))  + cn=2/n Σ<del>s=0</del>^n-1^ T(S)  + cn</p><p>由nT(n)-(n-1)T(n-1)=2T(n-1)+O(n)得</p><p>T(n)=（1+1/n)T(n-1)+ O(n)</p><p>归纳得T(n)=θ(nlogn)</p><hr><h1 id="选择问题"><a href="#选择问题" class="headerlink" title="选择问题"></a>选择问题</h1><p>对给定序列，选出其中第k小的元素</p><p><strong>该问题可在O(nlogn)时间内解决，方法为先排序，再取出a[k-1]元素</strong></p><p><strong>若用快速排序，可取得较好的平均复杂度，但最坏复杂度为O(n^2^)</strong></p><p><em>朴素算法（使用快排）</em></p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partation</span><span class="hljs-params">(<span class="hljs-keyword">int</span> * mylist, <span class="hljs-keyword">int</span> left ,<span class="hljs-keyword">int</span> right)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> povit=mylist[left];    <span class="hljs-keyword">while</span>(left&lt;right)&#123;        <span class="hljs-keyword">while</span> (left&lt;right&amp;&amp;mylist[right]&gt;=povit)            right--;        mylist[left]=mylist[right];        <span class="hljs-keyword">while</span> (left&lt;right&amp;&amp;mylist[left]&lt;=povit)            left++;        mylist[right]=mylist[left];    &#125;    mylist[left]=povit;    <span class="hljs-keyword">return</span> left;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">quicksort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>* mylist,<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right,<span class="hljs-keyword">int</span> k)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(left==right)    <span class="hljs-keyword">return</span> mylist[left];    <span class="hljs-keyword">int</span> j=partation(mylist,left,right);    <span class="hljs-keyword">if</span>(k==j-left+<span class="hljs-number">1</span>)    <span class="hljs-keyword">return</span> mylist[j];    <span class="hljs-keyword">if</span>(k-j+left&lt;<span class="hljs-number">1</span>)    <span class="hljs-keyword">return</span> quicksort(mylist,left,j<span class="hljs-number">-1</span>,k);    <span class="hljs-keyword">else</span>     <span class="hljs-keyword">return</span> quicksort(mylist,j+<span class="hljs-number">1</span>,right,k-j+left<span class="hljs-number">-1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> len;    <span class="hljs-built_in">cin</span>&gt;&gt;len;    <span class="hljs-keyword">int</span> *mylist=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [len];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)    <span class="hljs-built_in">cin</span>&gt;&gt;mylist[i];    <span class="hljs-built_in">cout</span>&lt;&lt;quicksort(mylist,<span class="hljs-number">0</span>,len<span class="hljs-number">-1</span>,<span class="hljs-number">3</span>)&lt;&lt;<span class="hljs-built_in">endl</span>;       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p><strong>复杂度分析：</strong></p><p>若left和right总是同样大小，或者相差不超过一个元素，那么递归式如下</p><p>T(n)=T(n/2)+cn， n&gt;1  </p><p>​         d， n&lt;=1</p><p>若n==2^k^，可通过迭代方法得到T(n)=θ(n)</p><p><strong>即选择较好的分点，可以得到较好的性能。</strong></p><h2 id="中间的中间"><a href="#中间的中间" class="headerlink" title="中间的中间"></a>中间的中间</h2><p><strong>若仔细地选择支点元素，则最坏情况下的时间开销也可以变成θ(n)</strong></p><p><strong>规则：</strong></p><p><strong>首先将数组a中的n 个元素分成n/r 组，r 为某一整常数。</strong></p><p><strong>除了最后一组外，每组都有r 个元素。然后通过在每组中对r 个元素进行排序来寻找每组中位于中间位置的元素。</strong></p><p><strong>最后对所得到的n/r 个中间元素，递归使用选择算法，求得”中间之中间”作为支点元素</strong></p><blockquote><p><strong>当使用中间的中间规则选取支点时，下定理成立</strong></p><p><strong>若r=5，且a 中所有元素都不同，那么当n≥24时，有max{| left |, | right | }≤3n/ 4</strong></p><p>*<em>有   ⌈1/2 * ⌊n/5⌋ ⌉  多个中间元素不大于mm。*</em></p><p><strong>大于mm元素的数目有上界</strong></p><p><img src="/2020/12/15/Divide-and-Conquer/%E5%AE%9A%E7%90%86.png"></p><p><strong>故，当n&gt;=24时，0.7n+1.2≤3n/4</strong></p></blockquote><p>r==5时</p><p><strong>T(n) ≤ T(n/5) + T(3n/4) +Θ(n)</strong></p><p>归纳法可证明当n≥24时有t(n)≤20cn</p><p><strong>r=9, 当n≥90时，有max{ |left|,|right|}≤7n/8</strong></p><p><strong>问：用第K小做支点的快速排序时间复杂度•在快速排序算法中，如果我们先调用最坏情形时间复杂度O(n)的选择算法找出第n/2小元素并以此为支点(pivot)对要排序的数组进行分划，则改进后的快速排序算法的最坏情形时间复杂度T(n)是什么？假定n=2k，列出T(n)满足的递归方程并分析.</strong></p><p><strong>解答：用第n/2小的元素做支点，把数组分成均等的两半，同时，分化的最坏情形时间代价为O(n)=cn，则改进快速排序算法的最坏时间复杂度为T(n)=2T(n/2)+cn。符合主定理case2，T(n)=Θ(nlogn)。假定n=2k，T(n)=2T(n/2)+cn=2kT(1)+k⋅cn=Θ(n+nlogn)=Θ(nlogn)。</strong></p><h1 id="求逆序个数"><a href="#求逆序个数" class="headerlink" title="求逆序个数"></a>求逆序个数</h1><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergecount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *mylist,<span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> mid,<span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> *temp)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> p1=l, p2=mid+<span class="hljs-number">1</span>, index=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span>(p1&lt;=mid&amp;&amp;p2&lt;=r)&#123;        <span class="hljs-keyword">if</span>(mylist[p1]&lt;mylist[p2])&#123;            temp[index++]=mylist[p1++];        &#125;<span class="hljs-keyword">else</span>&#123;            temp[index++]=mylist[p2++];            sum+=mid-p1+<span class="hljs-number">1</span>;        &#125;    &#125;    <span class="hljs-keyword">while</span>(p1&lt;=mid)&#123;        temp[index++]=mylist[p1++];    &#125;    <span class="hljs-keyword">while</span>(p2&lt;=r)&#123;        temp[index++]=mylist[p2++];    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;r-l+<span class="hljs-number">1</span>;i++)    mylist[l+i]=temp[i];&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergesort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *mylist, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> *temp)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(l&lt;r)&#123;        <span class="hljs-keyword">int</span> mid=(l+r)/<span class="hljs-number">2</span>;        mergesort(mylist,l,mid,temp);        mergesort(mylist,mid+<span class="hljs-number">1</span>,r,temp);        mergecount(mylist,l,mid,r,temp);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> n;    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Input the number of data&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cin</span>&gt;&gt;n;    <span class="hljs-keyword">int</span> *temp=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [n];    <span class="hljs-keyword">int</span> *mylist=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Input datas&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)    <span class="hljs-built_in">cin</span>&gt;&gt;mylist[i];    mergesort(mylist,<span class="hljs-number">0</span>,n<span class="hljs-number">-1</span>,temp);    <span class="hljs-built_in">cout</span>&lt;&lt;sum&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>南京大屠杀死难者国家公祭日</title>
    <link href="/2020/12/13/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%B1%A0%E6%9D%80%E6%AD%BB%E9%9A%BE%E8%80%85%E5%9B%BD%E5%AE%B6%E5%85%AC%E7%A5%AD%E6%97%A5/"/>
    <url>/2020/12/13/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%B1%A0%E6%9D%80%E6%AD%BB%E9%9A%BE%E8%80%85%E5%9B%BD%E5%AE%B6%E5%85%AC%E7%A5%AD%E6%97%A5/</url>
    
    <content type="html"><![CDATA[<p><strong>让真相就是真相，是不随时间而转移的真相</strong></p><a id="more"></a><p>晚辈定不负前辈之托，为中华之崛起而读书。</p>]]></content>
    
    
    <categories>
      
      <category>缅怀</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Thinking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《孔乙己》</title>
    <link href="/2020/12/11/%E3%80%8A%E5%AD%94%E4%B9%99%E5%B7%B1%E3%80%8B/"/>
    <url>/2020/12/11/%E3%80%8A%E5%AD%94%E4%B9%99%E5%B7%B1%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<p><strong>今日重读《孔乙己》，又有些新的感触。</strong></p><a id="more"></a>]]></content>
    
    
    <categories>
      
      <category>Reading</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Thinking</tag>
      
      <tag>Reading</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Greedy Algorithm</title>
    <link href="/2020/12/05/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    <url>/2020/12/05/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>Try to be a good coder and emmm… review !</p><a id="more"></a><h1 id="优化问题"><a href="#优化问题" class="headerlink" title="优化问题"></a>优化问题</h1><h2 id="优化问题的概念"><a href="#优化问题的概念" class="headerlink" title="优化问题的概念"></a>优化问题的概念</h2><p>即通过一定条件约束，对一组变量进行操作，使目标到达最优值。</p><h2 id="优化问题的一般描述"><a href="#优化问题的一般描述" class="headerlink" title="优化问题的一般描述"></a>优化问题的一般描述</h2><p><strong>优化问题的描述：</strong></p><p><strong>1.问题的解为一复杂结构 (x1,x2,…,xn) xi∈Si（可选的方式）</strong></p><p><strong>2.约束条件：B(x1,x2…,xn)，使B为true的元组称为可行解</strong></p><p><strong>3.目标函数f(x1,…,xn)</strong> </p><p><strong>优化解即指使目标函数取得最值的可行解，对应的目标函数值称为优化值</strong></p><p><strong>贪心算法是求近似解的一种主要途径。</strong></p><hr><h1 id="贪心算法的思想及要点"><a href="#贪心算法的思想及要点" class="headerlink" title="贪心算法的思想及要点"></a>贪心算法的思想及要点</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>&emsp;&emsp;贪心算法是一种多步求解优化问题的方法，每步按一种局部最优的策略选择解的一个分量，算法以第n步结束时构造出问题的解。</p><p>&emsp;&emsp;该算法问题在于：其<strong>贪婪的短视</strong>导致在很多情况下都会错过最优解，因为贪心算法不会从整体上对问题进行思考，只会埋头于当前情况。所以贪心算法不能用来求最大最小值、无法保证最后的解是最优的、只能求某些特定的解。</p><p>&emsp;&emsp;所以实际上可以用贪心算法求得最优解的情况很少，所以我们要证明每一步所作的贪心选择最终能导出问题最优解。</p><p><strong>Don’t worry. The codes here are simple and easy.</strong></p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>不回溯</li><li>局部优化策略可以减小开销，但不保证得到精确优化解</li><li>不同贪心策略得到不同算法</li><li>常使用使目标函数有最大增量的策略为贪心策略</li></ol><hr><h1 id="货箱装船问题"><a href="#货箱装船问题" class="headerlink" title="货箱装船问题"></a>货箱装船问题</h1><p>下面我们来看一个很简单的例题</p><blockquote><p><strong>例 Loading Problem</strong></p><p><strong>设有n个集装箱,集装箱大小一样，第i个设有n个集装箱,集装箱大小一样，第i个集装箱的重量为wi(1≤i≤n),设船的载重量为c.试设计一装船的方法使得装入的集装箱数目最多</strong></p></blockquote><p>&emsp;</p><p>这是一道很基础的贪心算法题目，我们先按照<strong>优化问题的格式</strong>来描述一下他：</p><p><strong>令问题的解为(x1,x2,…,xn) &nbsp;xi={0,1}//代表第i个箱子是否装载。</strong></p><p><strong>问题的约束条件是Σi=1,n wixi&lt;=c; //装载箱子的总重量小于等于C</strong> </p><p><strong>目标函数为 Σi=1,n xi； //装载的集装箱个数</strong></p><p><strong>我们的目标是极大化目标函数。</strong></p><p>因为目标函数是所装的集装箱数目，所以按照我们的常规思想，那么一定先装重量轻的集装箱。</p><p>所以可以写出代码如下</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> n,c;<span class="hljs-keyword">int</span> weight[<span class="hljs-number">100</span>]=&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">int</span> countt=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> tem_weight=<span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cin</span>&gt;&gt;n;    <span class="hljs-built_in">cin</span>&gt;&gt;c;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)    <span class="hljs-built_in">cin</span>&gt;&gt;weight[i];    sort(weight,weight+n);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)    &#123;        <span class="hljs-keyword">if</span>(tem_weight+weight[i]&lt;=c)        &#123;            tem_weight+=weight[i];            countt++;        &#125;        <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">break</span>;&#125;    &#125;    <span class="hljs-built_in">cout</span>&lt;&lt;countt&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>这时你可能对这种贪心策略存疑，先装载重量低的箱子一定能得到最优解吗？</p><p>下面给出证明</p><p><u>证明:</u></p><p><u>设问题最优解为(y1,y2,…,yn)</u></p><p><u> </u></p><p><u>如最优解不含箱子1，将箱子1替换优化解中某一个箱子得到一个新的解</u></p><p><u>1.替换是必须的：若1还能装入船中，则(y1,y2,…,yn)不是优化的</u></p><p><u>2.因为1是最轻的，所以替换后的解仍是可行的</u></p><p><u>3.替换后的解装入的箱子数==优化的箱子数，它仍是优化解</u></p><p><u>4.替换后新的优化解和贪心解都有箱子1</u></p><p><u> </u></p><p><u>反复替换得到一个优化解，优化解==贪心解</u></p><p><u>替换次数是有穷的。</u></p><p>这就确定了在这道题目里，我们的贪心解一定是优化解。</p><p><strong>针对这个问题也引出一点：贪心解虽然在一种策略下只有一个，但问题的真正最优解可能有多个。</strong>   </p><hr><h1 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0/1背包问题"></a>0/1背包问题</h1><blockquote><p><strong>01背包问题</strong></p><p><strong>设有容量c的背包和n件物品，物品i的重量为w<del>i</del> ;假定装入物品i获得的效益值为p<del>i</del>,试给出一装入物品的方法使获得的总效益值最大.</strong></p></blockquote><p><strong>首先说明，贪心法无法得出该问题的优化解，只能得到近似解</strong></p><p>我们首先要决定贪心策略：</p><ol><li>选目前效益最大的物品</li><li>选重量最小的物品</li><li>选单位重量效益最大的物品</li></ol><p>贪心策略的决定后就可以进行编码。</p><pre><code class="hljs cpp"><span class="hljs-comment">//唯一要做的就是对贪心策略有关的数组进行排序</span><span class="hljs-comment">//例如，使用贪心策略1，那就对效益值降序排序即可...</span>sort(target_array, target_array+length,cmp);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;length;i++)&#123;    <span class="hljs-keyword">if</span>(背包容量&lt;该物品重量)    &#123;        put;        容量-物品重量;        效益值+物品效益值;    &#125;&#125;<span class="hljs-keyword">return</span> X;</code></pre><p><strong>由于贪心解和精确解之间存在误差，所以我们要有能够计算和减小误差的方法。</strong></p><p><strong>计算：</strong></p><p>贪心解与优化解之间误差= (优化值 - 贪心值) / 优化值 x 100%</p><p>for example:</p><p>n=2,c=y, w=[1,y], p=[10, 9y]</p><p>使用 上述贪心策略3(价值密度)</p><p>当y&gt;1时，所有的贪心解为(1,0)，贪心值为10</p><p>而当y&gt;10/9时，优化值为9y</p><p>所以当 1=&lt;y&lt;10/9时，误差==0</p><p>y&gt;=10/9时，误差=(9y-10)/9y x 100%</p><p>&emsp;</p><p>减小误差方法：<strong>K-优化算法</strong></p><p>概念：*<em>对贪心算法进行改进，让误差在1/(k+1)<em>100%之内</em></em></p><p>具体方式：</p><p><strong>1.先将一些物品装入背包，然后对剩余物品使用贪心策略。</strong></p><p><strong>2.预先装入的物品不能超过K个</strong></p><p><strong>3.对所有物品数不超过K的物品子集进行上述过程，从中找到有最大效益值的解为K-优化算法的解。</strong></p><p><em>也就是说，如果用 2-优化算法，那么 预先装入0个、1个、2个的情况都要尝试。</em></p><p><strong>K优化算法需要测试的子集数目为O(n^k^)</strong></p><p><strong>每个子集做贪心需要时间为O(n)</strong></p><p><strong>K&gt;0时，总时间开销为O(n^k+1^)</strong></p><h1 id="Huffman-code"><a href="#Huffman-code" class="headerlink" title="Huffman code"></a>Huffman code</h1><pre><code class="hljs cpp"><span class="hljs-comment">/*Realize by using min_heap*/</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-comment">/*Huffman tree&#x27;s node*/</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Treenode</span>&#123;</span>    <span class="hljs-keyword">char</span> code;    Treenode *left;    Treenode *right;    Treenode(<span class="hljs-keyword">char</span> x): code(x),left(<span class="hljs-literal">NULL</span>),right(<span class="hljs-literal">NULL</span>)&#123;&#125;&#125;;<span class="hljs-comment">/*heap node*/</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">heapnode</span>&#123;</span>    <span class="hljs-keyword">char</span> c; <span class="hljs-comment">//input&#x27;s character</span>    <span class="hljs-keyword">int</span> frequence;    Treenode *node; <span class="hljs-comment">//choose two min heapnode then let them be a tree</span>    heapnode(<span class="hljs-keyword">char</span> _c,<span class="hljs-keyword">int</span> _n):c(_c),frequence(_n)&#123;&#125;&#125;;<span class="hljs-comment">/*ini the min_heap*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert2heap</span><span class="hljs-params">(<span class="hljs-built_in">vector</span> &lt;heapnode&gt; &amp; heap, heapnode hc)</span></span><span class="hljs-function"></span>&#123;    heap.push_back(hc);    <span class="hljs-keyword">int</span> len=heap.size();    <span class="hljs-keyword">int</span> childindex=len<span class="hljs-number">-1</span>;    <span class="hljs-keyword">int</span> parentindex=(childindex<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;<span class="hljs-comment">// complete binary tree ~~~</span>    <span class="hljs-keyword">while</span>(parentindex&gt;=<span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">if</span>(heap[parentindex].frequence&gt;heap[childindex].frequence)&#123;            heapnode temp=heap[parentindex];            heap[parentindex]=heap[childindex];            heap[childindex]=temp;                        childindex=parentindex;            parentindex=(childindex<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;<span class="hljs-comment">// if parent &gt; child, change them;</span>        &#125;        <span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">break</span>;        &#125;            &#125;&#125;<span class="hljs-comment">/*get elem from minheap*/</span><span class="hljs-function">heapnode <span class="hljs-title">remove4heap</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;heapnode&gt; &amp; heap)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(heap.empty())&#123;        <span class="hljs-keyword">return</span> heapnode(<span class="hljs-string">&#x27;0&#x27;</span>,<span class="hljs-number">-1</span>);    &#125;    heapnode ans=heap[<span class="hljs-number">0</span>];    heap[<span class="hljs-number">0</span>]=heap.back();    heap.pop_back();<span class="hljs-comment">//let the big one on the top,then sort this heap like ini process.</span>    <span class="hljs-keyword">int</span> len=heap.size();    <span class="hljs-keyword">int</span> parentindex=<span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> childindex=<span class="hljs-number">1</span>;    <span class="hljs-keyword">while</span>(childindex&lt;=len<span class="hljs-number">-1</span>)    &#123;        <span class="hljs-keyword">if</span>((childindex!=len<span class="hljs-number">-1</span>)&amp;&amp;(heap[childindex].frequence&gt;heap[childindex+<span class="hljs-number">1</span>].frequence))&#123;            childindex++;        &#125;        <span class="hljs-keyword">if</span>(heap[childindex].frequence&lt;heap[parentindex].frequence)&#123;            heapnode temp=heap[parentindex];            heap[parentindex]=heap[childindex];            heap[childindex]=temp;            parentindex=childindex;            childindex=<span class="hljs-number">2</span>*childindex+<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> ans;&#125;<span class="hljs-comment">/*ini the huffman tree! yohooooo!*/</span><span class="hljs-function">Treenode* <span class="hljs-title">huffman_encode</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;heapnode&gt; &amp;heap)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">while</span>(!heap.empty())&#123;        <span class="hljs-keyword">if</span>(heap.size()==<span class="hljs-number">1</span>)        <span class="hljs-keyword">return</span> heap[<span class="hljs-number">0</span>].node;        <span class="hljs-keyword">else</span>&#123;        heapnode x=remove4heap(heap);        heapnode y= remove4heap(heap);        Treenode* left;        <span class="hljs-keyword">if</span>(x.c!=<span class="hljs-number">0</span>)<span class="hljs-comment">// we let the newly built bintree(from two min node).c=0;and what we input !=0;</span>        &#123;            left=<span class="hljs-keyword">new</span> Treenode(x.c);        &#125;        <span class="hljs-keyword">else</span>        &#123;            left=x.node;<span class="hljs-comment">//if has a bintree ,just use it.</span>        &#125;        Treenode* right;        <span class="hljs-keyword">if</span>(y.c!=<span class="hljs-number">0</span>)        &#123;            right=<span class="hljs-keyword">new</span> Treenode(y.c);        &#125;        <span class="hljs-keyword">else</span>        &#123;            right=y.node;        &#125;                Treenode* z=<span class="hljs-keyword">new</span> Treenode(<span class="hljs-number">0</span>);        z-&gt;left=left;        z-&gt;right=right;        <span class="hljs-function">heapnode <span class="hljs-title">hc</span><span class="hljs-params">(<span class="hljs-number">0</span>,x.frequence+y.frequence)</span></span>;<span class="hljs-comment">// build a new bintree...</span>        hc.node=z;        insert2heap(heap,hc);    &#125;    &#125;    <span class="hljs-keyword">return</span> heap[<span class="hljs-number">0</span>].node;&#125;<span class="hljs-comment">/*for check*/</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">outputheap</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;heapnode&gt; &amp;heap)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;heap.size();i++)&#123;        <span class="hljs-built_in">cout</span>&lt;&lt;heap[i].c&lt;&lt;<span class="hljs-string">&quot; : &quot;</span>&lt;&lt;heap[i].frequence&lt;&lt;<span class="hljs-built_in">endl</span>;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">outputHuffmantree</span><span class="hljs-params">(Treenode* root,<span class="hljs-built_in">string</span> prefix)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">if</span>(root-&gt;left==<span class="hljs-literal">NULL</span>&amp;&amp;root-&gt;right==<span class="hljs-literal">NULL</span>)&#123;        <span class="hljs-built_in">cout</span>&lt;&lt;root-&gt;code&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;prefix.c_str()&lt;&lt;<span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-keyword">else</span>    &#123;        outputHuffmantree(root-&gt;left,prefix+<span class="hljs-string">&quot;0&quot;</span>);        outputHuffmantree(root-&gt;right,prefix+<span class="hljs-string">&quot;1&quot;</span>);    &#125;&#125;<span class="hljs-comment">//use these two to output huffmancode</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">outputHuffmantree</span><span class="hljs-params">(Treenode* root)</span></span><span class="hljs-function"></span>&#123;   <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">NULL</span>)&#123;outputHuffmantree(root-&gt;left, <span class="hljs-string">&quot;0&quot;</span>);outputHuffmantree(root-&gt;right, <span class="hljs-string">&quot;1&quot;</span>);&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">vector</span>&lt;heapnode&gt; heap;    <span class="hljs-built_in">vector</span>&lt; <span class="hljs-built_in">pair</span>&lt;<span class="hljs-keyword">char</span>,<span class="hljs-keyword">int</span>&gt; &gt; ci=&#123;        &#123;<span class="hljs-string">&#x27;A&#x27;</span>,<span class="hljs-number">3</span>&#125;,        &#123;<span class="hljs-string">&#x27;B&#x27;</span>,<span class="hljs-number">1</span>&#125;,        &#123;<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-number">2</span>&#125;,        &#123;<span class="hljs-string">&#x27;D&#x27;</span>,<span class="hljs-number">5</span>&#125;,        &#123;<span class="hljs-string">&#x27;E&#x27;</span>,<span class="hljs-number">10</span>&#125;,    &#125;;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x :ci)&#123;        <span class="hljs-function">heapnode <span class="hljs-title">hc</span><span class="hljs-params">(x.first,x.second)</span></span>;        insert2heap(heap,hc);    &#125;    outputheap(heap);    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;------HUFFMAN CODE--------&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;    Treenode* root=huffman_encode(heap);    outputHuffmantree(root);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><p><strong>定义：</strong></p><p>任务的先后顺序可用有向图表示，称为AOV网络。<strong>有向图的顶点代表任务，有向边(i,j)表示先后关系：任务i完成后才能开始任务j。</strong></p><p>拓扑排序要求对任务进行排序，使得排序序列先后关系和AOV网定义的先后关系一致。</p><p><strong>根据任务的有向图建立拓扑序列的过程称为拓扑排序。</strong></p><hr><p>朴素思想就是对这n个任务进行全排列，<strong>时间复杂度为O(n!)</strong></p><p>&emsp;</p><p><strong>而贪心法从空集开始，每步产生拓扑序列中的一个顶点W。</strong></p><p><strong>Greedy Startget</strong>：从当前不在拓扑序列的顶点中选取一顶点w，其所有先行节点v都在已产生的拓扑序列中，并将其加入到拓扑序列。</p><p><em>使用检测入度的方法确定w：入度为0的顶点要加入到拓扑序列中。</em></p><pre><code class="hljs cpp"><span class="hljs-comment">/*easy code using martix to storage graphy*/</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tuopu</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt;&amp; martix,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; &amp;indegree,<span class="hljs-keyword">int</span> num_node)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">queue</span>&lt;<span class="hljs-keyword">int</span>&gt; ans;    <span class="hljs-keyword">int</span> counter=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;num_node;i++)<span class="hljs-comment">/*ini the queue*/</span>    &#123;        <span class="hljs-keyword">if</span>(indegree[i]==<span class="hljs-number">0</span>)        &#123;             ans.push(i);            indegree[i]=<span class="hljs-number">-1</span>;        &#125;    &#125;    <span class="hljs-keyword">while</span>(!ans.empty())&#123;        <span class="hljs-keyword">int</span> temp=ans.front();        <span class="hljs-built_in">cout</span>&lt;&lt;temp&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;        ans.pop();        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;num_node;i++)<span class="hljs-comment">/*pop,then modify indegree array, then push new node!*/</span>        &#123;            <span class="hljs-keyword">if</span>(martix[i][temp]&gt;<span class="hljs-number">0</span>)            &#123;                martix[i][temp]--;                indegree[i]--;            &#125;            <span class="hljs-keyword">if</span>(indegree[i]==<span class="hljs-number">0</span>)            &#123;                ans.push(i);                indegree[i]=<span class="hljs-number">-1</span>;            &#125;        &#125;        counter++;    &#125;    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">if</span>(counter!=num_node)<span class="hljs-comment">/*check circle*/</span>    &#123;        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Circle inside!&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> num_edge,num_node;    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Input number of nodes and edges&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cin</span>&gt;&gt;num_node&gt;&gt;num_edge;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">martix</span><span class="hljs-params">(num_node,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(num_node) )</span></span>;       <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Input nodes of each edge:x-&gt;y&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">int</span> x,y;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;num_edge;i++)    &#123;        <span class="hljs-built_in">cin</span>&gt;&gt;x&gt;&gt;y;        martix[y][x]++;    &#125;    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">indegree</span><span class="hljs-params">(num_node)</span></span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;num_node;i++)<span class="hljs-comment">/*calcilate indegree array*/</span>    &#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;num_node;j++)        &#123;            <span class="hljs-keyword">if</span>(martix[i][j]!=<span class="hljs-number">0</span>)            indegree[i]++;        &#125;    &#125;    tuopu(martix,indegree,num_node);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h1 id="单源最短路经"><a href="#单源最短路经" class="headerlink" title="单源最短路经"></a>单源最短路经</h1><p><strong>问题描述：</strong>给定有向图G，其每条边都有一个非负的权值a[ i ] [ j ]，路径长度定义为路径上边的权值之和。<strong>给定源节点S，找出从S到图中所有其他节点的最短路径及其长度。</strong></p><hr><p><strong>迪杰斯特拉算法</strong> <em>适用于权值非负情况</em></p><p>步骤：</p><p><strong>1.维护一个集合S，该集合中源节点到其他节点的最短路已知，初始时该集合为空</strong></p><p><strong>2.从V-S集合中寻找节点v，使源节点到该点距离最小</strong></p><p><strong>3.更新V的临界点到源节点的距离值。</strong></p><p><strong>正确性原理：</strong> 如果权值非负，那么最短路的子路径也是最短路，其长度小于原来路径长度。<em>so，我们从长度小的最短路找起。</em></p><pre><code class="hljs cpp"><span class="hljs-comment">/*easy code using martix to storage martix*/</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> max_node=<span class="hljs-number">50</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> max_dis=<span class="hljs-number">9999</span>;<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span>* S;<span class="hljs-keyword">int</span>* visted;<span class="hljs-keyword">int</span> G [max_node][max_node];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num_node,<span class="hljs-keyword">int</span>* S,<span class="hljs-keyword">int</span> *visted,<span class="hljs-keyword">int</span> G[max_node][max_node])</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> temp;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> m=<span class="hljs-number">0</span>;m&lt;num_node;m++)    &#123;        <span class="hljs-keyword">int</span> min_dis=max_dis;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;num_node;i++)        &#123;            <span class="hljs-keyword">if</span>(visted[i]==<span class="hljs-number">0</span> &amp;&amp; S[i]&lt;min_dis)&#123;                min_dis=S[i];                temp=i;            &#125;        &#125;               visted[temp]=<span class="hljs-number">1</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;num_node;i++)        &#123;            <span class="hljs-keyword">if</span>(G[temp][i]&lt;max_dis)            &#123;                <span class="hljs-keyword">if</span>(S[i]&gt;S[temp]+G[temp][i])                &#123;                    S[i]=S[temp]+G[temp][i];                &#125;            &#125;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> num_node,num_edge;    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Input the number of nodes and edge&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cin</span>&gt;&gt;num_node&gt;&gt;num_edge;    S=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [num_node];    visted=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[num_node];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;num_node;i++)    visted[i]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;num_node;i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;num_node;j++)&#123;            <span class="hljs-keyword">if</span>(i==j)            G[i][j]=<span class="hljs-number">0</span>;            <span class="hljs-keyword">else</span>            G[i][j]=max_dis;        &#125;    &#125;    <span class="hljs-keyword">int</span> x,y,weight;    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Input the edge:X-&gt;Y and input the weight&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;num_edge;i++)    &#123;        <span class="hljs-built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;weight;        G[x<span class="hljs-number">-1</span>][y<span class="hljs-number">-1</span>]=weight;    &#125;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;num_node;i++)    &#123;        S[i]=G[<span class="hljs-number">0</span>][i];    &#125;    visted[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;    dijkstra(num_node,S,visted,G);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;num_node;i++)    <span class="hljs-built_in">cout</span>&lt;&lt;S[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><p><strong>问题描述：</strong></p><p>具有n个顶点的联通的无向图G，图的每条边e有一非负权值c(e)，也称为成本，求有最小成本的生成树，每个生成树刚好具有n-1条边。</p><p>即选择n-1条边使他们形成G的最小生成树。</p><h2 id="Kruskal-算法（以边为对象）"><a href="#Kruskal-算法（以边为对象）" class="headerlink" title="Kruskal 算法（以边为对象）"></a>Kruskal 算法（以边为对象）</h2><p><strong>贪心策略：</strong>每次都选权值最小且与以前选择的边不构成cycle的边e。</p><p><em>需要按权值由大到小对边排序</em></p><pre><code class="hljs cpp"><span class="hljs-comment">/*easy code by merge set*/</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> max_node=<span class="hljs-number">50</span>;<span class="hljs-keyword">int</span>* father;<span class="hljs-keyword">int</span>* son;<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Edge</span>&#123;</span>    <span class="hljs-keyword">int</span> x,y;<span class="hljs-comment">/*x-&gt;y*/</span>    <span class="hljs-keyword">int</span> weight;&#125;;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">mycmp</span><span class="hljs-params">(Edge a, Edge b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> a.weight&lt;b.weight;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">find_root</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">return</span> x==father[x] ? x : find_root(father[x]); &#125;<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">merge_set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> rootx=find_root(x);    <span class="hljs-keyword">int</span> rooty=find_root(y);    <span class="hljs-keyword">if</span>(rootx==rooty)    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(son[rootx]&gt;=son[rooty])&#123;        father[rooty]=rootx;        son[rootx]=son[rooty]+son[rootx];    &#125;    <span class="hljs-keyword">else</span>    &#123;        father[rootx]=rooty;        son[rooty]=son[rooty]+son[rootx];    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> num_node,num_edge;    <span class="hljs-keyword">int</span> counter=<span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> flag=<span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Input the number of nodes and edges&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cin</span>&gt;&gt;num_node&gt;&gt;num_edge;    Edge* edge=<span class="hljs-keyword">new</span> Edge[num_edge];    father= <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [num_node];    son=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [num_node];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;num_node;i++)&#123;        father[i]=i;        son[i]=<span class="hljs-number">1</span>;    &#125;    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Input the edge:x-&gt;y and the weight&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;num_edge;i++)&#123;        <span class="hljs-built_in">cin</span>&gt;&gt;edge[i].x&gt;&gt;edge[i].y&gt;&gt;edge[i].weight;    &#125;    sort(edge,edge+num_edge,mycmp);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;num_edge<span class="hljs-number">-1</span>;i++)&#123;        <span class="hljs-keyword">if</span>(merge_set(edge[i].x,edge[i].y))        &#123;            counter++;            ans+=edge[i].weight;            <span class="hljs-built_in">cout</span>&lt;&lt;edge[i].x&lt;&lt;<span class="hljs-string">&quot;-&gt;&quot;</span>&lt;&lt;edge[i].y&lt;&lt;<span class="hljs-built_in">endl</span>;        &#125;        <span class="hljs-keyword">if</span>(counter==num_node<span class="hljs-number">-1</span>)        &#123;            flag=<span class="hljs-number">1</span>;            <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-keyword">if</span>(flag)    &#123;        <span class="hljs-built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-keyword">else</span>    &#123;        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Wrong data&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="Prime-算法-（以点为对象）"><a href="#Prime-算法-（以点为对象）" class="headerlink" title="Prime 算法 （以点为对象）"></a>Prime 算法 （以点为对象）</h2><p><strong>算法描述：</strong></p><p><strong>1）以某一个点开始，寻找当前该点可以访问的所有的边；</strong><br><strong>2）在已经寻找的边中发现最小边，这个边必须有一个点还没有访问过，将还没有访问的点加入我们的集合，记录添加的边；</strong><br><strong>3）寻找当前集合可以访问的所有边，重复2的过程，直到没有新的点可以加入；</strong><br><strong>4）此时由所有边构成的树即为最小生成树。</strong></p><pre><code class="hljs cpp"><span class="hljs-comment">/*easy code using martix to storage graphy*/</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> Max_dis=<span class="hljs-number">9999</span>;<span class="hljs-keyword">int</span> num_node,num_edge;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">prime</span><span class="hljs-params">(<span class="hljs-keyword">int</span>**G,<span class="hljs-keyword">int</span> num_node,<span class="hljs-keyword">int</span> num_edge)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;Input the number of nodes and edges&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cin</span>&gt;&gt;num_node&gt;&gt;num_edge;    <span class="hljs-keyword">int</span> **G=<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>* [num_node];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt;num_node;i++)G[i] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[num_node];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;num_node;i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;num_node;j++)&#123;            <span class="hljs-keyword">if</span>(i==j)            G[i][j]=<span class="hljs-number">0</span>;            <span class="hljs-keyword">else</span>            G[i][j]=Max_dis;        &#125;    &#125;    <span class="hljs-keyword">int</span> x,y,weight;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;num_edge;i++)    &#123;        <span class="hljs-built_in">cin</span>&gt;&gt;x&gt;&gt;y&gt;&gt;weight;        G[x<span class="hljs-number">-1</span>][y<span class="hljs-number">-1</span>]=weight;        G[y<span class="hljs-number">-1</span>][x<span class="hljs-number">-1</span>]=weight;    &#125;    <span class="hljs-built_in">cout</span>&lt;&lt;prime(G,num_node,num_edge)&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">prime</span><span class="hljs-params">(<span class="hljs-keyword">int</span>**G ,<span class="hljs-keyword">int</span> num_node,<span class="hljs-keyword">int</span> num_edge)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> start[num_node];    <span class="hljs-keyword">int</span> lowdis[num_node];    <span class="hljs-keyword">int</span> minid=<span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> sum=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;num_node;i++)    &#123;        lowdis[i]=G[<span class="hljs-number">0</span>][i];    &#125;    start[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;num_node;i++)    &#123;        <span class="hljs-keyword">int</span> mindis=Max_dis;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;num_node;j++)        &#123;            <span class="hljs-keyword">if</span>(lowdis[j]&lt;mindis&amp;&amp;lowdis[j]!=<span class="hljs-number">0</span>)            &#123;                mindis=lowdis[j];                minid=j;            &#125;        &#125;        lowdis[minid]=<span class="hljs-number">0</span>;        sum+=mindis;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1</span>;j&lt;num_node;j++)        &#123;            <span class="hljs-keyword">if</span>(lowdis[j]&gt;G[minid][j])            &#123;                lowdis[j]=G[minid][j];                start[j]=minid;            &#125;        &#125;    &#125;    <span class="hljs-keyword">return</span> sum;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>flie-system</title>
    <link href="/2020/12/04/flie-system/"/>
    <url>/2020/12/04/flie-system/</url>
    
    <content type="html"><![CDATA[<p>文件：名称(存在目录中)，属性，数据(存在数据块中)</p><p>inode 可以连续存储也可以非连续存储</p><p>存储属性(owner group size type…)。</p><p>1 file 1 inode-&gt; inumber</p><p>目录文件也有对应的inode，属性，内容(目录内文件名，inumber)</p><p>inode表由内核维护共享</p><p>root dic 的inumber由系统记录。</p><p>root dir 由inumber查inode表，读其数据块，知道目录内文件及inumber</p><p>索引复杂度取决于：目录深度与各层目录下文件多少。</p><p>OS可以控制目录深度：CWD（当前工作目录）//使用相对路径</p><p>data值即为pointer</p><h1 id="shared-files"><a href="#shared-files" class="headerlink" title="shared files"></a>shared files</h1><p>软链接/硬链接</p><h1 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h1><p>按块/扇区分配，优点：访问速度快。实现随机访问。</p><p>缺点：连续存储对文件大小不固定的文件可能会导致没有空余空间，只能剪切。</p><h1 id="非连续，link-list"><a href="#非连续，link-list" class="headerlink" title="非连续，link list"></a>非连续，link list</h1><p>大小灵活，访问速度慢。</p><h1 id="多级索引-商用"><a href="#多级索引-商用" class="headerlink" title="多级索引 商用"></a>多级索引 商用</h1><p> 部分作为直接指针（指向数据块）</p><p>部分作为K级间接指针(指向表)</p><p><strong>计算指向数据大小</strong></p><p>12+（1024/4)+(1024/4)(1024/4)+(1024/4)^3 </p><h1 id="Realize-file-system"><a href="#Realize-file-system" class="headerlink" title="Realize file system"></a>Realize file system</h1><p><strong>VFS将用户与file system隔绝</strong></p><p><strong>EXT2</strong></p><p>filesystem is full when:</p><p>1.No more inode block</p><p>2.No more data block</p><p> 多少个字节应该有一个inode( bytes-per-inode) 4096default(1:31)</p><p><strong>空闲块管理</strong></p><h1 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h1><h2 id="disk"><a href="#disk" class="headerlink" title="disk"></a>disk</h2><p>IDE<em>并行接口</em></p><p>ATA<em>串行接口</em></p><p>-PATA（parallel ATA / IDE）</p><p>-SATA（serial ATA）</p><p>SCS</p><p>SAS /server/</p><p>SSD/读写不对称，读&gt;&gt;写/</p><p><strong>磁盘臂调度算法</strong></p><p>time： seek time + rotational time + data read time(要读扇区转的时间)</p><h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a><strong>调度算法</strong></h2><h3 id="FCFS"><a href="#FCFS" class="headerlink" title="FCFS"></a>FCFS</h3><h3 id="SSTF"><a href="#SSTF" class="headerlink" title="SSTF"></a>SSTF</h3><h3 id="SCAN"><a href="#SCAN" class="headerlink" title="SCAN"></a>SCAN</h3><p>一定会到顶，再折返。指明当前位置与方向。</p><h3 id="C-SCAN"><a href="#C-SCAN" class="headerlink" title="C-SCAN"></a>C-SCAN</h3><p>返程不响应。 解决SCAN对两端的不公平。</p><h3 id="LOOK"><a href="#LOOK" class="headerlink" title="LOOK"></a>LOOK</h3><p> 不会到顶。请求max min，确定范围。返程提供服务</p><h3 id="C-LOOK"><a href="#C-LOOK" class="headerlink" title="C-LOOK"></a>C-LOOK</h3><p>返程不响应。不会到顶。</p><h2 id="partition"><a href="#partition" class="headerlink" title="partition"></a>partition</h2><h1 id="LVM-server-back"><a href="#LVM-server-back" class="headerlink" title="LVM(server/back)"></a>LVM(server/back)</h1><p>Volume Group</p><p>Physical Volume分成PE，以块为单位划分为逻辑卷</p><pre><code class="hljs bash">pvcreat /dev/sda3vgcreatelvcreate -L 50M -n</code></pre><h1 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h1><p><strong>redundant array of independent disks</strong></p><p>PC:</p><p>slower, less reliable , smaller , but cheap;</p><p>RAID use multiple hard disks int an array to create a logic device.</p><p>Spare disk</p><h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>大学？人生？</title>
    <link href="/2020/11/13/%E6%9C%88%E5%A4%9C%E6%9D%82%E8%B0%88/"/>
    <url>/2020/11/13/%E6%9C%88%E5%A4%9C%E6%9D%82%E8%B0%88/</url>
    
    <content type="html"><![CDATA[<p>最近看到诺奖得主塞门扎学术问题的新闻，不禁又对这个问题产生思考。</p><a id="more"></a><p>上大学！</p><p>上大学是为了什么？</p><p>最近看到诺奖得主塞门扎学术问题的新闻，不禁又对这个问题产生思考。</p><p>学术巨擘也会为了名利造假，这对我的梦想给了沉重的一拳。</p><p>&emsp;</p><p>回顾鄙人的姑且算作一年半的大学时光，很可悲的是，我竟然没有感觉到她与高中有什么明显的不同。</p><p>GPA和加权仿佛成为了我唯一追逐的东西，我记得我刚进校园的时候不是这个样子啊！？</p><p>记得大一上学期，中美贸易战刚刚开打，我当初立志于投身计算机底层，为祖国的薄弱之处补上一环。但到这次选专业的时候，我觉得我的目标似乎…变了一些，这次选专业，我首先想到的是这个专业好不好保研，卷不卷。</p><p>大一的我还会抽时间读杂书，学一些文史哲，读一些马哲。但大二的这半个学期，我感觉我只是一个学习的机器。</p><p>整天忙来忙去却没有找到目的，总感觉自己有一部分被抽掉了。</p><p>仿佛刚入校门的那个我已经被我忘掉了。</p><p>虽然最后还是选了计科，以后想向底层进军，但我真的真的真的不确定自己能否抗住现实的重击。</p><p>&emsp;</p><p>现在社会和校园的感觉对我来说就是——浮躁。</p><p>一个追名逐利的社会已经将象牙塔中的师生拉入了社会这个大染缸。</p><p>很多人为了就业拼命往CS中跳，有人混到毕业只为找个工作，有人委屈读研只为职业生涯…</p><p>这么多人都只为小家，这样真的好吗？</p><p>我并不是质疑人，而是在质疑这个时代，这个时代是最好的，也是最坏的…</p><p>&emsp;</p><p>现在的我知道底层工资待遇不会很好，但我想去，我感兴趣，我有理想有目标。</p><p>但我真的能接受同届毕业生三倍于我的工资吗？我真的能抗住物质生活压力而坚持自己的理想吗？我真的能守护住自己心中的那个白月光吗？</p><p>我不知道，我也不想知道。</p><p>&emsp;</p><p>在我的遗愿清单里我写到，我想为祖国做贡献，我想和马克思有灵魂的接触。</p><p>我不想让这个遗愿清单变成一个失望清单。</p><p>我更不想在大四的时候回顾我的本科阶段，感觉到这不是我，或者感觉到这就是我。</p><p>&emsp;</p><p>这时候想起来三问桥上的那三问</p><p>“懂吗？会吗？敢吗？”</p><p>我现在的答案是：不懂，不会，不敢。</p><p>希望两年后的我，可以更好地回答这三个问题吧…</p><p>单向的人生没有返回的机会，</p><p>但我这个无知的婴儿却在无畏地向前走，</p><p>我想停，却愈发觉得步伐变快，</p><p>我想跑，却总是止步不前，</p><p>我想知道向前会遇到什么，</p><p>那条未知的路给我的只有漆黑的沥青，</p><p>一天，我突然回头，</p><p>我走过的路上既有明媚的阳光，</p><p>也有灰色的乌云，</p><p>我环顾四周，</p><p>目光不由得再次被那漆黑的路而吸引，</p><p>那，是我未知的颜色。</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Life</tag>
      
      <tag>Thinking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dynamic Programming</title>
    <link href="/2020/11/07/Dynamic-Programming/"/>
    <url>/2020/11/07/Dynamic-Programming/</url>
    
    <content type="html"><![CDATA[<p>Share and review my study process.</p><a id="more"></a><h1 id="引论"><a href="#引论" class="headerlink" title="引论"></a>引论</h1><p><strong>个人理解动态规划应该是一种设计技巧，和分治法类似，但DP更关心子问题的重叠。</strong></p><p>动态规划是一种在各个不同大小(size)的子问题的优化值之间建立递归关系并求解的过程.</p><p>能使用动态规划求解的问题必须<strong>满足优化原理：</strong></p><p><strong>优化解包含的子问题的解也是最优的</strong></p><p>即可利用优化原理，使用枚举法建立不同长度子问题优化值之间的递归关系—动态规划方程。</p><p><em>注意，动态规划算法得出的解为精确解，子问题的数目决定了该算法的复杂度.</em></p><p><em>Ps: 尽量不要用递归</em></p><h1 id="经典的0-1背包"><a href="#经典的0-1背包" class="headerlink" title="经典的0/1背包"></a>经典的0/1背包</h1><p><strong>给定 n 种物品和一个容量为 C 的背包，物品 i 的重量是 wi，其价值为 vi 。</strong></p><p><strong>问：应该如何选择装入背包的物品，使得装入背包中的物品的总价值最大？</strong></p><p>&emsp; </p><p>在学习DP算法之前，我们面对01背包问题有的思路就是贪心和穷举：</p><p>不管是对价值排序还是对价值密度排序，只是改变了贪心策略，但还是贪心算法，也就意味着我们只能求解一个近似解，无法得到精确解。</p><p>而穷举法的开销太大了，在很多情况下复杂且不适用。</p><p><strong>既然贪心法在理论上是无法得到精确解的，那我们能否在穷举的基础上进行优化呢？</strong></p><h2 id="来一个具体的例子"><a href="#来一个具体的例子" class="headerlink" title="来一个具体的例子"></a><strong>来一个具体的例子</strong></h2><p>n=5,c=10,w=[2,2,6,5,4],p=[6,3,5,4,6]. </p><p>可知此时的优化解为(1,1,0,0,1),即装1,2,5物品</p><p>想要用DP算法，首先要判断<strong>问题是否满足优化原理</strong></p><p>即优化解包含的子问题的解是否最优。</p><blockquote><p>当我们先装物品1时。</p><p>物品1装入，子问题为n=4,c’=c-2(物品1的重量),物品为2,3,4,5</p><p>可以看到子问题的优化解为(1,0,0,1)</p><p>与优化解相同</p></blockquote><p>可以得知<strong>01背包问题满足优化原理</strong>。</p><h2 id="DP的思路分析"><a href="#DP的思路分析" class="headerlink" title="DP的思路分析"></a>DP的思路分析</h2><p>面对n个物品，我们并不知道该拿哪几个才是最优解，那么就使用计算机最擅长的技能：计算(遍历)</p><p>只不过我们会对遍历进行一些操作</p><p>设函数 f(i,y)表示当背包容量为y时，面对 i，i+1,…，n物品时的最优解。</p><p>可以知道f(1,c)就是我们最终要求的答案</p><p>求 f(1,c)遇到的第一个问题就是物品1拿不拿？</p><p>答案是：不知道。&emsp; 但我们可以根据子问题推出来物品1拿不拿。</p><p><strong>f(1,c)=max{f(2,c), f(2,c-w1)+p1}</strong></p><p>这样我们的思路就出来了：建立一个父问题与子问题递归式。即在最后一个物品时返回两种情况：拿或不拿。再一路返回到第一种情况，判断物品1拿不拿。</p><p>下面是递归算法和非递归算法</p><h2 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h2><pre><code class="hljs cpp"><span class="hljs-comment">//递归算法</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> content;<span class="hljs-keyword">int</span> num_things;<span class="hljs-keyword">int</span> weightt[<span class="hljs-number">101</span>];<span class="hljs-keyword">int</span> value[<span class="hljs-number">101</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> thing,<span class="hljs-keyword">int</span> content)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> dp1=<span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> dp2;    <span class="hljs-keyword">if</span>(thing==num_things<span class="hljs-number">-1</span>)    &#123;        <span class="hljs-keyword">if</span>(content&lt;weightt[num_things<span class="hljs-number">-1</span>])        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-keyword">return</span> value[num_things<span class="hljs-number">-1</span>];        &#125;            &#125;    <span class="hljs-keyword">if</span>(content&gt;=weightt[thing])    dp1=dp(thing+<span class="hljs-number">1</span>,content-weightt[thing])+value[thing];    dp2=dp(thing+<span class="hljs-number">1</span>,content);    <span class="hljs-keyword">return</span> max(dp1,dp2);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cin</span>&gt;&gt;content&gt;&gt;num_things;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;num_things;i++)    <span class="hljs-built_in">cin</span>&gt;&gt;weightt[i];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;num_things;i++)    <span class="hljs-built_in">cin</span>&gt;&gt;value[i];    <span class="hljs-built_in">cout</span>&lt;&lt;dp(<span class="hljs-number">0</span>,content)&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>由于递归算法开销很大，所以我们使用元组法来实现DP</p><h1 id="当W为整数时-迭代法"><a href="#当W为整数时-迭代法" class="headerlink" title="当W为整数时 迭代法"></a>当W为整数时 迭代法</h1><pre><code class="hljs cpp"><span class="hljs-comment">/*Easy code using martix, and all need to do is initial it*/</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> Maxnumber=<span class="hljs-number">100</span>;<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> Maxvalue=<span class="hljs-number">100</span>;<span class="hljs-keyword">int</span> f[Maxnumber][Maxvalue];<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">knapsack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p[],<span class="hljs-keyword">int</span> w[],<span class="hljs-keyword">int</span> c,<span class="hljs-keyword">int</span> n)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-comment">//initial f[n][i]</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> y=<span class="hljs-number">0</span>;y&lt;w[n<span class="hljs-number">-1</span>]<span class="hljs-number">-1</span>;y++)    f[n<span class="hljs-number">-1</span>][y]=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> y=w[n<span class="hljs-number">-1</span>]<span class="hljs-number">-1</span>;y&lt;c;y++)    f[n<span class="hljs-number">-1</span>][y]=p[n<span class="hljs-number">-1</span>];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n<span class="hljs-number">-2</span>;i&gt;<span class="hljs-number">0</span>;i--)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;w[i]<span class="hljs-number">-1</span>;j++)        f[i][j]=f[i+<span class="hljs-number">1</span>][j];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=w[i]<span class="hljs-number">-1</span>;j&lt;c;j++)        f[i][j]=max(f[i+<span class="hljs-number">1</span>][j],f[i+<span class="hljs-number">1</span>][j-w[i]]+p[i]);    &#125;    f[<span class="hljs-number">0</span>][c<span class="hljs-number">-1</span>]=f[<span class="hljs-number">1</span>][c<span class="hljs-number">-1</span>];    <span class="hljs-keyword">if</span>(c&gt;=w[<span class="hljs-number">0</span>])    f[<span class="hljs-number">0</span>][c<span class="hljs-number">-1</span>]=max(f[<span class="hljs-number">1</span>][c<span class="hljs-number">-1</span>],f[<span class="hljs-number">1</span>][c<span class="hljs-number">-1</span>-w[<span class="hljs-number">0</span>]]+p[<span class="hljs-number">0</span>]);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> p[Maxnumber];    <span class="hljs-keyword">int</span> w[Maxnumber];    <span class="hljs-keyword">int</span> n;    <span class="hljs-keyword">int</span> c;    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;input the number of things and content of package&quot;</span>&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-built_in">cin</span>&gt;&gt;n&gt;&gt;c;    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;input value of each thing\n&quot;</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)    <span class="hljs-built_in">cin</span>&gt;&gt;p[i];    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">&quot;input weight of each thing\n&quot;</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)    <span class="hljs-built_in">cin</span>&gt;&gt;w[i];    knapsack(p,w,c,n);    <span class="hljs-built_in">cout</span>&lt;&lt;f[<span class="hljs-number">0</span>][c<span class="hljs-number">-1</span>]&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=n<span class="hljs-number">-1</span>;i&gt;<span class="hljs-number">0</span>;i--)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;c;j++)        <span class="hljs-built_in">cout</span>&lt;&lt;f[i][j]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;        <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-built_in">endl</span>;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="元组法"><a href="#元组法" class="headerlink" title="元组法"></a>元组法</h2><p>仔细回想我们的01背包问题，是否有这样一个感觉，效益值=f(i,y)是一个分段函数，且每一段都是效益值不变的水平直线。</p><p>那么我们只要记住分段函数的跳跃点，是否就可以对输入的每种情况进行还原(和数据结构中稀疏矩阵的存储相似)</p><p>&emsp;</p><p>由于f(i, y)=max{ f(i+1,y),f(i+1,y-w<del>i</del>)+p<del>i</del> }</p><p>设f(i,y)对应元组P(i), f(i+1,y-w<del>i</del>)+p<del>i</del>对应元组Q</p><p>我们想要得到的是P(i)，所以我们需要求P(i+1)和Q。</p><p>由于f(i+1,y-w<del>i</del>)+p<del>i</del>可看作f(i+1,y)向右向上平移，所以P中每个元组(a,b)对应Q中的(a+wi,b+pi)</p><p>&emsp; </p><p>求出P(i+1)和Q后，使用类似于merge排序的方法把两个元组中的点合并</p><p><strong>合并规则：</strong></p><p><strong>合并时使用以下支配(选优)规则:</strong></p><p><strong>设(a,b)和(u,v)是来自P(i+1)和Q的元组,若a≥u且b＜v,则称(a,b)受(u,v) 支配. 因为</strong></p><p><strong>(a,b)代表以容量a得到效益值b的方案,</strong></p><p><strong>而(u,v)代表以较少的容量u得到较大效益值v的装包方案.</strong></p><p>(可以想象为两个分段函数一直取x相等时二者y值最大的一段)</p><p>&emsp;</p><p><strong>得到P(2)后我们可以不求P(1)</strong></p><p>直接利用w<del>1</del>和P(2)来求出满足w<del>1</del>+w&lt;C的最后一个元组（w,v）</p><p>将v+p<del>1</del>与原来P(2)中最后一个满足条件的效益值比较，取最大的那个。 </p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>人这一辈子，最不能透支的是什么？</title>
    <link href="/2020/11/03/%E5%85%B1%E5%8B%89/"/>
    <url>/2020/11/03/%E5%85%B1%E5%8B%89/</url>
    
    <content type="html"><![CDATA[<p>午觉起来看到知乎一个高赞回答，分享一下，与君共勉。</p><a id="more"></a><p>作者：简在我心<br>链接：<a href="https://www.zhihu.com/question/422796779/answer/1556486657">知乎链接</a><br>来源：知乎</p><p>生命力。</p><p>今天上午给学生讲解电影《死亡诗社》，对这个问题正好深有感触。</p><p>这个影片里，反复提到一些词：热情，激情，爱，浪漫，强有力，奋斗，寻觅，发现，呐喊……</p><p>人类这个物种有个很大的优势就是对新鲜事物的好奇性。</p><p>我们喜欢探奇历险，喜欢学习研究。但是这种行为具有风险。</p><p>所以长辈或管理者为了安全需要和管理方便，会制定各种规则，把那个内心里生动活泼的小人儿关进牢笼里。</p><p>不让你玩水，不让你玩火，不让你爬树，不让你恋爱，不让你问为什么，不让你做这个做那个。</p><p>美其名曰：为你好。</p><p>然后你的生命力就会在种种禁锢中持续性流失和透支。</p><p>你变得对生活失去了热情，对世界失去了探索的欲望，你没有了学习的兴趣，没有了爱的能力……</p><p>失去生命力的表现：</p><p>你刷着抖音，停不下来，哪怕已经厌倦，也还是忍不住继续滑动手指。</p><p>你躺在床上，睡到头疼，浑身无力，不想再躺下去了，却依然缺乏起床的动力。</p><p>你玩着游戏，玩到疲惫不堪，但依然百无聊赖地点着鼠标，两眼无光。</p><p>你频繁和五姑娘交谈，谈到昏昏沉沉，依然不想松开她。</p><p>你失去了对自己的生命的强有力的感觉。</p><p>你沦丧于无聊的重复的形式中，无力自拔。</p><p>失去了生命的热情和希望。</p><p>失去了对于自我身体的掌控。</p><p>失去了对事物的感知能力。</p><p>你疲惫，疲软，无力，无感，靠反复的刺激来提醒自己好像还活着。</p><p>我认为这就是生命力透支的表现，是最糟糕的生活状态，没有之一。</p><p>我为什么感受那么深？</p><p>最近跟学生交流，发现他们很多人都已经处于这种生命力透支的状态。</p><p>你问他还有什么理想、希望或想做的事情。好像没有，或即便有也是缺乏可持续性。</p><p>所以他们只能浑浑噩噩地混日子。</p><p>为什么那么多人抑郁、自杀或躺平？</p><p>因为他们的生命力已经透支了，枯竭了，对生活已经没有了热情，没有了希望，也没有了信心。</p><p>才不到二十岁的年纪，就失去了狂野、野心、激情、欲望。</p><p>这是一个多么令人痛心的事实。</p><p>所以别说什么成才，就是过好自己平凡一生都很难了。</p><p>这将是一个个了无生趣的生命。</p><p>这就是不重视人文教育的后果。</p><p>生命需要呵护，需要个性的张扬和奔放，需要自由的空气，才能健康成长，才能抵御现实的风霜雪剑。</p><p>可是我们以爱的名义，剥夺了孩子们的生命力，使得他们还没绽放，就已经枯萎了。</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Life</tag>
      
      <tag>Thinking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日洛谷_9.28</title>
    <link href="/2020/09/28/%E6%AF%8F%E6%97%A5%E6%B4%9B%E8%B0%B7-9-28/"/>
    <url>/2020/09/28/%E6%AF%8F%E6%97%A5%E6%B4%9B%E8%B0%B7-9-28/</url>
    
    <content type="html"><![CDATA[<p>今天刷洛谷基础题看到一个很好的题，分享一下。</p><a id="more"></a><p>​    <a href="https://www.luogu.com.cn/problem/P2181">原题链接</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>对于一个 n 个顶点的凸多边形，它的任何三条对角线都不会交于一点。请求出图形中对角线交点的个数。</p><p>例如，6 边形：</p><img src="/2020/09/28/%E6%AF%8F%E6%97%A5%E6%B4%9B%E8%B0%B7-9-28/6023.png" style="zoom: 80%;"><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入只有一行一个整数 nnn，代表边数。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行一个整数代表答案。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入 #1 &nbsp;&emsp;输入#2</p><blockquote><p>3 &nbsp; &emsp;&nbsp;      6</p></blockquote><p>输出#2 &nbsp; &emsp; 输入#2</p><blockquote><p>0 &nbsp; &emsp;      &nbsp;15</p></blockquote><h2 id="说明与提示"><a href="#说明与提示" class="headerlink" title="说明与提示"></a>说明与提示</h2><ul><li>对于 50%50 %50% 的数据，保证 3≤n≤100。</li><li>对于 100%100 %100% 的数据，保证 3≤n≤10^5。</li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先看题目中一句<strong>任何三条对角线都不会交于一点</strong>，所以给定<strong>一个交点，可以确定两条对角线——也就意味着确定了四个角</strong></p><p>所以这道题就变成了一个排列问题</p><p>即求Cn4的组合数问题 ：就是求 n * (n-1) * (n-2) * (n-3) /24</p><p>这时大家可能会想&nbsp;”啊，这个题目这么简单，怎么会有人拿他出来写博客！”</p><p>所以你就写出了下面的代码</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> n;<span class="hljs-keyword">int</span> outcome;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cin</span>&gt;&gt;n;    outcome=n*(n<span class="hljs-number">-1</span>)*(n<span class="hljs-number">-2</span>)*(n<span class="hljs-number">-3</span>)/<span class="hljs-number">24</span>;    <span class="hljs-built_in">cout</span>&lt;&lt;outcome&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>结果</p><p><img src="/2020/09/28/%E6%AF%8F%E6%97%A5%E6%B4%9B%E8%B0%B7-9-28/%E7%BB%93%E6%9E%9C.png" alt="结果"></p><p><strong>再仔细阅读下题目，你会发现这道题会爆数据的…</strong></p><p><strong>所以你把int 全部换成了long long 或者unsigned long long ，并沾沾自喜，这么简单不会真有人拿出来写博客吧！</strong></p><p>结果你又发现出现了两个WA…（手动狗头）</p><p>这时你想到，我可以写高精求组合数啊</p><p><em>这无疑是一种很好的解题方法，但对于这样一道入门题来说，未免太…</em></p><p><strong>所以给出了一个很妙的写法</strong></p><p>那就是把 n * (n-1) * (n-2) * (n-3) /24写成 n * (n-1)/2 *(n-2) /3 *(n-3)/4</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> outcome;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cin</span>&gt;&gt;n;    outcome=n*(n<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>*(n<span class="hljs-number">-2</span>)/<span class="hljs-number">3</span>*(n<span class="hljs-number">-3</span>)/<span class="hljs-number">4</span>;    <span class="hljs-built_in">cout</span>&lt;&lt;outcome&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;</code></pre><p>现在来分析一下为什么这样写是对的。</p><p>首先n * (n-1)中一定有一个是2的倍数，所以可以被2整除</p><p>n * (n-1) *(n-2)中一定有一个是3的倍数，所以可以被3整除</p><p>n * (n-1) * (n-2) * (n-3) 中一定有一个是4的倍数，所以可以被4整除</p><p>emmmmmmmmmmm，就差不多是这样了</p><p>溜了溜了，上课去。</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>欧几里得算法</title>
    <link href="/2020/09/22/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/"/>
    <url>/2020/09/22/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>昨天上算法课听到了这个算法，突发兴趣来写一篇blog。</p><a id="more"></a><h1 id="欧几里得算法的用处"><a href="#欧几里得算法的用处" class="headerlink" title="欧几里得算法的用处"></a>欧几里得算法的用处</h1><p>欧几里得算法也称为辗转相除法，是求解最大公约数的一种方法。</p><p>若有两个数a和b，求a和b的最大公约数，按照我们之前所学的东西，可能只会枚举a与b的因子，效率很低…</p><p>但欧几里得为我们提供了一个十分便捷的方法。</p><h1 id="一个强大的定理"><a href="#一个强大的定理" class="headerlink" title="一个强大的定理"></a>一个强大的定理</h1><p><strong>gcd(a,b) = gcd(b, a%b)</strong></p><p>下面给出证明</p><pre><code class="hljs cpp">设a与b的公约数为 k ，a=bx+y;则 k|a 且 k|b ，有 a%b=y又有y=a-bx, 所以 k|y。即 k|a%b再假设b 与 a%b的公约数为kk，得 kk|a，所以(a,b)与(b,a%b)的公约数相同，所以其最大公约数也相同。即gcd(a,b)==gcd(b,a%b);</code></pre><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>任何数与0的最大公约数都是他本身，且根据gcd(a,b)==gcd(b,a%b)可得知</p><p>当gcd中余数为0时，另一个数就是最大公约数。</p><p>所以代码如下</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> outcome;    <span class="hljs-keyword">int</span> temp;    <span class="hljs-keyword">while</span>(b!=<span class="hljs-number">0</span>)    &#123;        temp=a%b;        a=b;        b=temp;    &#125;    outcome=a;    <span class="hljs-keyword">return</span> outcome;&#125;</code></pre><p><em>溜溜球，去学概率论了…</em></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>世界反法西斯战争胜利75周年有感</title>
    <link href="/2020/09/03/%E4%B8%96%E7%95%8C%E5%8F%8D%E6%B3%95%E8%A5%BF%E6%96%AF%E6%88%98%E4%BA%89%E8%83%9C%E5%88%A975%E5%91%A8%E5%B9%B4%E6%9C%89%E6%84%9F/"/>
    <url>/2020/09/03/%E4%B8%96%E7%95%8C%E5%8F%8D%E6%B3%95%E8%A5%BF%E6%96%AF%E6%88%98%E4%BA%89%E8%83%9C%E5%88%A975%E5%91%A8%E5%B9%B4%E6%9C%89%E6%84%9F/</url>
    
    <content type="html"><![CDATA[<p>​       这是我今年第三次流泪：第一次是在听《国际歌》的时候，第二次是在读《悲惨世界》的时候，今天是第三次。但这次除了流泪，我还有一些忧虑。</p><a id="more"></a><p>​        “为有牺牲多壮志，敢叫日月换新天”。法西斯的阴云在中华大地盘旋了十四年，三千五百万烈士在反法西斯战争中牺牲。他们在极度艰苦的环境中仍坚守心中理想，献身于保卫祖国的斗争，以自己的血肉之躯换来了中华民族的转折点，换来了现在的人民共和国，换来了民族运动的高潮。他们的事迹永世长存，他们的功绩永垂不朽。</p><p>​        中国人民的斗争无疑对世界法西斯主义进行了沉重的打击，但法西斯主义已经完全消散了吗？红色的太阳已经高悬了吗？</p><p>​        只怕这片阴云恐怕还在盘旋，太阳也才刚放出光芒。</p><p>​        世界经济形势低迷，势必会带来社会变革。而对于现在的出路只有两条：左转，马列主义；右转，法西斯主义。而资本主义的领头人——美国，目前地表最强的国家，正在带领着一众资本主义国家向右疾行。而随着苏联的解体，国际共运陷入了又一次低潮，资本主义国家人民的声音越来越小。</p><p>​        再加上最近美国对华动作不断：贸易战、对台动作、驱逐中国留学生……，这一系列动作不禁让我想起了纳粹德国，担心会出现一个新的“水晶之夜”。担心出现像拉斯科利尼科夫那样的人——一个自认为非凡的普通人。我们已经为旧的法西斯主义付出了三千五百万条生命的代价，我们不能再忍受这样沉痛的代价。</p><p>​        昔日的盟友已经在法西斯道路上渐行渐远，屠龙者已经成为了恶龙。我们更不应松开我们的反法西斯历史，成为世界下一座灯塔。</p><p>​        现在世界上除了我们，再也没有人能担起反法西斯战士的称号了！达瓦里氏，我们的前途是光明的，社会主义的又一次高潮即将出现在东方；我们的前途也是崎岖的，我们面对的是前所未有的强大的敌人——美国，一个远比纳粹德国强大的力量。</p><p>​        在黎明到来前，会有很多人倒下，但我们终将迎来光明。</p><p>​        达瓦里氏，你，愿意和我一起吗？</p>]]></content>
    
    
    <categories>
      
      <category>缅怀</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Thinking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>My Bucket List -- version 1</title>
    <link href="/2020/08/11/My-Bucket-List-version-1/"/>
    <url>/2020/08/11/My-Bucket-List-version-1/</url>
    
    <content type="html"><![CDATA[<p>0.希望能为国家突破一些技术障碍</p><a id="more"></a><p>1.去俄罗斯游玩，再去伦敦的马克思墓地</p><p>2.帮助一个陌生人</p><p>3.对一个女生表白 and 亲吻世界上最美的女生</p><p>4.跑完一次马拉松</p><p>5.写出一个属于自己的纪念app/网页</p><p>6.去当国际志愿者 and 去联合国转转</p><p>7.见勒布朗 詹姆斯一面</p><p>8.开一次枪、坐直升机跳伞</p><p>9.把自己都捐了</p><p>…</p><p>正在努力的事情：</p><p>9.阅读马列主义书籍及其他世界名著</p><p>10.编程，进入ACM队</p><p>11.复习…</p><p>12.坚持跑步、锻炼</p><p>13.捐款</p><p>14.成为党员</p><p>15.保研到THU</p><p>16.能为国家硬件/软件做出自己的贡献</p>]]></content>
    
    
    <categories>
      
      <category>Bucket List</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Life</tag>
      
      <tag>Thinking</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

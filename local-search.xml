<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux-存储管理</title>
    <link href="/2020/11/17/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2020/11/17/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>计算机组成及Linux系统基础知识、实验思路解析</p><a id="more"></a><h1 id="speed-problem"><a href="#speed-problem" class="headerlink" title="speed problem"></a>speed problem</h1><p>局部性原理</p><p>TLB(Translation Lookaside Buffer)&emsp; 相联存储器 &emsp; 快表(内存中叫慢表，存了全部的页表信息)</p><h1 id="Storage-Problem"><a href="#Storage-Problem" class="headerlink" title="Storage Problem"></a>Storage Problem</h1><p>请求式分页+多级页表(局部性原理) &emsp;时间换空间</p><p>倒排页表</p><p>1 OS，1 page，大小取决于物理内存大小。</p><p>下标为物理页帧号，内容存的是逻辑页号。</p><p>根据内容查找。</p><p>硬件实现hash查找(TLB)</p><h1 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h1><h1 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h1><p>抖动(thrashing)</p><h2 id="最优页面置换算法"><a href="#最优页面置换算法" class="headerlink" title="最优页面置换算法"></a>最优页面置换算法</h2><h2 id="最近未使用页面置换算法"><a href="#最近未使用页面置换算法" class="headerlink" title="最近未使用页面置换算法"></a>最近未使用页面置换算法</h2><h2 id="FF置换算法"><a href="#FF置换算法" class="headerlink" title="FF置换算法"></a>FF置换算法</h2><h2 id="二次机会页面算法"><a href="#二次机会页面算法" class="headerlink" title="二次机会页面算法"></a>二次机会页面算法</h2><h2 id="时钟页面置换算法"><a href="#时钟页面置换算法" class="headerlink" title="时钟页面置换算法"></a>时钟页面置换算法</h2><h2 id="LRU-最近最少使用"><a href="#LRU-最近最少使用" class="headerlink" title="LRU 最近最少使用"></a>LRU 最近最少使用</h2>]]></content>
    
    
    <categories>
      
      <category>Operating System</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux-进程</title>
    <link href="/2020/11/14/Operating%E2%80%94-System/"/>
    <url>/2020/11/14/Operating%E2%80%94-System/</url>
    
    <content type="html"><![CDATA[<p>Basic knowledge about OS &amp;&amp; Linux. Solutions about MIT 6.828</p><a id="more"></a><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h2><p>进程是一个正在执行程序的实例，包括了程序代码和它当前的状态（寄存器…）</p><p>一个进程包括三个部分</p><p><img src="/2020/11/14/Operating%E2%80%94-System/Process.png" alt="process contains"></p><p><em>Tips: The differences between process and program</em></p><p><em>Program is just the static text</em></p><p><em>Process is an dynamic entity being executed and has lifecycle</em></p><p><em>So if a program exec two times ,there should be two processes</em></p><h2 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h2><p>四种事件会导致进程的创建:</p><p>1.系统初始化</p><p>2.正在运行的程序执行了创建进程的系统调用</p><p>3.用户请求创建一个新进程</p><p>4.批处理作业的初始化</p><p>新进程都是由一个已存在的进程执行了一个用于创建进程的系统调用而创建。</p><p>在Linux中，只有fork这个系统调用可用来创建进程。</p><p>fork后，创建的子进程会和父进程拥有相同的内存映像、环境变量。通常，子进程会接着执行一个execve之类的系统调用来修改内存映像从而运行一个新的程序。</p><h2 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h2><p>进程终止的条件：</p><p>1.正常退出(自愿的)</p><p>2.出错退出(自愿的) 自愿时通常调用exit系统调用</p><p>3.严重错误(非自愿)</p><p>4.被其他进程杀死(非自愿)//在Linux和Windows中，如果一个进程被杀死，但他创建的进程不会被全部杀死</p><h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><p><img src="/2020/11/14/Operating%E2%80%94-System/%E7%8A%B6%E6%80%81.png" alt="进程状态"></p><p>处于阻塞状态的进程不会参与进程调度，处在运行和就绪状态的进程会在就绪队列中。</p><p>Running-&gt;Block：进程需要等待数据(自发)</p><p>Running-&gt;Ready：调度程序造成(优先级调度、时间片流转…)</p><p>Ready-&gt;Running：调度程序造成</p><p>Block-&gt;Ready：1.进程发起。2.OS发起。</p><h2 id="进程的生命周期"><a href="#进程的生命周期" class="headerlink" title="进程的生命周期"></a>进程的生命周期</h2><img src="/2020/11/14/Operating%E2%80%94-System/lifeline.png" alt="image-20201114151211842" style="zoom: 67%;"><p><strong>I (Idle) state</strong>（空闲状态）</p><p>进程在被创造前需要在进程/线程表中申请一个空间，这时处于SNONE状态</p><p>进程正在被创作时，需要向内存申请存储空间，此时处于SIDL状态。</p><p><strong>A (active) state</strong>（活跃状态）</p><p>当进程处于A状态时，他会有一个或多个线程处于R(ready to run)状态。这些线程必须和其他处于R态的线程共用CPU。CPU同时只能跑一个线程(不考虑多处理器)</p><p>当线程需要等待事件发生或者输入输出时，为了不浪费CPU，他会进入sleep状态并且放弃CPU使用权。当输入/输出结束，线程会被唤醒进入R状态。</p><p>线程可能会被一些信号终止或者开启。当线程被挂起时，他处于T状态，无法执行。</p><p><strong>Z (zombie) state</strong>（僵尸状态）</p><p>当一个进程死亡(结束）时，他会变成僵尸进程。</p><p>僵尸进程除了进程/线程表外不占用其他资源。他只会存活很短的时间，直到他的父进程发出信号，清理进线程表。</p><p>但是当一个进程的父进程先于子进程死亡时/或者无法发出信号时，就会在OS中留下僵尸进程。</p><p>如果OS长时间运行，进程表可能会被僵尸进程塞满，无法再开启新的进程(重启系统)。</p><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="我们为什么需要线程？"><a href="#我们为什么需要线程？" class="headerlink" title="我们为什么需要线程？"></a>我们为什么需要线程？</h2><p>进程模型的抽象让我们不必再考虑CPU中断，时钟周期，上下文切换之类的底层内容，只要考虑并行进程即可。</p><p>但对于很多进程来说，他们还需要一种能够共享存储空间与数据的能力(例如word文档，他需要有定时保存，同时修改多页内容等功能)</p><p>而且使用线程后可以将某些阻塞的活动(IO)的时间用来进行其他功能，可增大CPU利用率。</p><p>而且线程相对于进程来说是一个更加轻量级的模型，更容易被创建、结束。</p><p>典型的例子就是word、web服务器…</p><hr><p>在没有多线程的情况下，我们通过有限状态机这样的设计实现Web服务器</p><p>即使用非阻塞版本的系统调用来进行IO，再有需求进来时，会进行新工作。</p><p>在这种设计中，“顺序进程”模型消失了，但进程每次切换工作时都要将先前内容进行存储。</p><p>可以认为我们模拟了线程及其堆栈。</p><table><thead><tr><th align="center">模型</th><th align="center">特性</th></tr></thead><tbody><tr><td align="center">多线程</td><td align="center">并行、阻塞系统调用</td></tr><tr><td align="center">单线程进程</td><td align="center">无并行性、阻塞系统调用</td></tr><tr><td align="center">有限状态机</td><td align="center">并行性、非阻塞系统调用、中断</td></tr></tbody></table><h2 id="经典线程、POSIX线程"><a href="#经典线程、POSIX线程" class="headerlink" title="经典线程、POSIX线程"></a>经典线程、POSIX线程</h2><img src="/2020/11/14/Operating%E2%80%94-System/传统线程.png" alt="传统线程" style="zoom: 67%;"><p>在图a中可以看到三个传统的进程，每个进程有自己的地址空间和一个控制线程。</p><p>图b中可以看到一个进程拥有三个控制线程，且运行在同一地址空间。</p><p>在多线程进程中，所有线程都共享完全一样的地址空间，也就是共享同样的全局变量，且线程之间是不存在保护的。</p> <img src="/2020/11/14/Operating%E2%80%94-System/进线程内容.png" style="zoom:67%;"><p>上图给出了进线程中所包含的内容。</p><p>有了线程的概念后，<strong>可以把进程当作资源管理的单位，线程当做执行的单位</strong>。</p><hr><p><strong>每个线程都有自己的堆栈</strong></p><p>假设有下面这样的情况：过程X调用Y，Y调用Z，当Z执行时，XYZ使用的栈帧都会存在堆栈中。而每个线程往往会执行不同的过程，这就让他们有各自不同的历史，也就是每个线程都要有自己的堆栈。</p><p><em>线程也可以创造线程，且线程间一般不会存在父子关系</em></p><hr><p><strong>POSIX线程</strong></p><p><a href="https://blog.csdn.net/dreams_deng/article/details/104201715">POSIX提供了很多系统调用来实现线程</a></p><p> 通过一个求PI的程序来说明。    </p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pthread.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><span class="hljs-keyword">double</span> PI;<span class="hljs-keyword">long</span> num_thread;<span class="hljs-keyword">long</span> N;<span class="hljs-keyword">double</span> tim;<span class="hljs-keyword">pthread_t</span>* threads;<span class="hljs-keyword">pthread_mutex_t</span> lock;<span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* ID)</span></span><span class="hljs-function"></span>&#123;      <span class="hljs-keyword">long</span> id=(<span class="hljs-keyword">long</span>)ID;<span class="hljs-keyword">int</span> length=N/num_thread;<span class="hljs-keyword">int</span> i;pthread_mutex_lock(&amp;lock);<span class="hljs-keyword">for</span>(i=id*length;i&lt;(id+<span class="hljs-number">1</span>)*length;i++)&#123;PI+=(<span class="hljs-number">4.0</span>/N)*(<span class="hljs-number">1.0</span>/(<span class="hljs-number">1</span>+((i+<span class="hljs-number">0.5</span>)/N)*((i+<span class="hljs-number">0.5</span>)/N)));&#125;pthread_mutex_unlock(&amp;lock);&#125;      <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Please input the num of threads\n&quot;</span>);<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%ld&quot;</span>,&amp;num_thread);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Please input the N of calculator\n&quot;</span>);<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%ld&quot;</span>,&amp;N);<span class="hljs-keyword">clock_t</span> start,<span class="hljs-built_in">end</span>;start=clock();threads=(<span class="hljs-keyword">pthread_t</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">pthread_t</span>)*num_thread);<span class="hljs-keyword">long</span> i;<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;num_thread;i++)&#123;        pthread_create(&amp;threads[i],<span class="hljs-literal">NULL</span>,thread,(<span class="hljs-keyword">void</span>*)i);&#125;<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;num_thread;i++)&#123;pthread_join(threads[i],<span class="hljs-literal">NULL</span>);&#125;<span class="hljs-built_in">end</span>=clock();tim=(<span class="hljs-keyword">double</span>)(<span class="hljs-built_in">end</span>-start)/CLOCKS_PER_SEC;<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Running Time: %fs\n&quot;</span>,tim);<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;PI= %.15f\n&quot;</span>,PI);        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;  </code></pre><h2 id="在用户-内核中实现线程"><a href="#在用户-内核中实现线程" class="headerlink" title="在用户/内核中实现线程"></a>在用户/内核中实现线程</h2><p><strong>1.在用户空间实现线程</strong></p><p>此时内核并没有线程的概念，他仍然只会对进程进行调度。此时线程的实现需要用户级程序去完成。</p><p>其实现大都使用pthread的系统调用。</p><p>同时，在用户空间管理线程时，每个进程也要有对应的线程表来记录进程中的线程。</p><p><strong>优点：</strong></p><p><strong>1.线程间切换很快</strong></p><p>当一个线程引发了自己的阻塞，那么他就会存储自己的状态，并在线程表中查看可运行的线程，将新线程的保存值重新装入机器的寄存器中。</p><p>因此，只要堆栈指针和程序计数器一被切换，新的线程就会自动运行。</p><p>这样的切换要比陷入内核来说更快。</p><p><strong>2.每个进程可以有自己的调度算法，且扩展性强</strong></p><p>可让用户程序自定义线程的运行状态。内核线程需要一些固定的表格空间和堆栈，如果内核线程数量很大就会出现问题。</p><hr><p><strong>缺点：</strong></p><p>1.如何实现阻塞系统调用</p><p>线程的目标是允许每个线程使用阻塞调用，且要避免被阻塞的线程影响其他线程。</p><p>2.starvation问题</p><p>如果一个线程开始运行，那么在该进程中的其他线程都无法运行。除非该线程主动放弃CPU。</p><p>由于在进程中不会有中断的概念，所以无法使用轮转调度的方法调度线程。</p><p>3.最大问题出现在本身</p><p>程序员通常会在经常发生线程阻塞的应用中才希望使用多线程。</p><p>但在一个服务器中，线程一直在进行着系统调用，如果原有线程阻塞，就很难让内核进行线程切换。否则就一直使用select系统调用。</p><p>但这样的话多线程的意义就不大了，并没有什么实质性的好处。</p><h1 id="调度程序-Important"><a href="#调度程序-Important" class="headerlink" title="调度程序(Important)"></a>调度程序(Important)</h1><p>在计算机中，如果有多个进程处于就绪状态，而只有一个CPU可用，那么OS就必须对下一个要运行的进程进行选择。完成这个工作的就是调度程序。</p><p>早期的批处理系统中的调度程序就是：顺序执行磁带上的每一个作业。由于那时CPU是稀缺资源，所以调度程序的作用十分重要。</p><p>但随着PC的普及以及CPU速度的快速增长，OS中多数时间只有一个活动进程，而且时间大多花费在等待用户输入，而非等待CPU计算。</p><p>但在Web服务器中，经常会有多个进程抢占CPU，此时的调度程序又十分重要。</p><p><strong>为什么要好的调度程序？</strong></p><p>因为进程切换的代价是十分高昂的：要先从用户态切换到内核态；保存进程状态；调度选择新进程；将新进程的内存印象装入MMU，开始运行。</p><p>如果调度程序每秒切换进程次数太多，会耗费大量CPU时间。</p><h2 id="何时调度进程？"><a href="#何时调度进程？" class="headerlink" title="何时调度进程？"></a>何时调度进程？</h2><p>1.在创建一个新进程后，需要决定是运行父进程还是子进程</p><p>2.在一个进程退出时必须调度</p><p>3.进程阻塞时必须调度</p><p>4.一个IO中断发生时必须调度</p><h2 id="调度算法分类及其目标"><a href="#调度算法分类及其目标" class="headerlink" title="调度算法分类及其目标"></a>调度算法分类及其目标</h2><p>对于所有系统，使用调度程序的目标都是要实现：公平(每个进程有公平的CPU份额)、策略强制执行(规定的策略被执行)、平衡(系统的所有部分都忙碌)</p><p>在不同系统中，需要的调度程序的类型、目标也不同，可划分为三组环境：</p><p>1.批处理(Batch System)</p><p>其目标要实现：吞吐量、周转时间、CPU利用率的最优。</p><p>2.交互式(Interactive System)</p><p>其目标为：实现响应时间、均衡性的最优。</p><p>3.实时(Real-time System)</p><p>其目标为：满足截止时间(避免丢失数据)、可预测性</p><h2 id="批处理系统中的调度-Important"><a href="#批处理系统中的调度-Important" class="headerlink" title="批处理系统中的调度(Important)"></a>批处理系统中的调度(Important)</h2><h3 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h3><p>按照进程请求CPU的顺序来使用CPU。类似于队列的FIFO机制，优点在于公平且思路简单。</p><p>但缺点也很明显：<strong>护航效应</strong>。</p><p>假如此时有一个CPU密集型和一个IO密集型的进程在就绪队列中，CPU密集型的进程在CPU中执行一段时间，进入IO；此时IO密集型进程进入CPU，执行很短很短的时间也进入IO；此时CPU空闲，CPU密集型进程再次进入就绪队列，IO进程又会等待CPU密集型进程完成。</p><p>可以看到，在这种情况下，IO进程总是在等待着计算密集型进程使用完CPU，从而导致运行时间很长。</p><p>如果有可能让IO进程直接单独抢占一段时间，那么运行时间会大大减少。</p><p><em>可通过下图理解进程执行的过程，并不是一直使用CPU然后一直使用IO就结束了，而是交错着的</em></p><img src="/2020/11/14/Operating%E2%80%94-System/密集型.png" style="zoom:50%;"><h3 id="最短作业优先"><a href="#最短作业优先" class="headerlink" title="最短作业优先"></a>最短作业优先</h3><p><em>由于需要知道运行时间，因此多用于专用OS，但可能出现starvation问题</em></p><h3 id="最短剩余时间优先"><a href="#最短剩余时间优先" class="headerlink" title="最短剩余时间优先"></a>最短剩余时间优先</h3><p><em>由于需要知道剩余运行时间，只能在专用OS使用</em></p><h3 id="高响应比优先"><a href="#高响应比优先" class="headerlink" title="高响应比优先"></a>高响应比优先</h3><p>响应比的计算:Response Radio = Turnaround time / Executing time = 1 + Waiting Time/ Executing Time</p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>在一单道批处理系统中，一组作业的提交时刻和运行时间如下表所示。试计算一下三种作业调度算法的平均周转时间 T 和平均带权周转时间 W。 (1) 先来先服务; (2) 短作业优先 (3) 高响应比优先。作业提交时刻和运行时间如下表</p><p><img src="/2020/11/14/Operating%E2%80%94-System/%E4%BE%8B%E9%A2%98.png" alt="例题"></p><p>1.先来先服务</p><p>根据题目可得到以下数据</p><table><thead><tr><th>作业</th><th>提交时刻</th><th>运行时间</th><th align="left">开始时间</th><th>完成时间</th><th>周转时间</th><th>带权周转时间</th></tr></thead><tbody><tr><td>1</td><td>8.0</td><td>1.0</td><td align="left">8.0</td><td>9.0</td><td>1.0</td><td>1.0</td></tr><tr><td>2</td><td>8.5</td><td>0.5</td><td align="left">9.0</td><td>9.5</td><td>1.0</td><td>2.0</td></tr><tr><td>3</td><td>9.0</td><td>0.2</td><td align="left">9.5</td><td>9.7</td><td>0.7</td><td>3.5</td></tr><tr><td>4</td><td>9.1</td><td>0.1</td><td align="left">9.7</td><td>9.8</td><td>0.7</td><td>7.0</td></tr></tbody></table><p>所以平均周转时间T=(1.0+1.0+0.7+0.7)/4=0.85</p><p>平均带权周转时间W=(1.0+2.0+3.5+7.0)/4=3.375</p><p>2.短作业优先</p><p>可知在8.0时系统中只有作业1，所以作业1仍为第一个执行的。</p><p>作业1执行完成时间为9.0</p><p>此时系统中有作业2,3两个作业，短作业优先选择作业3</p><p>作业3执行完成时间为9.2</p><p>此时系统中有作业2,4两个作业，短作业优先选择作业4</p><p>作业4执行完成时间为9.3</p><p>此时只有作业2</p><p>作业2执行完成时间为9.8</p><p>表格如下</p><table><thead><tr><th>作业</th><th>提交时刻</th><th>运行时间</th><th align="left">开始时间</th><th>完成时间</th><th>周转时间</th><th>带权周转时间</th></tr></thead><tbody><tr><td>1</td><td>8.0</td><td>1.0</td><td align="left">8.0</td><td>9.0</td><td>1.0</td><td>1.0</td></tr><tr><td>3</td><td>9.0</td><td>0.2</td><td align="left">9.0</td><td>9.2</td><td>0.2</td><td>1.0</td></tr><tr><td>4</td><td>9.1</td><td>0.1</td><td align="left">9.2</td><td>9.3</td><td>0.2</td><td>2.0</td></tr><tr><td>2</td><td>8.5</td><td>0.5</td><td align="left">9.3</td><td>9.8</td><td>1.3</td><td>2.6</td></tr></tbody></table><p>可以得到</p><p>平均周转时间T=(1+0.2+0.2+1.3)/4=0.675</p><p>平均带权周转时间W=(1.0+1.0+2.0+2.6)/4=1.65</p><p>3.高响应比优先</p><p>同样8.0时系统只有作业1，执行作业1</p><p>作业1执行完成时间为9.0</p><p>此时系统中有作业2,3</p><p>此时作业2 response radio=(1+0.5/0.5)=2; 作业3 response radio=1</p><p>所以先执行作业2</p><p>作业2执行完成时间为9.5</p><p>此时系统中有作业3,4</p><p>此时作业3的response radio=(1+0.5/0.2)=3.5</p><p>作业4的response radio =（1+0.4/0.1）=5</p><p>所以先执行作业4</p><p>作业4执行完时间为9.6</p><p>执行作业3</p><p>执行完成时间为9.8</p><p>可列为如下表格</p><table><thead><tr><th>作业</th><th>提交时刻</th><th>运行时间</th><th align="left">开始时间</th><th>完成时间</th><th>周转时间</th><th>带权周转时间</th></tr></thead><tbody><tr><td>1</td><td>8.0</td><td>1.0</td><td align="left">8.0</td><td>9.0</td><td>1.0</td><td>1.0</td></tr><tr><td>2</td><td>8.5</td><td>0.5</td><td align="left">9.0</td><td>9.5</td><td>1.0</td><td>2.0</td></tr><tr><td>4</td><td>9.1</td><td>0.1</td><td align="left">9.5</td><td>9.6</td><td>0.5</td><td>5.0</td></tr><tr><td>3</td><td>9.0</td><td>0.2</td><td align="left">9.6</td><td>9.8</td><td>0.8</td><td>4.0</td></tr></tbody></table><p>可知平均周转时间T=(1+1+0.5+0.8)/4=0.825</p><p>平均带权周转时间W=(1+2+5+4)/4=3</p><h3 id="区分一下带权周转时间和响应比的概念"><a href="#区分一下带权周转时间和响应比的概念" class="headerlink" title="区分一下带权周转时间和响应比的概念"></a>区分一下带权周转时间和响应比的概念</h3><p><strong>二者虽然看上去计算公式相同，但他们的性质是不同的</strong></p><p><strong>带权周转时间是在调度完成后评价该调度程序的一个指标，是静态的</strong></p><p><strong>而响应比是作为调度的一个条件来使用的，每当调度一次后，每个作业的响应比都会变化。是动态的。</strong></p><h2 id="交互式系统中的调度-Important"><a href="#交互式系统中的调度-Important" class="headerlink" title="交互式系统中的调度(Important)"></a>交互式系统中的调度(Important)</h2><h3 id="Round-robin-scheduling-轮转调度"><a href="#Round-robin-scheduling-轮转调度" class="headerlink" title="Round-robin scheduling (轮转调度)"></a>Round-robin scheduling (轮转调度)</h3><p>这是最简单、公平、使用最广的调度算法.</p><p>每个进程被分配一个<strong>时间片</strong>，即允许该进程在该时间段中运行。如果进程在时间片结束时还在运行，那就夺走CPU分配给下一个进程。如果进程在时间片结束前就完成或者阻塞，CPU就立即进行切换。</p><p>调度程序要做的就是维护一个可运行程序列表，并对使用完时间片的程序进行调整。</p><p><strong>唯一要考虑的就是时间片的长度</strong></p><p>时间片太短会导致进程切换过于频繁，降低CPU效率。太长又会引起对短的交互请求的不响应。</p><p>常将时间片设置在20~50ms之间</p><h3 id="Priority-scheduling-优先级调度"><a href="#Priority-scheduling-优先级调度" class="headerlink" title="Priority scheduling (优先级调度)"></a>Priority scheduling (优先级调度)</h3><p>在Round-robin中，我们把每个进程都看作同等重要，而优先级调度就是要改变这种想法，给每个进程赋予一个优先级，优先级高的进程会先运行。</p><p>为了防止高优先级进程一直运行下去，调度程序可能在每个时钟中断时降低其优先级，如果有高于其的进程，就开始调度。</p><p>也可以给每个进程设置一个允许允许的最大时间片，超过时间片后次高级进程就会运行。</p><img src="/2020/11/14/Operating%E2%80%94-System/优先级.png" style="zoom:67%;"><h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><h3 id="用户态线程"><a href="#用户态线程" class="headerlink" title="用户态线程"></a>用户态线程</h3><p>内核并不知道线程的存在，因此还是会直接对线程使用调度程序。</p><p>此时由进程中的线程调度程序来决定线程的运行。由于这里面并不存在时钟中断，所以线程可以按其意愿任意运行直到进程时间用完。</p><h3 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h3><p>此时内核选择特定的线程运行，且不用考虑线程属于哪个进程。可以分配时间…</p><p>&nbsp;</p><p>二者的差别主要在于性能。</p><p>用户级线程的切换只需要少量指令，但内核级线程切换需要上下文切换,修改内存，高速缓存…</p><p>但内核级线程如果阻塞，并不用直接将整个进程挂起。</p><p><em>另外，从A的线程切换到B的线程的代价高于在一个进程中切换线程，因此，在有多种选择的情况下，倾向于在相同进程中切换线程。</em></p><h1 id="竞争条件与信号量-Important"><a href="#竞争条件与信号量-Important" class="headerlink" title="竞争条件与信号量(Important)"></a>竞争条件与信号量(Important)</h1><p>竞争条件：多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序。且随着多核的增长，竞争条件变得越来越普遍。</p><p>其原因在于OS的调度进程不会，也不可能确保各个进程之间有确定的顺序。</p><p>因此，我们要做的就是避免竞争条件。其<strong>关键就是阻止多个进程同时读写共享的数据。</strong></p><p>我们把对共享内存进行访问的程序片段成为**临界区域(critical region/section)**。</p><p>&emsp;</p><p><strong>对于一个好的解决方法要满足4个条件：</strong></p><p><strong>1.任何两个进程不能同时在临界区中</strong></p><p>2.不对CPU的速度和数量做任何假设</p><p><strong>3.临界区外运行的进程不得阻塞其他进程</strong></p><p>4.不得使进程无限期等待进入临界区</p><p>&nbsp; </p><h2 id="忙等待-busy-waiting-的互斥"><a href="#忙等待-busy-waiting-的互斥" class="headerlink" title="忙等待(busy waiting)的互斥"></a>忙等待(busy waiting)的互斥</h2><h3 id="一、屏蔽中断"><a href="#一、屏蔽中断" class="headerlink" title="一、屏蔽中断"></a>一、屏蔽中断</h3><p>对于单处理器来说，在进程进入临界区后立即屏蔽所有中断，在离开前打开中断是最直接的方法。屏蔽中断后，时钟中断也被屏蔽——CPU就不会切换到其他进程。</p><p>其缺点在于给了用户程序太大的权力。屏蔽中断对于OS来说很好，但对用户程序却不太合适。</p><p>且由于多核的普及，其他CPU也是可以访问共享内存的。</p><h3 id="二、锁变量"><a href="#二、锁变量" class="headerlink" title="二、锁变量"></a>二、锁变量</h3><p>一种软件解决方法。设置一个共享锁变量，进入临界区前要先开锁才能进入。</p><p>但由于调度的不确定性，如果一个进程在读锁变量为0后，在准备将其设置为1之前被调度，另一个程序将其设置为1，进入临界区。此时再返回，第一个进程将锁变量设为1，也进入临界区。此时临界区中有两个程序。</p><h3 id="三、严格轮换法"><a href="#三、严格轮换法" class="headerlink" title="三、严格轮换法"></a>三、严格轮换法</h3><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> turn=<span class="hljs-number">0</span>;<span class="hljs-comment">/*进程 0*/</span><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;    <span class="hljs-keyword">while</span>(turn!=<span class="hljs-number">0</span>)    critical_region();    turn=<span class="hljs-number">1</span>;    noncritical_region();&#125;<span class="hljs-comment">/*进程 1*/</span><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;    <span class="hljs-keyword">while</span>(turn!=<span class="hljs-number">1</span>)    critical_region();    turn=<span class="hljs-number">0</span>;    noncritical_region();&#125;</code></pre><p><em>功能描述：</em> 进程0首先检查turn为0，进入临界区；进程1检查turn为0，执行循环一直检查turn直至为1.</p><p>连续测试一个变量直到某个值出现称为<strong>忙等待(Busy waiting)</strong> ——浪费CPU时间，上述锁称为自旋锁。</p><p><em>但这种解法也是存在问题的</em></p><p>假如进程0结束临界区操作，将turn设置为1,。进程0迅速完成非临界区操作，而进程1正在忙于非临界区操作。此时进程0无法进入临界区(turn==1),进程1也不进入临界区。<strong>说明在一个进程比另一个慢得多的情况下，该解法并不太好。</strong></p><p><strong>违背前述条件3，进程0被在临界区外的进程1阻塞无法进入临界区。</strong></p><h3 id="四、Peterson解法-针对两个进程"><a href="#四、Peterson解法-针对两个进程" class="headerlink" title="四、Peterson解法   (针对两个进程)"></a>四、Peterson解法   (针对两个进程)</h3><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FALSE 0</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TRUE 1</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 2 <span class="hljs-comment">//进程数量</span></span><span class="hljs-keyword">int</span> turn; <span class="hljs-comment">//轮到谁？</span><span class="hljs-keyword">int</span> interested[N]=&#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">//所有值初始化为0</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enter_region</span><span class="hljs-params">(<span class="hljs-keyword">int</span> process<span class="hljs-comment">/*进程是0或1*/</span>)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> other;    <span class="hljs-comment">/*另一进程号*/</span>    other=<span class="hljs-number">1</span>-process;    interested[process]=TRUE;<span class="hljs-comment">/*表示感兴趣*/</span>    turn = process;<span class="hljs-comment">/*设置标志*/</span>    <span class="hljs-keyword">while</span>(turn=process&amp;&amp;interested[other]==TRUE); <span class="hljs-comment">/*空语句*/</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">leave_region</span><span class="hljs-params">(<span class="hljs-keyword">int</span> process)</span> <span class="hljs-comment">/*离开的进程*/</span></span><span class="hljs-function"></span>&#123;    interested[process]=FALSE;<span class="hljs-comment">/*离开临界区*/</span>&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Operating System</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大学？人生？</title>
    <link href="/2020/11/13/%E6%9C%88%E5%A4%9C%E6%9D%82%E8%B0%88/"/>
    <url>/2020/11/13/%E6%9C%88%E5%A4%9C%E6%9D%82%E8%B0%88/</url>
    
    <content type="html"><![CDATA[<p>最近看到诺奖得主塞门扎学术问题的新闻，不禁又对这个问题产生思考。</p><a id="more"></a><p>上大学！</p><p>上大学是为了什么？</p><p>最近看到诺奖得主塞门扎学术问题的新闻，不禁又对这个问题产生思考。</p><p>学术巨擘也会为了名利造假，这对我的梦想给了沉重的一拳。</p><p>&emsp;</p><p>回顾鄙人的姑且算作一年半的大学时光，很可悲的是，我竟然没有感觉到她与高中有什么明显的不同。</p><p>GPA和加权仿佛成为了我唯一追逐的东西，我记得我刚进校园的时候不是这个样子啊！？</p><p>记得大一上学期，中美贸易战刚刚开打，我当初立志于投身计算机底层，为祖国的薄弱之处补上一环。但到这次选专业的时候，我觉得我的目标似乎…变了一些，这次选专业，我首先想到的是这个专业好不好保研，卷不卷。</p><p>大一的我还会抽时间读杂书，学一些文史哲，读一些马哲。但大二的这半个学期，我感觉我只是一个学习的机器。</p><p>整天忙来忙去却没有找到目的，总感觉自己有一部分被抽掉了。</p><p>仿佛刚入校门的那个我已经被我忘掉了。</p><p>虽然最后还是选了计科，以后想向底层进军，但我真的真的真的不确定自己能否抗住现实的重击。</p><p>&emsp;</p><p>现在社会和校园的感觉对我来说就是——浮躁。</p><p>一个追名逐利的社会已经将象牙塔中的师生拉入了社会这个大染缸。</p><p>很多人为了就业拼命往CS中跳，有人混到毕业只为找个工作，有人委屈读研只为职业生涯…</p><p>这么多人都只为小家，这样真的好吗？</p><p>我并不是质疑人，而是在质疑这个时代，这个时代是最好的，也是最坏的…</p><p>&emsp;</p><p>现在的我知道底层工资待遇不会很好，但我想去，我感兴趣，我有理想有目标。</p><p>但我真的能接受同届毕业生三倍于我的工资吗？我真的能抗住物质生活压力而坚持自己的理想吗？我真的能守护住自己心中的那个白月光吗？</p><p>我不知道，我也不想知道。</p><p>&emsp;</p><p>在我的遗愿清单里我写到，我想为祖国做贡献，我想和马克思有灵魂的接触。</p><p>我不想让这个遗愿清单变成一个失望清单。</p><p>我更不想在大四的时候回顾我的本科阶段，感觉到这不是我，或者感觉到这就是我。</p><p>&emsp;</p><p>这时候想起来三问桥上的那三问</p><p>“懂吗？会吗？敢吗？”</p><p>我现在的答案是：不懂，不会，不敢。</p><p>希望两年后的我，可以更好地回答这三个问题吧…</p><p>单向的人生没有返回的机会，</p><p>但我这个无知的婴儿却在无畏地向前走，</p><p>我想停，却愈发觉得步伐变快，</p><p>我想跑，却总是止步不前，</p><p>我想知道向前会遇到什么，</p><p>那条未知的路给我的只有漆黑的沥青，</p><p>一天，我突然回头，</p><p>我走过的路上既有明媚的阳光，</p><p>也有灰色的乌云，</p><p>我环顾四周，</p><p>目光不由得再次被那漆黑的路而吸引，</p><p>那，是我未知的颜色。</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Life</tag>
      
      <tag>Thinking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NEMU</title>
    <link href="/2020/11/10/NEMU/"/>
    <url>/2020/11/10/NEMU/</url>
    
    <content type="html"><![CDATA[<p>Record my programming process and give others some inspirations.</p><a id="more"></a><p>You can find source code from <a href="https://github.com/Feng-Jay/NEMU">My github repo</a></p><p>/* But please do not just ctrl+c and ctrl+v */</p><p>And here is a very useful manual <a href="https://nju-ics.gitbooks.io/ics2015-programming-assignment/content/PA0.html">NEMU_gitbook</a></p><h1 id="PA2"><a href="#PA2" class="headerlink" title="PA2"></a>PA2</h1><p>PA2要求我们在NEMU中实现部分X86指令集中的内容。</p><p>如果是第一次真正接触底层指令编写的话，一开始肯定是很茫然和无措的。(切身体会)</p><p>但别灰心，CS就是这样，只有不会才能提升嘛。那么就….开始！</p><h2 id="三个关键宏"><a href="#三个关键宏" class="headerlink" title="三个关键宏"></a>三个关键宏</h2><p>阅读指导书，会发现这样三个宏定义在实现新指令时都会被用到。</p><pre><code class="hljs c"><span class="hljs-string">&quot;nemu/include/cpu/helper.h&quot;</span><span class="hljs-comment">/* All function defined with &#x27;make_helper&#x27; return the length of the operation. */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> make_helper(name) int name(swaddr_t eip)</span><span class="hljs-string">&quot;nemu/include/cpu/exec/helper.h&quot;</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> make_helper_v(name) </span>make_helper(concat(name, _v)) &#123; <span class="hljs-keyword">return</span> (ops_decoded.is_operand_size_16 ? concat(name, _w) : concat(name, _l)) (eip); \&#125;<span class="hljs-string">&quot;nemu/include/cpu/exec/helper.h&quot;</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> make_instr_helper(type) </span>make_helper(concat5(instr, _, type, _, SUFFIX)) &#123; <span class="hljs-keyword">return</span> idex(eip, concat4(decode_, type, _, SUFFIX), do_execute); &#125;</code></pre><p>这三个宏定义很巧妙地使用了函数指针和宏定义的配合。<a href="https://blog.csdn.net/Zz_1996/article/details/78758627">感兴趣可以了解一下</a></p><p><strong>其中，make_helper函数的功能是声明一个函数，并且返回操作的长度</strong></p><p>可以通过阅读代码知道，make_helper函数每次都要传入一个参数eip，返回一个int值。</p><p>&emsp;</p><p><strong>make_helper_v函数的作用是用来确定一个函数的后缀</strong></p><p>16位指令的话就+w(word,16bits)，否则就+l(long word, 32bits);</p><p>&emsp;</p><p><strong>make_instr_helper函数的作用就是确定函数的形式，并且进行译码、执行</strong></p><p>其中 <code>type</code> 为指令的形式, 通过调用 <code>idex()</code> 函数来进行执行的译码和执行。</p><p>&emsp;</p><p>如果看不太懂没关系，下面来一个实例</p><p><strong>mov_i2r_b指令的实现</strong></p><pre><code class="hljs c"><span class="hljs-string">&quot;nemu/src/cpu/exec/date-mov/mov.h&quot;</span>make_helper(mov_i2r_b);<span class="hljs-string">&quot;nemu/src/cpu/exec/date-mov/mov.c &quot;</span>make_helper_v(mov_i2r)    <span class="hljs-string">&quot;nemu/src/cpu/exec/date-mov/mov-template.h&quot;</span>make_instr_helper(i2r)    <span class="hljs-comment">/*ignored the do_execute part*/</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>Operating System</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dynamic Programming</title>
    <link href="/2020/11/07/Dynamic-Programming/"/>
    <url>/2020/11/07/Dynamic-Programming/</url>
    
    <content type="html"><![CDATA[<p>Share and review my study process.</p><a id="more"></a><h1 id="引论"><a href="#引论" class="headerlink" title="引论"></a>引论</h1><p><strong>个人理解动态规划应该是一种设计技巧，和分治法类似，但DP更关心子问题的重叠。</strong></p><p>动态规划是一种在各个不同大小(size)的子问题的优化值之间建立递归关系并求解的过程.</p><p>能使用动态规划求解的问题必须<strong>满足优化原理：</strong></p><p><strong>优化解包含的子问题的解也是最优的</strong></p><p>即可利用优化原理，使用枚举法建立不同长度子问题优化值之间的递归关系—动态规划方程。</p><p><em>注意，动态规划算法得出的解为精确解，子问题的数目决定了该算法的复杂度.</em></p><p><em>Ps: 尽量不要用递归</em></p><h1 id="经典的0-1背包"><a href="#经典的0-1背包" class="headerlink" title="经典的0/1背包"></a>经典的0/1背包</h1><p><strong>给定 n 种物品和一个容量为 C 的背包，物品 i 的重量是 wi，其价值为 vi 。</strong></p><p><strong>问：应该如何选择装入背包的物品，使得装入背包中的物品的总价值最大？</strong></p><p>&emsp; </p><p>在学习DP算法之前，我们面对01背包问题有的思路就是贪心和穷举：</p><p>不管是对价值排序还是对价值密度排序，只是改变了贪心策略，但还是贪心算法，也就意味着我们只能求解一个近似解，无法得到精确解。</p><p>而穷举法的开销太大了，在很多情况下复杂且不适用。</p><p><strong>既然贪心法在理论上是无法得到精确解的，那我们能否在穷举的基础上进行优化呢？</strong></p><h2 id="来一个具体的例子"><a href="#来一个具体的例子" class="headerlink" title="来一个具体的例子"></a><strong>来一个具体的例子</strong></h2><p>n=5,c=10,w=[2,2,6,5,4],p=[6,3,5,4,6]. </p><p>可知此时的优化解为(1,1,0,0,1),即装1,2,5物品</p><p>想要用DP算法，首先要判断<strong>问题是否满足优化原理</strong></p><p>即优化解包含的子问题的解是否最优。</p><blockquote><p>当我们先装物品1时。</p><p>物品1装入，子问题为n=4,c’=c-2(物品1的重量),物品为2,3,4,5</p><p>可以看到子问题的优化解为(1,0,0,1)</p><p>与优化解相同</p></blockquote><p>可以得知<strong>01背包问题满足优化原理</strong>。</p><h2 id="DP的思路分析"><a href="#DP的思路分析" class="headerlink" title="DP的思路分析"></a>DP的思路分析</h2><p>面对n个物品，我们并不知道该拿哪几个才是最优解，那么就使用计算机最擅长的技能：计算(遍历)</p><p>只不过我们会对遍历进行一些操作</p><p>设函数 f(i,y)表示当背包容量为y时，面对 i，i+1,…，n物品时的最优解。</p><p>可以知道f(1,c)就是我们最终要求的答案</p><p>求 f(1,c)遇到的第一个问题就是物品1拿不拿？</p><p>答案是：不知道。&emsp; 但我们可以根据子问题推出来物品1拿不拿。</p><p><strong>f(1,c)=max{f(2,c), f(2,c-w1)+p1}</strong></p><p>这样我们的思路就出来了：建立一个父问题与子问题递归式。即在最后一个物品时返回两种情况：拿或不拿。再一路返回到第一种情况，判断物品1拿不拿。</p><p>下面是递归算法和非递归算法</p><h2 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h2><pre><code class="hljs cpp"><span class="hljs-comment">//递归算法</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> content;<span class="hljs-keyword">int</span> num_things;<span class="hljs-keyword">int</span> weightt[<span class="hljs-number">101</span>];<span class="hljs-keyword">int</span> value[<span class="hljs-number">101</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> thing,<span class="hljs-keyword">int</span> content)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> dp1=<span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> dp2;    <span class="hljs-keyword">if</span>(thing==num_things<span class="hljs-number">-1</span>)    &#123;        <span class="hljs-keyword">if</span>(content&lt;weightt[num_things<span class="hljs-number">-1</span>])        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-keyword">return</span> value[num_things<span class="hljs-number">-1</span>];        &#125;            &#125;    <span class="hljs-keyword">if</span>(content&gt;=weightt[thing])    dp1=dp(thing+<span class="hljs-number">1</span>,content-weightt[thing])+value[thing];    dp2=dp(thing+<span class="hljs-number">1</span>,content);    <span class="hljs-keyword">return</span> max(dp1,dp2);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cin</span>&gt;&gt;content&gt;&gt;num_things;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;num_things;i++)    <span class="hljs-built_in">cin</span>&gt;&gt;weightt[i];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;num_things;i++)    <span class="hljs-built_in">cin</span>&gt;&gt;value[i];    <span class="hljs-built_in">cout</span>&lt;&lt;dp(<span class="hljs-number">0</span>,content)&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>由于递归算法开销很大，所以我们使用元组法来实现DP</p><h2 id="元组法"><a href="#元组法" class="headerlink" title="元组法"></a>元组法</h2><p>仔细回想我们的01背包问题，是否有这样一个感觉，效益值=f(i,y)是一个分段函数，且每一段都是效益值不变的水平直线。</p><p>那么我们只要记住分段函数的跳跃点，是否就可以对输入的每种情况进行还原(和数据结构中稀疏矩阵的存储相似)</p><p>&emsp;</p><p>由于f(i, y)=max{ f(i+1,y),f(i+1,y-w<del>i</del>)+p<del>i</del> }</p><p>设f(i,y)对应元组P(i), f(i+1,y-w<del>i</del>)+p<del>i</del>对应元组Q</p><p>我们想要得到的是P(i)，所以我们需要求P(i+1)和Q。</p><p>由于f(i+1,y-w<del>i</del>)+p<del>i</del>可看作f(i+1,y)向右向上平移，所以P中每个元组(a,b)对应Q中的(a+wi,b+pi)</p><p>&emsp; </p><p>求出P(i+1)和Q后，使用类似于merge排序的方法把两个元组中的点合并</p><p><strong>合并规则：</strong></p><p><strong>合并时使用以下支配(选优)规则:</strong></p><p><strong>设(a,b)和(u,v)是来自P(i+1)和Q的元组,若a≥u且b＜v,则称(a,b)受(u,v) 支配. 因为</strong></p><p><strong>(a,b)代表以容量a得到效益值b的方案,</strong></p><p><strong>而(u,v)代表以较少的容量u得到较大效益值v的装包方案.</strong></p><p>(可以想象为两个分段函数一直取x相等时二者y值最大的一段)</p><p>&emsp;</p><p><strong>得到P(2)后我们可以不求P(1)</strong></p><p>直接利用w<del>1</del>和P(2)来求出满足w<del>1</del>+w&lt;C的最后一个元组（w,v）</p><p>将v+p<del>1</del>与原来P(2)中最后一个满足条件的效益值比较，取最大的那个。 </p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>人这一辈子，最不能透支的是什么？</title>
    <link href="/2020/11/03/%E5%85%B1%E5%8B%89/"/>
    <url>/2020/11/03/%E5%85%B1%E5%8B%89/</url>
    
    <content type="html"><![CDATA[<p>午觉起来看到知乎一个高赞回答，分享一下，与君共勉。</p><a id="more"></a><p>作者：简在我心<br>链接：<a href="https://www.zhihu.com/question/422796779/answer/1556486657">知乎链接</a><br>来源：知乎</p><p>生命力。</p><p>今天上午给学生讲解电影《死亡诗社》，对这个问题正好深有感触。</p><p>这个影片里，反复提到一些词：热情，激情，爱，浪漫，强有力，奋斗，寻觅，发现，呐喊……</p><p>人类这个物种有个很大的优势就是对新鲜事物的好奇性。</p><p>我们喜欢探奇历险，喜欢学习研究。但是这种行为具有风险。</p><p>所以长辈或管理者为了安全需要和管理方便，会制定各种规则，把那个内心里生动活泼的小人儿关进牢笼里。</p><p>不让你玩水，不让你玩火，不让你爬树，不让你恋爱，不让你问为什么，不让你做这个做那个。</p><p>美其名曰：为你好。</p><p>然后你的生命力就会在种种禁锢中持续性流失和透支。</p><p>你变得对生活失去了热情，对世界失去了探索的欲望，你没有了学习的兴趣，没有了爱的能力……</p><p>失去生命力的表现：</p><p>你刷着抖音，停不下来，哪怕已经厌倦，也还是忍不住继续滑动手指。</p><p>你躺在床上，睡到头疼，浑身无力，不想再躺下去了，却依然缺乏起床的动力。</p><p>你玩着游戏，玩到疲惫不堪，但依然百无聊赖地点着鼠标，两眼无光。</p><p>你频繁和五姑娘交谈，谈到昏昏沉沉，依然不想松开她。</p><p>你失去了对自己的生命的强有力的感觉。</p><p>你沦丧于无聊的重复的形式中，无力自拔。</p><p>失去了生命的热情和希望。</p><p>失去了对于自我身体的掌控。</p><p>失去了对事物的感知能力。</p><p>你疲惫，疲软，无力，无感，靠反复的刺激来提醒自己好像还活着。</p><p>我认为这就是生命力透支的表现，是最糟糕的生活状态，没有之一。</p><p>我为什么感受那么深？</p><p>最近跟学生交流，发现他们很多人都已经处于这种生命力透支的状态。</p><p>你问他还有什么理想、希望或想做的事情。好像没有，或即便有也是缺乏可持续性。</p><p>所以他们只能浑浑噩噩地混日子。</p><p>为什么那么多人抑郁、自杀或躺平？</p><p>因为他们的生命力已经透支了，枯竭了，对生活已经没有了热情，没有了希望，也没有了信心。</p><p>才不到二十岁的年纪，就失去了狂野、野心、激情、欲望。</p><p>这是一个多么令人痛心的事实。</p><p>所以别说什么成才，就是过好自己平凡一生都很难了。</p><p>这将是一个个了无生趣的生命。</p><p>这就是不重视人文教育的后果。</p><p>生命需要呵护，需要个性的张扬和奔放，需要自由的空气，才能健康成长，才能抵御现实的风霜雪剑。</p><p>可是我们以爱的名义，剥夺了孩子们的生命力，使得他们还没绽放，就已经枯萎了。</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Life</tag>
      
      <tag>Thinking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>贪心算法&amp;&amp;优化问题</title>
    <link href="/2020/10/11/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    <url>/2020/10/11/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>Record key point  And  write code for some problems.</p><a id="more"></a><h1 id="优化问题"><a href="#优化问题" class="headerlink" title="优化问题"></a>优化问题</h1><h2 id="优化问题的概念"><a href="#优化问题的概念" class="headerlink" title="优化问题的概念"></a>优化问题的概念</h2><p>即通过一定条件约束，对一组变量进行操作，使目标到达最优值。</p><h2 id="优化问题的一般描述"><a href="#优化问题的一般描述" class="headerlink" title="优化问题的一般描述"></a>优化问题的一般描述</h2><p><strong>优化问题的描述：</strong></p><p><strong>1.问题的解为一复杂结构 (x1,x2,…,xn) xi∈Si（可选的方式）</strong></p><p><strong>2.约束条件：B(x1,x2…,xn)，使B为true的元组称为可行解</strong></p><p><strong>3.目标函数f(x1,…,xn)</strong> </p><p><strong>优化解即指使目标函数取得最值的可行解，对应的目标函数值称为优化值</strong></p><p><strong>贪心算法是求近似解的一种主要途径。</strong></p><h1 id="贪心算法的思想及要点"><a href="#贪心算法的思想及要点" class="headerlink" title="贪心算法的思想及要点"></a>贪心算法的思想及要点</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>&emsp;&emsp;贪心算法是一种多步求解的方法，每步按一种局部最优的策略选择解的一个分量，算法以第n步结束时构造出问题的解。他也是一种寻找最优解的方法，即在使用时要把整个问题分解为若干步，在每一步中都会选择当前最优的解法，然后将每一步的解合并成为整个问题的最终解。</p><p>&emsp;&emsp;该算法问题在于：因为其的<strong>贪婪的短视</strong>导致在很多情况下都会错过最优解，因为贪心算法不会从整体上对问题进行思考，只会闷头于当前情况。所以贪心算法不能用来求最大最小值、无法保证最后的解是最优的、只能求某些特定的解。</p><p>&emsp;&emsp;所以实际上可以用贪心算法求得最优解的情况很少，所以我们要证明每一步所作的贪心选择最终能导出问题最优解（举几组数据即可）。</p><p>&emsp;&emsp;听起来贪心算法似乎很复杂，但他其实并没有太多的技巧。唯一的考验就<strong>在于制定你的贪心策略(主要是要有这个思想)</strong> 让你的算法 <strong>真正的只关心当下，不去关心后续情况或者先前情况</strong>。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>不回溯</li><li>局部优化策略可以减小开销，但不保证得到精确优化解</li><li>不同贪心策略得到不同算法</li><li>常使用使目标函数有最大增量的策略为贪心策略</li></ol><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>下面我们来看一个很简单的例题</p><blockquote><p><strong>例 Loading Problem</strong></p><p><strong>设有n个集装箱,集装箱大小一样，第i个设有n个集装箱,集装箱大小一样，第i个集装箱的重量为wi(1≤i≤n),设船的载重量为c.试设计一装船的方法使得装入的集装箱数目最多</strong></p></blockquote><p>&emsp;</p><p>这是一道很基础的贪心算法题目，我们先按照<strong>优化问题的格式</strong>来描述一下他：</p><p><strong>令问题的解为(x1,x2,…,xn) &nbsp;xi={0,1}//代表第i个箱子是否装载。</strong></p><p><strong>问题的约束条件是Σi=1,n wixi&lt;=c; //装载箱子的总重量小于等于C</strong> </p><p><strong>目标函数为 Σi=1,n xi； //装载的集装箱个数</strong></p><p><strong>我们的目标是极大化目标函数。</strong></p><p>因为目标函数是所装的集装箱数目，所以按照我们的常规思想，那么一定先装重量轻的集装箱。</p><p>所以可以写出代码如下</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> n,c;<span class="hljs-keyword">int</span> weight[<span class="hljs-number">100</span>]=&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">int</span> countt=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> tem_weight=<span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cin</span>&gt;&gt;n;    <span class="hljs-built_in">cin</span>&gt;&gt;c;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)    <span class="hljs-built_in">cin</span>&gt;&gt;weight[i];    sort(weight,weight+n);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)    &#123;        <span class="hljs-keyword">if</span>(tem_weight+weight[i]&lt;=c)        &#123;            tem_weight+=weight[i];            countt++;        &#125;        <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">break</span>;&#125;    &#125;    <span class="hljs-built_in">cout</span>&lt;&lt;countt&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>这时你可能对这种贪心策略存疑，先装载重量低的箱子一定能得到最优解吗？</p><p>下面给出证明</p><p><u>证明:</u></p><p><u>设问题最优解为(y1,y2,…,yn)</u></p><p><u> </u></p><p><u>如最优解不含箱子1，将箱子1替换优化解中某一个箱子得到一个新的解</u></p><p><u>1.替换是必须的：若1还能装入船中，则(y1,y2,…,yn)不是优化的</u></p><p><u>2.因为1是最轻的，所以替换后的解仍是可行的</u></p><p><u>3.替换后的解装入的箱子数==优化的箱子数，它仍是优化解</u></p><p><u>4.替换后新的优化解和贪心解都有箱子1</u></p><p><u> </u></p><p><u>反复替换得到一个优化解，优化解==贪心解</u></p><p><u>替换次数是有穷的。</u></p><p>这就确定了在这道题目里，我们的贪心解一定是优化解。</p><p><strong>针对这个问题也引出一点：贪心解虽然在一种策略下只有一个，但问题的真正最优解可能有多个。</strong>   </p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日洛谷_9.28</title>
    <link href="/2020/09/28/%E6%AF%8F%E6%97%A5%E6%B4%9B%E8%B0%B7-9-28/"/>
    <url>/2020/09/28/%E6%AF%8F%E6%97%A5%E6%B4%9B%E8%B0%B7-9-28/</url>
    
    <content type="html"><![CDATA[<p>今天刷洛谷基础题看到一个很好的题，分享一下。</p><a id="more"></a><p>​    <a href="https://www.luogu.com.cn/problem/P2181">原题链接</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>对于一个 n 个顶点的凸多边形，它的任何三条对角线都不会交于一点。请求出图形中对角线交点的个数。</p><p>例如，6 边形：</p><img src="/2020/09/28/%E6%AF%8F%E6%97%A5%E6%B4%9B%E8%B0%B7-9-28/6023.png" style="zoom: 80%;"><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入只有一行一个整数 nnn，代表边数。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行一个整数代表答案。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入 #1 &nbsp;&emsp;输入#2</p><blockquote><p>3 &nbsp; &emsp;&nbsp;      6</p></blockquote><p>输出#2 &nbsp; &emsp; 输入#2</p><blockquote><p>0 &nbsp; &emsp;      &nbsp;15</p></blockquote><h2 id="说明与提示"><a href="#说明与提示" class="headerlink" title="说明与提示"></a>说明与提示</h2><ul><li>对于 50%50 %50% 的数据，保证 3≤n≤100。</li><li>对于 100%100 %100% 的数据，保证 3≤n≤10^5。</li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先看题目中一句<strong>任何三条对角线都不会交于一点</strong>，所以给定<strong>一个交点，可以确定两条对角线——也就意味着确定了四个角</strong></p><p>所以这道题就变成了一个排列问题</p><p>即求Cn4的组合数问题 ：就是求 n * (n-1) * (n-2) * (n-3) /24</p><p>这时大家可能会想&nbsp;”啊，这个题目这么简单，怎么会有人拿他出来写博客！”</p><p>所以你就写出了下面的代码</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> n;<span class="hljs-keyword">int</span> outcome;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cin</span>&gt;&gt;n;    outcome=n*(n<span class="hljs-number">-1</span>)*(n<span class="hljs-number">-2</span>)*(n<span class="hljs-number">-3</span>)/<span class="hljs-number">24</span>;    <span class="hljs-built_in">cout</span>&lt;&lt;outcome&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>结果</p><p><img src="/2020/09/28/%E6%AF%8F%E6%97%A5%E6%B4%9B%E8%B0%B7-9-28/%E7%BB%93%E6%9E%9C.png" alt="结果"></p><p><strong>再仔细阅读下题目，你会发现这道题会爆数据的…</strong></p><p><strong>所以你把int 全部换成了long long 或者unsigned long long ，并沾沾自喜，这么简单不会真有人拿出来写博客吧！</strong></p><p>结果你又发现出现了两个WA…（手动狗头）</p><p>这时你想到，我可以写高精求组合数啊</p><p><em>这无疑是一种很好的解题方法，但对于这样一道入门题来说，未免太…</em></p><p><strong>所以给出了一个很妙的写法</strong></p><p>那就是把 n * (n-1) * (n-2) * (n-3) /24写成 n * (n-1)/2 *(n-2) /3 *(n-3)/4</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> outcome;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cin</span>&gt;&gt;n;    outcome=n*(n<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>*(n<span class="hljs-number">-2</span>)/<span class="hljs-number">3</span>*(n<span class="hljs-number">-3</span>)/<span class="hljs-number">4</span>;    <span class="hljs-built_in">cout</span>&lt;&lt;outcome&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;</code></pre><p>现在来分析一下为什么这样写是对的。</p><p>首先n * (n-1)中一定有一个是2的倍数，所以可以被2整除</p><p>n * (n-1) *(n-2)中一定有一个是3的倍数，所以可以被3整除</p><p>n * (n-1) * (n-2) * (n-3) 中一定有一个是4的倍数，所以可以被4整除</p><p>emmmmmmmmmmm，就差不多是这样了</p><p>溜了溜了，上课去。</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>欧几里得算法</title>
    <link href="/2020/09/22/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/"/>
    <url>/2020/09/22/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>昨天上算法课听到了这个算法，突发兴趣来写一篇blog。</p><a id="more"></a><h1 id="欧几里得算法的用处"><a href="#欧几里得算法的用处" class="headerlink" title="欧几里得算法的用处"></a>欧几里得算法的用处</h1><p>欧几里得算法也称为辗转相除法，是求解最大公约数的一种方法。</p><p>若有两个数a和b，求a和b的最大公约数，按照我们之前所学的东西，可能只会枚举a与b的因子，效率很低…</p><p>但欧几里得为我们提供了一个十分便捷的方法。</p><h1 id="一个强大的定理"><a href="#一个强大的定理" class="headerlink" title="一个强大的定理"></a>一个强大的定理</h1><p><strong>gcd(a,b) = gcd(b, a%b)</strong></p><p>下面给出证明</p><pre><code class="hljs cpp">设a与b的公约数为 k ，a=bx+y;则 k|a 且 k|b ，有 a%b=y又有y=a-bx, 所以 k|y。即 k|a%b再假设b 与 a%b的公约数为kk，得 kk|a，所以(a,b)与(b,a%b)的公约数相同，所以其最大公约数也相同。即gcd(a,b)==gcd(b,a%b);</code></pre><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>任何数与0的最大公约数都是他本身，且根据gcd(a,b)==gcd(b,a%b)可得知</p><p>当gcd中余数为0时，另一个数就是最大公约数。</p><p>所以代码如下</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> outcome;    <span class="hljs-keyword">int</span> temp;    <span class="hljs-keyword">while</span>(b!=<span class="hljs-number">0</span>)    &#123;        temp=a%b;        a=b;        b=temp;    &#125;    outcome=a;    <span class="hljs-keyword">return</span> outcome;&#125;</code></pre><p><em>溜溜球，去学概率论了…</em></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>世界反法西斯战争胜利75周年有感</title>
    <link href="/2020/09/03/%E4%B8%96%E7%95%8C%E5%8F%8D%E6%B3%95%E8%A5%BF%E6%96%AF%E6%88%98%E4%BA%89%E8%83%9C%E5%88%A975%E5%91%A8%E5%B9%B4%E6%9C%89%E6%84%9F/"/>
    <url>/2020/09/03/%E4%B8%96%E7%95%8C%E5%8F%8D%E6%B3%95%E8%A5%BF%E6%96%AF%E6%88%98%E4%BA%89%E8%83%9C%E5%88%A975%E5%91%A8%E5%B9%B4%E6%9C%89%E6%84%9F/</url>
    
    <content type="html"><![CDATA[<p>​       这是我今年第三次流泪：第一次是在听《国际歌》的时候，第二次是在读《悲惨世界》的时候，今天是第三次。但这次除了流泪，我还有一些忧虑。</p><a id="more"></a><p>​        “为有牺牲多壮志，敢叫日月换新天”。法西斯的阴云在中华大地盘旋了十四年，三千五百万烈士在反法西斯战争中牺牲。他们在极度艰苦的环境中仍坚守心中理想，献身于保卫祖国的斗争，以自己的血肉之躯换来了中华民族的转折点，换来了现在的人民共和国，换来了民族运动的高潮。他们的事迹永世长存，他们的功绩永垂不朽。</p><p>​        中国人民的斗争无疑对世界法西斯主义进行了沉重的打击，但法西斯主义已经完全消散了吗？红色的太阳已经高悬了吗？</p><p>​        只怕这片阴云恐怕还在盘旋，太阳也才刚放出光芒。</p><p>​        世界经济形势低迷，势必会带来社会变革。而对于现在的出路只有两条：左转，马列主义；右转，法西斯主义。而资本主义的领头人——美国，目前地表最强的国家，正在带领着一众资本主义国家向右疾行。而随着苏联的解体，国际共运陷入了又一次低潮，资本主义国家人民的声音越来越小。</p><p>​        再加上最近美国对华动作不断：贸易战、对台动作、驱逐中国留学生……，这一系列动作不禁让我想起了纳粹德国，担心会出现一个新的“水晶之夜”。担心出现像拉斯科利尼科夫那样的人——一个自认为非凡的普通人。我们已经为旧的法西斯主义付出了三千五百万条生命的代价，我们不能再忍受这样沉痛的代价。</p><p>​        昔日的盟友已经在法西斯道路上渐行渐远，屠龙者已经成为了恶龙。我们更不应松开我们的反法西斯历史，成为世界下一座灯塔。</p><p>​        现在世界上除了我们，再也没有人能担起反法西斯战士的称号了！达瓦里氏，我们的前途是光明的，社会主义的又一次高潮即将出现在东方；我们的前途也是崎岖的，我们面对的是前所未有的强大的敌人——美国，一个远比纳粹德国强大的力量。</p><p>​        在黎明到来前，会有很多人倒下，但我们终将迎来光明。</p><p>​        达瓦里氏，你，愿意和我一起吗？</p>]]></content>
    
    
    <categories>
      
      <category>Socialism</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Thinking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>My Bucket List -- version 1</title>
    <link href="/2020/08/11/My-Bucket-List-version-1/"/>
    <url>/2020/08/11/My-Bucket-List-version-1/</url>
    
    <content type="html"><![CDATA[<p>0.希望能为国家突破一些技术障碍</p><a id="more"></a><p>1.去俄罗斯游玩，再去伦敦的马克思墓地</p><p>2.帮助一个陌生人</p><p>3.对一个女生表白 and 亲吻世界上最美的女生</p><p>4.跑完一次马拉松</p><p>5.写出一个属于自己的纪念app/网页</p><p>6.去当国际志愿者 and 去联合国转转</p><p>7.见勒布朗 詹姆斯一面</p><p>8.开一次枪、坐直升机跳伞</p><p>9.把自己都捐了</p><p>…</p><p>正在努力的事情：</p><p>9.阅读马列主义书籍及其他世界名著</p><p>10.编程，进入ACM队</p><p>11.复习…</p><p>12.坚持跑步、锻炼</p><p>13.捐款</p><p>14.成为党员</p><p>15.保研到THU</p><p>16.能为国家硬件/软件做出自己的贡献</p>]]></content>
    
    
    <categories>
      
      <category>Bucket List</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Life</tag>
      
      <tag>Thinking</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

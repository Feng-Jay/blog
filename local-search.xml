<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>近日的烦恼</title>
    <link href="/2020/10/18/%E8%BF%91%E8%BF%91%E6%97%A5%E7%9A%84%E7%83%A6%E6%81%BC/"/>
    <url>/2020/10/18/%E8%BF%91%E8%BF%91%E6%97%A5%E7%9A%84%E7%83%A6%E6%81%BC/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>贪心算法</title>
    <link href="/2020/10/11/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    <url>/2020/10/11/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>Weekend for relax ?  NEMU : Algorithm.</p><a id="more"></a><h1 id="贪心算法的思想及要点"><a href="#贪心算法的思想及要点" class="headerlink" title="贪心算法的思想及要点"></a>贪心算法的思想及要点</h1><p>&emsp;&emsp;贪心算法正如其名，在解决问题时每次都会<strong>选择当前情况下的最优解</strong>，是一种逼近最优解的算法。他也是一种寻找最优解的方法，即在使用时要把整个问题分解为若干步，在每一步中都会选择当前最优的解法，然后将每一步的解合并成为整个问题的最终解。</p><p>&emsp;&emsp;他的问题在于：因为他的<strong>贪婪的短视</strong>导致在很多情况下都会错过最优解，因为他不会从整体上对问题进行思考，只会闷头于当前情况。所以贪心算法不能用来求最大最小值、无法保证最后的解是最优的、只能求某些特定的解。</p><p>&emsp;&emsp;所以实际上可以用贪心算法求得最优解的情况很少，所以我们要证明每一步所作的贪心选择最终能导出问题最优解（举几组数据即可）。</p><p>&emsp;&emsp;听起来贪心算法似乎很复杂，但他其实并没有太多的技巧。唯一的考验就<strong>在于制定你的贪心策略(主要是要有这个思想)</strong> 让你的算法 <strong>真正的只关心当下，不去关心后续情况或者先前情况</strong>。</p><h1 id="优化问题的一般描述"><a href="#优化问题的一般描述" class="headerlink" title="优化问题的一般描述"></a>优化问题的一般描述</h1><p><strong>优化问题的描述：</strong></p><p><strong>1.问题的解为一复杂结构 (x1,x2,…,xn) xi∈Si（可选的方式）</strong></p><p><strong>2.约束条件：B(x1,x2…,xn)，使B为true的元组称为可行解</strong></p><p><strong>3.目标函数f(x1,…,xn)</strong> </p><p><strong>优化解即指使目标函数取得最值的可行解，对应的目标函数值称为优化值</strong></p><p><strong>贪心算法是求近似解的一种主要途径。</strong></p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>下面我们来看一个很简单的例题</p><blockquote><p><strong>例 Loading Problem</strong></p><p><strong>设有n个集装箱,集装箱大小一样，第i个设有n个集装箱,集装箱大小一样，第i个集装箱的重量为wi(1≤i≤n),设船的载重量为c.试设计一装船的方法使得装入的集装箱数目最多</strong></p></blockquote><p>&emsp;</p><p>这是一道很基础的贪心算法题目，我们先按照<strong>优化问题的格式</strong>来描述一下他：</p><p><strong>令问题的解为(x1,x2,…,xn) &nbsp;xi={0,1}//代表第i个箱子是否装载。</strong></p><p><strong>问题的约束条件是Σi=1,n wixi&lt;=c; //装载箱子的总重量小于等于C</strong> </p><p><strong>目标函数为 Σi=1,n xi； //装载的集装箱个数</strong></p><p><strong>我们的目标是极大化目标函数。</strong></p><p>因为目标函数是所装的集装箱数目，所以按照我们的常规思想，那么一定先装重量轻的集装箱。</p><p>所以可以写出代码如下</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> n,c;<span class="hljs-keyword">int</span> weight[<span class="hljs-number">100</span>]=&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">int</span> countt=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> tem_weight=<span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cin</span>&gt;&gt;n;    <span class="hljs-built_in">cin</span>&gt;&gt;c;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)    <span class="hljs-built_in">cin</span>&gt;&gt;weight[i];    sort(weight,weight+n);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)    &#123;        <span class="hljs-keyword">if</span>(tem_weight+weight[i]&lt;=c)        &#123;            tem_weight+=weight[i];            countt++;        &#125;        <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">break</span>;&#125;    &#125;    <span class="hljs-built_in">cout</span>&lt;&lt;countt&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>这时你可能对这种贪心策略存疑，先装载重量低的箱子一定能得到最优解吗？</p><p>下面给出证明</p><p><u>证明:</u></p><p><u>设问题最优解为(y1,y2,…,yn)</u></p><p><u> </u></p><p><u>如最优解不含箱子1，将箱子1替换优化解中某一个箱子得到一个新的解</u></p><p><u>1.替换是必须的：若1还能装入船中，则(y1,y2,…,yn)不是优化的</u></p><p><u>2.因为1是最轻的，所以替换后的解仍是可行的</u></p><p><u>3.替换后的解装入的箱子数==优化的箱子数，它仍是优化解</u></p><p><u>4.替换后新的优化解和贪心解都有箱子1</u></p><p><u> </u></p><p><u>反复替换得到一个优化解，优化解==贪心解</u></p><p><u>替换次数是有穷的。</u></p><p>这就确定了我们的贪心解一定是优化解。</p><p><strong>针对这个问题也引出一点：贪心解虽然在一种策略下只有一个，但问题的真正最优解可能有多个。</strong></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日洛谷_9.28</title>
    <link href="/2020/09/28/%E6%AF%8F%E6%97%A5%E6%B4%9B%E8%B0%B7-9-28/"/>
    <url>/2020/09/28/%E6%AF%8F%E6%97%A5%E6%B4%9B%E8%B0%B7-9-28/</url>
    
    <content type="html"><![CDATA[<p>今天刷洛谷基础题看到一个很好的题，分享一下。</p><a id="more"></a><p>​    <a href="https://www.luogu.com.cn/problem/P2181">原题链接</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>对于一个 n 个顶点的凸多边形，它的任何三条对角线都不会交于一点。请求出图形中对角线交点的个数。</p><p>例如，6 边形：</p><img src="/2020/09/28/%E6%AF%8F%E6%97%A5%E6%B4%9B%E8%B0%B7-9-28/6023.png" style="zoom: 80%;"><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入只有一行一个整数 nnn，代表边数。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行一个整数代表答案。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入 #1 &nbsp;&emsp;输入#2</p><blockquote><p>3 &nbsp; &emsp;&nbsp;      6</p></blockquote><p>输出#2 &nbsp; &emsp; 输入#2</p><blockquote><p>0 &nbsp; &emsp;      &nbsp;15</p></blockquote><h2 id="说明与提示"><a href="#说明与提示" class="headerlink" title="说明与提示"></a>说明与提示</h2><ul><li>对于 50%50 %50% 的数据，保证 3≤n≤100。</li><li>对于 100%100 %100% 的数据，保证 3≤n≤10^5。</li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先看题目中一句<strong>任何三条对角线都不会交于一点</strong>，所以给定<strong>一个交点，可以确定两条对角线——也就意味着确定了四个角</strong></p><p>所以这道题就变成了一个排列问题</p><p>即求Cn4的组合数问题 ：就是求 n * (n-1) * (n-2) * (n-3) /24</p><p>这时大家可能会想&nbsp;”啊，这个题目这么简单，怎么会有人拿他出来写博客！”</p><p>所以你就写出了下面的代码</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> n;<span class="hljs-keyword">int</span> outcome;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cin</span>&gt;&gt;n;    outcome=n*(n<span class="hljs-number">-1</span>)*(n<span class="hljs-number">-2</span>)*(n<span class="hljs-number">-3</span>)/<span class="hljs-number">24</span>;    <span class="hljs-built_in">cout</span>&lt;&lt;outcome&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>结果</p><p><img src="/2020/09/28/%E6%AF%8F%E6%97%A5%E6%B4%9B%E8%B0%B7-9-28/%E7%BB%93%E6%9E%9C.png" alt="结果"></p><p><strong>再仔细阅读下题目，你会发现这道题会爆数据的…</strong></p><p><strong>所以你把int 全部换成了long long 或者unsigned long long ，并沾沾自喜，这么简单不会真有人拿出来写博客吧！</strong></p><p>结果你又发现出现了两个WA…（手动狗头）</p><p>这时你想到，我可以写高精求组合数啊</p><p><em>这无疑是一种很好的解题方法，但对于这样一道入门题来说，未免太…</em></p><p><strong>所以给出了一个很妙的写法</strong></p><p>那就是把 n * (n-1) * (n-2) * (n-3) /24写成 n * (n-1)/2 *(n-2) /3 *(n-3)/4</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> outcome;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cin</span>&gt;&gt;n;    outcome=n*(n<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>*(n<span class="hljs-number">-2</span>)/<span class="hljs-number">3</span>*(n<span class="hljs-number">-3</span>)/<span class="hljs-number">4</span>;    <span class="hljs-built_in">cout</span>&lt;&lt;outcome&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;</code></pre><p>现在来分析一下为什么这样写是对的。</p><p>首先n * (n-1)中一定有一个是2的倍数，所以可以被2整除</p><p>n * (n-1) *(n-2)中一定有一个是3的倍数，所以可以被3整除</p><p>n * (n-1) * (n-2) * (n-3) 中一定有一个是4的倍数，所以可以被4整除</p><p>emmmmmmmmmmm，就差不多是这样了</p><p>溜了溜了，上课去。</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>欧几里得算法</title>
    <link href="/2020/09/22/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/"/>
    <url>/2020/09/22/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>昨天上算法课听到了这个算法，突发兴趣来写一篇blog。</p><a id="more"></a><h1 id="欧几里得算法的用处"><a href="#欧几里得算法的用处" class="headerlink" title="欧几里得算法的用处"></a>欧几里得算法的用处</h1><p>欧几里得算法也称为辗转相除法，是求解最大公约数的一种方法。</p><p>若有两个数a和b，求a和b的最大公约数，按照我们之前所学的东西，可能只会枚举a与b的因子，效率很低…</p><p>但欧几里得为我们提供了一个十分便捷的方法。</p><h1 id="一个强大的定理"><a href="#一个强大的定理" class="headerlink" title="一个强大的定理"></a>一个强大的定理</h1><p><strong>gcd(a,b) = gcd(b, a%b)</strong></p><p>下面给出证明</p><pre><code class="hljs cpp">设a与b的公约数为 k ，a=bx+y;则 k|a 且 k|b ，有 a%b=y又有y=a-bx, 所以 k|y。即 k|a%b再假设b 与 a%b的公约数为kk，得 kk|a，所以(a,b)与(b,a%b)的公约数相同，所以其最大公约数也相同。即gcd(a,b)==gcd(b,a%b);</code></pre><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>任何数与0的最大公约数都是他本身，且根据gcd(a,b)==gcd(b,a%b)可得知</p><p>当gcd中余数为0时，另一个数就是最大公约数。</p><p>所以代码如下</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> outcome;    <span class="hljs-keyword">int</span> temp;    <span class="hljs-keyword">while</span>(b!=<span class="hljs-number">0</span>)    &#123;        temp=a%b;        a=b;        b=temp;    &#125;    outcome=a;    <span class="hljs-keyword">return</span> outcome;&#125;</code></pre><p><em>溜溜球，去学概率论了…</em></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>世界反法西斯战争胜利75周年有感</title>
    <link href="/2020/09/03/%E4%B8%96%E7%95%8C%E5%8F%8D%E6%B3%95%E8%A5%BF%E6%96%AF%E6%88%98%E4%BA%89%E8%83%9C%E5%88%A975%E5%91%A8%E5%B9%B4%E6%9C%89%E6%84%9F/"/>
    <url>/2020/09/03/%E4%B8%96%E7%95%8C%E5%8F%8D%E6%B3%95%E8%A5%BF%E6%96%AF%E6%88%98%E4%BA%89%E8%83%9C%E5%88%A975%E5%91%A8%E5%B9%B4%E6%9C%89%E6%84%9F/</url>
    
    <content type="html"><![CDATA[<p>​       这是我今年第三次流泪：第一次是在听《国际歌》的时候，第二次是在读《悲惨世界》的时候，今天是第三次。但这次除了流泪，我还有一些忧虑。</p><a id="more"></a><p>​        “为有牺牲多壮志，敢叫日月换新天”。法西斯的阴云在中华大地盘旋了十四年，三千五百万烈士在反法西斯战争中牺牲。他们在极度艰苦的环境中仍坚守心中理想，献身于保卫祖国的斗争，以自己的血肉之躯换来了中华民族的转折点，换来了现在的人民共和国，换来了民族运动的高潮。他们的事迹永世长存，他们的功绩永垂不朽。</p><p>​        中国人民的斗争无疑对世界法西斯主义进行了沉重的打击，但法西斯主义已经完全消散了吗？红色的太阳已经高悬了吗？</p><p>​        只怕这片阴云恐怕还在盘旋，太阳也才刚放出光芒。</p><p>​        世界经济形势低迷，势必会带来社会变革。而对于现在的出路只有两条：左转，马列主义；右转，法西斯主义。而资本主义的领头人——美国，目前地表最强的国家，正在带领着一众资本主义国家向右疾行。而随着苏联的解体，国际共运陷入了又一次低潮，资本主义国家人民的声音越来越小。</p><p>​        再加上最近美国对华动作不断：贸易战、对台动作、驱逐中国留学生……，这一系列动作不禁让我想起了纳粹德国，担心会出现一个新的“水晶之夜”。担心出现像拉斯科利尼科夫那样的人——一个自认为非凡的普通人。我们已经为旧的法西斯主义付出了三千五百万条生命的代价，我们不能再忍受这样沉痛的代价。</p><p>​        昔日的盟友已经在法西斯道路上渐行渐远，屠龙者已经成为了恶龙。我们更不应松开我们的反法西斯历史，成为世界下一座灯塔。</p><p>​        现在世界上除了我们，再也没有人能担起反法西斯战士的称号了！达瓦里氏，我们的前途是光明的，社会主义的又一次高潮即将出现在东方；我们的前途也是崎岖的，我们面对的是前所未有的强大的敌人——美国，一个远比纳粹德国强大的力量。</p><p>​        在黎明到来前，会有很多人倒下，但我们终将迎来光明。</p><p>​        达瓦里氏，你，愿意和我一起吗？</p>]]></content>
    
    
    <categories>
      
      <category>Socialism</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Thinking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>My Bucket List -- version 1</title>
    <link href="/2020/08/11/My-Bucket-List-version-1/"/>
    <url>/2020/08/11/My-Bucket-List-version-1/</url>
    
    <content type="html"><![CDATA[<p>0.希望能为国家突破一些技术障碍</p><a id="more"></a><p>1.去俄罗斯游玩，再去伦敦的马克思墓地</p><p>2.帮助一个陌生人</p><p>3.对一个女生表白 and 亲吻世界上最美的女生</p><p>4.跑完一次马拉松</p><p>5.写出一个属于自己的纪念app/网页</p><p>6.去当国际志愿者 and 去联合国转转</p><p>7.见勒布朗 詹姆斯一面</p><p>8.开一次枪、坐直升机跳伞</p><p>9.把自己都捐了</p><p>…</p><p>正在努力的事情：</p><p>9.阅读马列主义书籍及其他世界名著</p><p>10.编程，进入ACM队</p><p>11.复习…</p><p>12.坚持跑步、锻炼</p><p>13.捐款</p><p>14.成为党员</p><p>15.保研到THU</p><p>16.能为国家硬件/软件做出自己的贡献</p>]]></content>
    
    
    <categories>
      
      <category>Bucket List</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Life</tag>
      
      <tag>Thinking</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

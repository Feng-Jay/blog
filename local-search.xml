<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>NEMU</title>
    <link href="/2020/11/10/NEMU/"/>
    <url>/2020/11/10/NEMU/</url>
    
    <content type="html"><![CDATA[<p>Record my programming process and give others some inspirations.</p><a id="more"></a><p>You can find source code from <a href="https://github.com/Feng-Jay/NEMU">My github repo</a></p><p>/* But please do not just ctrl+c and ctrl+v */</p><p>And here is a very useful manual <a href="https://nju-ics.gitbooks.io/ics2015-programming-assignment/content/PA0.html">NEMU_gitbook</a></p><h1 id="PA2"><a href="#PA2" class="headerlink" title="PA2"></a>PA2</h1><p>PA2要求我们在NEMU中实现部分X86指令集中的内容。</p><p>如果是第一次真正接触底层指令编写的话，一开始肯定是很茫然和无措的。(切身体会)</p><p>但别灰心，CS就是这样，只有不会才能提升嘛。那么就….开始！</p><h2 id="三个关键宏"><a href="#三个关键宏" class="headerlink" title="三个关键宏"></a>三个关键宏</h2><p>阅读指导书，会发现这样三个宏定义在实现新指令时都会被用到。</p><pre><code class="hljs c"><span class="hljs-string">&quot;nemu/include/cpu/helper.h&quot;</span><span class="hljs-comment">/* All function defined with &#x27;make_helper&#x27; return the length of the operation. */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> make_helper(name) int name(swaddr_t eip)</span><span class="hljs-string">&quot;nemu/include/cpu/exec/helper.h&quot;</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> make_helper_v(name) </span>make_helper(concat(name, _v)) &#123; <span class="hljs-keyword">return</span> (ops_decoded.is_operand_size_16 ? concat(name, _w) : concat(name, _l)) (eip); \&#125;<span class="hljs-string">&quot;nemu/include/cpu/exec/helper.h&quot;</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> make_instr_helper(type) </span>make_helper(concat5(instr, _, type, _, SUFFIX)) &#123; <span class="hljs-keyword">return</span> idex(eip, concat4(decode_, type, _, SUFFIX), do_execute); &#125;</code></pre><p>这三个宏定义很巧妙地使用了函数指针和宏定义的配合。<a href="https://blog.csdn.net/Zz_1996/article/details/78758627">感兴趣可以了解一下</a></p><p><strong>其中，make_helper函数的功能是声明一个函数，并且返回操作的长度</strong></p><p>可以通过阅读代码知道，make_helper函数每次都要传入一个参数eip，返回一个int值。</p><p>&emsp;</p><p><strong>make_helper_v函数的作用是用来确定一个函数的后缀</strong></p><p>16位指令的话就+w(word,16bits)，否则就+l(long word, 32bits);</p><p>&emsp;</p><p><strong>make_instr_helper函数的作用就是确定函数的形式，并且进行译码、执行</strong></p><p>其中 <code>type</code> 为指令的形式, 通过调用 <code>idex()</code> 函数来进行执行的译码和执行。</p><p>&emsp;</p><p>如果看不太懂没关系，下面来一个实例</p><p><strong>mov_i2r_b指令的实现</strong></p><pre><code class="hljs c"><span class="hljs-string">&quot;nemu/src/cpu/exec/date-mov/mov.h&quot;</span>make_helper(mov_i2r_b);<span class="hljs-string">&quot;nemu/src/cpu/exec/date-mov/mov.c &quot;</span>make_helper_v(mov_i2r)    <span class="hljs-string">&quot;nemu/src/cpu/exec/date-mov/mov-template.h&quot;</span>make_instr_helper(i2r)    <span class="hljs-comment">/*ignored the do_execute part*/</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>Operating System</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dynamic Programming</title>
    <link href="/2020/11/07/Dynamic-Programming/"/>
    <url>/2020/11/07/Dynamic-Programming/</url>
    
    <content type="html"><![CDATA[<p>Share and review my study process.</p><a id="more"></a><h1 id="引论"><a href="#引论" class="headerlink" title="引论"></a>引论</h1><p><strong>个人理解动态规划应该是一种设计技巧，和分治法类似，但DP更关心子问题的重叠。</strong></p><p>动态规划是一种在各个不同大小(size)的子问题的优化值之间建立递归关系并求解的过程.</p><p>能使用动态规划求解的问题必须<strong>满足优化原理：</strong></p><p><strong>优化解包含的子问题的解也是最优的</strong></p><p>即可利用优化原理，使用枚举法建立不同长度子问题优化值之间的递归关系—动态规划方程。</p><p><em>注意，动态规划算法得出的解为精确解，子问题的数目决定了该算法的复杂度.</em></p><p><em>Ps: 尽量不要用递归</em></p><h1 id="经典的0-1背包"><a href="#经典的0-1背包" class="headerlink" title="经典的0/1背包"></a>经典的0/1背包</h1><p><strong>给定 n 种物品和一个容量为 C 的背包，物品 i 的重量是 wi，其价值为 vi 。</strong></p><p><strong>问：应该如何选择装入背包的物品，使得装入背包中的物品的总价值最大？</strong></p><p>&emsp; </p><p>在学习DP算法之前，我们面对01背包问题有的思路就是贪心和穷举：</p><p>不管是对价值排序还是对价值密度排序，只是改变了贪心策略，但还是贪心算法，也就意味着我们只能求解一个近似解，无法得到精确解。</p><p>而穷举法的开销太大了，在很多情况下复杂且不适用。</p><p><strong>既然贪心法在理论上是无法得到精确解的，那我们能否在穷举的基础上进行优化呢？</strong></p><h2 id="来一个具体的例子"><a href="#来一个具体的例子" class="headerlink" title="来一个具体的例子"></a><strong>来一个具体的例子</strong></h2><p>n=5,c=10,w=[2,2,6,5,4],p=[6,3,5,4,6]. </p><p>可知此时的优化解为(1,1,0,0,1),即装1,2,5物品</p><p>想要用DP算法，首先要判断<strong>问题是否满足优化原理</strong></p><p>即优化解包含的子问题的解是否最优。</p><blockquote><p>当我们先装物品1时。</p><p>物品1装入，子问题为n=4,c’=c-2(物品1的重量),物品为2,3,4,5</p><p>可以看到子问题的优化解为(1,0,0,1)</p><p>与优化解相同</p></blockquote><p>可以得知<strong>01背包问题满足优化原理</strong>。</p><h2 id="DP的思路分析"><a href="#DP的思路分析" class="headerlink" title="DP的思路分析"></a>DP的思路分析</h2><p>面对n个物品，我们并不知道该拿哪几个才是最优解，那么就使用计算机最擅长的技能：计算(遍历)</p><p>只不过我们会对遍历进行一些操作</p><p>设函数 f(i,y)表示当背包容量为y时，面对 i，i+1,…，n物品时的最优解。</p><p>可以知道f(1,c)就是我们最终要求的答案</p><p>求 f(1,c)遇到的第一个问题就是物品1拿不拿？</p><p>答案是：不知道。&emsp; 但我们可以根据子问题推出来物品1拿不拿。</p><p><strong>f(1,c)=max{f(2,c), f(2,c-w1)+p1}</strong></p><p>这样我们的思路就出来了：建立一个父问题与子问题递归式。即在最后一个物品时返回两种情况：拿或不拿。再一路返回到第一种情况，判断物品1拿不拿。</p><p>下面是递归算法和非递归算法</p><h2 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h2><pre><code class="hljs cpp"><span class="hljs-comment">//递归算法</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> content;<span class="hljs-keyword">int</span> num_things;<span class="hljs-keyword">int</span> weightt[<span class="hljs-number">101</span>];<span class="hljs-keyword">int</span> value[<span class="hljs-number">101</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> thing,<span class="hljs-keyword">int</span> content)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> dp1=<span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> dp2;    <span class="hljs-keyword">if</span>(thing==num_things<span class="hljs-number">-1</span>)    &#123;        <span class="hljs-keyword">if</span>(content&lt;weightt[num_things<span class="hljs-number">-1</span>])        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;        <span class="hljs-keyword">else</span>        &#123;            <span class="hljs-keyword">return</span> value[num_things<span class="hljs-number">-1</span>];        &#125;            &#125;    <span class="hljs-keyword">if</span>(content&gt;=weightt[thing])    dp1=dp(thing+<span class="hljs-number">1</span>,content-weightt[thing])+value[thing];    dp2=dp(thing+<span class="hljs-number">1</span>,content);    <span class="hljs-keyword">return</span> max(dp1,dp2);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cin</span>&gt;&gt;content&gt;&gt;num_things;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;num_things;i++)    <span class="hljs-built_in">cin</span>&gt;&gt;weightt[i];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;num_things;i++)    <span class="hljs-built_in">cin</span>&gt;&gt;value[i];    <span class="hljs-built_in">cout</span>&lt;&lt;dp(<span class="hljs-number">0</span>,content)&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>由于递归算法开销很大，所以我们使用元组法来实现DP</p><h2 id="元组法"><a href="#元组法" class="headerlink" title="元组法"></a>元组法</h2><p>仔细回想我们的01背包问题，是否有这样一个感觉，效益值=f(i,y)是一个分段函数，且每一段都是效益值不变的水平直线。</p><p>那么我们只要记住分段函数的跳跃点，是否就可以对输入的每种情况进行还原(和数据结构中稀疏矩阵的存储相似)</p><p>&emsp;</p><p>由于f(i, y)=max{ f(i+1,y),f(i+1,y-w<del>i</del>)+p<del>i</del> }</p><p>设f(i,y)对应元组P(i), f(i+1,y-w<del>i</del>)+p<del>i</del>对应元组Q</p><p>我们想要得到的是P(i)，所以我们需要求P(i+1)和Q。</p><p>由于f(i+1,y-w<del>i</del>)+p<del>i</del>可看作f(i+1,y)向右向上平移，所以P中每个元组(a,b)对应Q中的(a+wi,b+pi)</p><p>&emsp; </p><p>求出P(i+1)和Q后，使用类似于merge排序的方法把两个元组中的点合并</p><p><strong>合并规则：</strong></p><p><strong>合并时使用以下支配(选优)规则:</strong></p><p><strong>设(a,b)和(u,v)是来自P(i+1)和Q的元组,若a≥u且b＜v,则称(a,b)受(u,v) 支配. 因为</strong></p><p><strong>(a,b)代表以容量a得到效益值b的方案,</strong></p><p><strong>而(u,v)代表以较少的容量u得到较大效益值v的装包方案.</strong></p><p>(可以想象为两个分段函数一直取x相等时二者y值最大的一段)</p><p>&emsp;</p><p><strong>得到P(2)后我们可以不求P(1)</strong></p><p>直接利用w<del>1</del>和P(2)来求出满足w<del>1</del>+w&lt;C的最后一个元组（w,v）</p><p>将v+p<del>1</del>与原来P(2)中最后一个满足条件的效益值比较，取最大的那个。 </p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>人这一辈子，最不能透支的是什么？</title>
    <link href="/2020/11/03/%E5%85%B1%E5%8B%89/"/>
    <url>/2020/11/03/%E5%85%B1%E5%8B%89/</url>
    
    <content type="html"><![CDATA[<p>午觉起来看到知乎一个高赞回答，分享一下，与君共勉。</p><a id="more"></a><p>作者：简在我心<br>链接：<a href="https://www.zhihu.com/question/422796779/answer/1556486657">知乎链接</a><br>来源：知乎</p><p>生命力。</p><p>今天上午给学生讲解电影《死亡诗社》，对这个问题正好深有感触。</p><p>这个影片里，反复提到一些词：热情，激情，爱，浪漫，强有力，奋斗，寻觅，发现，呐喊……</p><p>人类这个物种有个很大的优势就是对新鲜事物的好奇性。</p><p>我们喜欢探奇历险，喜欢学习研究。但是这种行为具有风险。</p><p>所以长辈或管理者为了安全需要和管理方便，会制定各种规则，把那个内心里生动活泼的小人儿关进牢笼里。</p><p>不让你玩水，不让你玩火，不让你爬树，不让你恋爱，不让你问为什么，不让你做这个做那个。</p><p>美其名曰：为你好。</p><p>然后你的生命力就会在种种禁锢中持续性流失和透支。</p><p>你变得对生活失去了热情，对世界失去了探索的欲望，你没有了学习的兴趣，没有了爱的能力……</p><p>失去生命力的表现：</p><p>你刷着抖音，停不下来，哪怕已经厌倦，也还是忍不住继续滑动手指。</p><p>你躺在床上，睡到头疼，浑身无力，不想再躺下去了，却依然缺乏起床的动力。</p><p>你玩着游戏，玩到疲惫不堪，但依然百无聊赖地点着鼠标，两眼无光。</p><p>你频繁和五姑娘交谈，谈到昏昏沉沉，依然不想松开她。</p><p>你失去了对自己的生命的强有力的感觉。</p><p>你沦丧于无聊的重复的形式中，无力自拔。</p><p>失去了生命的热情和希望。</p><p>失去了对于自我身体的掌控。</p><p>失去了对事物的感知能力。</p><p>你疲惫，疲软，无力，无感，靠反复的刺激来提醒自己好像还活着。</p><p>我认为这就是生命力透支的表现，是最糟糕的生活状态，没有之一。</p><p>我为什么感受那么深？</p><p>最近跟学生交流，发现他们很多人都已经处于这种生命力透支的状态。</p><p>你问他还有什么理想、希望或想做的事情。好像没有，或即便有也是缺乏可持续性。</p><p>所以他们只能浑浑噩噩地混日子。</p><p>为什么那么多人抑郁、自杀或躺平？</p><p>因为他们的生命力已经透支了，枯竭了，对生活已经没有了热情，没有了希望，也没有了信心。</p><p>才不到二十岁的年纪，就失去了狂野、野心、激情、欲望。</p><p>这是一个多么令人痛心的事实。</p><p>所以别说什么成才，就是过好自己平凡一生都很难了。</p><p>这将是一个个了无生趣的生命。</p><p>这就是不重视人文教育的后果。</p><p>生命需要呵护，需要个性的张扬和奔放，需要自由的空气，才能健康成长，才能抵御现实的风霜雪剑。</p><p>可是我们以爱的名义，剥夺了孩子们的生命力，使得他们还没绽放，就已经枯萎了。</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Life</tag>
      
      <tag>Thinking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Operating System</title>
    <link href="/2020/10/27/Operating%E2%80%94-System/"/>
    <url>/2020/10/27/Operating%E2%80%94-System/</url>
    
    <content type="html"><![CDATA[<p>Basic knowledge about OS &amp;&amp; Linux. Solutions about MIT 6.828</p><a id="more"></a><h1 id="Processes"><a href="#Processes" class="headerlink" title="Processes"></a>Processes</h1><h2 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h2><p>进程是一个正在执行程序的实例，包括了程序代码和它当前的状态（寄存器…）</p><p>一个进程包括三个部分</p><p><img src="/2020/10/27/Operating%E2%80%94-System/Process.png" alt="process contains"></p><p><em>Tips: The differences between process and program</em></p><p><em>Program is just the static text</em></p><p><em>Process is an dynamic entity being executed and has lifecycle</em></p><p><em>So if a program exec two times ,there should be two processes</em></p><h2 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h2><p>四种事件会导致进程的创建:</p><p>1.系统初始化</p><p>2.正在运行的程序执行了创建进程的系统调用</p><p>3.用户请求创建一个新进程</p><p>4.批处理作业的初始化</p><p>新进程都是由一个已存在的进程执行了一个用于创建进程的系统调用而创建。</p><p>在Linux中，只有fork这个系统调用可用来创建进程。</p><p>fork后，创建的子进程会和父进程拥有相同的内存映像、环境变量。通常，子进程会接着执行一个execve之类的系统调用来修改内存映像从而运行一个新的程序。</p><h2 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h2><p>进程终止的条件：</p><p>1.正常退出(自愿的)</p><p>2.出错退出(自愿的) 自愿时通常调用exit系统调用</p><p>3.严重错误(非自愿)</p><p>4.被其他进程杀死(非自愿)//在Linux和Windows中，如果一个进程被杀死，但他创建的进程不会被全部杀死</p><h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><p><img src="/2020/10/27/Operating%E2%80%94-System/%E7%8A%B6%E6%80%81.png" alt="进程状态"></p>]]></content>
    
    
    <categories>
      
      <category>Operating System</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Operating System</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>贪心算法&amp;&amp;优化问题</title>
    <link href="/2020/10/11/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    <url>/2020/10/11/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>Record key point  And  write code for some problems.</p><a id="more"></a><h1 id="优化问题"><a href="#优化问题" class="headerlink" title="优化问题"></a>优化问题</h1><h2 id="优化问题的概念"><a href="#优化问题的概念" class="headerlink" title="优化问题的概念"></a>优化问题的概念</h2><p>即通过一定条件约束，对一组变量进行操作，使目标到达最优值。</p><h2 id="优化问题的一般描述"><a href="#优化问题的一般描述" class="headerlink" title="优化问题的一般描述"></a>优化问题的一般描述</h2><p><strong>优化问题的描述：</strong></p><p><strong>1.问题的解为一复杂结构 (x1,x2,…,xn) xi∈Si（可选的方式）</strong></p><p><strong>2.约束条件：B(x1,x2…,xn)，使B为true的元组称为可行解</strong></p><p><strong>3.目标函数f(x1,…,xn)</strong> </p><p><strong>优化解即指使目标函数取得最值的可行解，对应的目标函数值称为优化值</strong></p><p><strong>贪心算法是求近似解的一种主要途径。</strong></p><h1 id="贪心算法的思想及要点"><a href="#贪心算法的思想及要点" class="headerlink" title="贪心算法的思想及要点"></a>贪心算法的思想及要点</h1><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>&emsp;&emsp;贪心算法是一种多步求解的方法，每步按一种局部最优的策略选择解的一个分量，算法以第n步结束时构造出问题的解。他也是一种寻找最优解的方法，即在使用时要把整个问题分解为若干步，在每一步中都会选择当前最优的解法，然后将每一步的解合并成为整个问题的最终解。</p><p>&emsp;&emsp;该算法问题在于：因为其的<strong>贪婪的短视</strong>导致在很多情况下都会错过最优解，因为贪心算法不会从整体上对问题进行思考，只会闷头于当前情况。所以贪心算法不能用来求最大最小值、无法保证最后的解是最优的、只能求某些特定的解。</p><p>&emsp;&emsp;所以实际上可以用贪心算法求得最优解的情况很少，所以我们要证明每一步所作的贪心选择最终能导出问题最优解（举几组数据即可）。</p><p>&emsp;&emsp;听起来贪心算法似乎很复杂，但他其实并没有太多的技巧。唯一的考验就<strong>在于制定你的贪心策略(主要是要有这个思想)</strong> 让你的算法 <strong>真正的只关心当下，不去关心后续情况或者先前情况</strong>。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>不回溯</li><li>局部优化策略可以减小开销，但不保证得到精确优化解</li><li>不同贪心策略得到不同算法</li><li>常使用使目标函数有最大增量的策略为贪心策略</li></ol><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>下面我们来看一个很简单的例题</p><blockquote><p><strong>例 Loading Problem</strong></p><p><strong>设有n个集装箱,集装箱大小一样，第i个设有n个集装箱,集装箱大小一样，第i个集装箱的重量为wi(1≤i≤n),设船的载重量为c.试设计一装船的方法使得装入的集装箱数目最多</strong></p></blockquote><p>&emsp;</p><p>这是一道很基础的贪心算法题目，我们先按照<strong>优化问题的格式</strong>来描述一下他：</p><p><strong>令问题的解为(x1,x2,…,xn) &nbsp;xi={0,1}//代表第i个箱子是否装载。</strong></p><p><strong>问题的约束条件是Σi=1,n wixi&lt;=c; //装载箱子的总重量小于等于C</strong> </p><p><strong>目标函数为 Σi=1,n xi； //装载的集装箱个数</strong></p><p><strong>我们的目标是极大化目标函数。</strong></p><p>因为目标函数是所装的集装箱数目，所以按照我们的常规思想，那么一定先装重量轻的集装箱。</p><p>所以可以写出代码如下</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> n,c;<span class="hljs-keyword">int</span> weight[<span class="hljs-number">100</span>]=&#123;<span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">int</span> countt=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> tem_weight=<span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cin</span>&gt;&gt;n;    <span class="hljs-built_in">cin</span>&gt;&gt;c;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)    <span class="hljs-built_in">cin</span>&gt;&gt;weight[i];    sort(weight,weight+n);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)    &#123;        <span class="hljs-keyword">if</span>(tem_weight+weight[i]&lt;=c)        &#123;            tem_weight+=weight[i];            countt++;        &#125;        <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">break</span>;&#125;    &#125;    <span class="hljs-built_in">cout</span>&lt;&lt;countt&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>这时你可能对这种贪心策略存疑，先装载重量低的箱子一定能得到最优解吗？</p><p>下面给出证明</p><p><u>证明:</u></p><p><u>设问题最优解为(y1,y2,…,yn)</u></p><p><u> </u></p><p><u>如最优解不含箱子1，将箱子1替换优化解中某一个箱子得到一个新的解</u></p><p><u>1.替换是必须的：若1还能装入船中，则(y1,y2,…,yn)不是优化的</u></p><p><u>2.因为1是最轻的，所以替换后的解仍是可行的</u></p><p><u>3.替换后的解装入的箱子数==优化的箱子数，它仍是优化解</u></p><p><u>4.替换后新的优化解和贪心解都有箱子1</u></p><p><u> </u></p><p><u>反复替换得到一个优化解，优化解==贪心解</u></p><p><u>替换次数是有穷的。</u></p><p>这就确定了在这道题目里，我们的贪心解一定是优化解。</p><p><strong>针对这个问题也引出一点：贪心解虽然在一种策略下只有一个，但问题的真正最优解可能有多个。</strong>   </p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>每日洛谷_9.28</title>
    <link href="/2020/09/28/%E6%AF%8F%E6%97%A5%E6%B4%9B%E8%B0%B7-9-28/"/>
    <url>/2020/09/28/%E6%AF%8F%E6%97%A5%E6%B4%9B%E8%B0%B7-9-28/</url>
    
    <content type="html"><![CDATA[<p>今天刷洛谷基础题看到一个很好的题，分享一下。</p><a id="more"></a><p>​    <a href="https://www.luogu.com.cn/problem/P2181">原题链接</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>对于一个 n 个顶点的凸多边形，它的任何三条对角线都不会交于一点。请求出图形中对角线交点的个数。</p><p>例如，6 边形：</p><img src="/2020/09/28/%E6%AF%8F%E6%97%A5%E6%B4%9B%E8%B0%B7-9-28/6023.png" style="zoom: 80%;"><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入只有一行一个整数 nnn，代表边数。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行一个整数代表答案。</p><h2 id="输入输出样例"><a href="#输入输出样例" class="headerlink" title="输入输出样例"></a>输入输出样例</h2><p>输入 #1 &nbsp;&emsp;输入#2</p><blockquote><p>3 &nbsp; &emsp;&nbsp;      6</p></blockquote><p>输出#2 &nbsp; &emsp; 输入#2</p><blockquote><p>0 &nbsp; &emsp;      &nbsp;15</p></blockquote><h2 id="说明与提示"><a href="#说明与提示" class="headerlink" title="说明与提示"></a>说明与提示</h2><ul><li>对于 50%50 %50% 的数据，保证 3≤n≤100。</li><li>对于 100%100 %100% 的数据，保证 3≤n≤10^5。</li></ul><h1 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h1><p>首先看题目中一句<strong>任何三条对角线都不会交于一点</strong>，所以给定<strong>一个交点，可以确定两条对角线——也就意味着确定了四个角</strong></p><p>所以这道题就变成了一个排列问题</p><p>即求Cn4的组合数问题 ：就是求 n * (n-1) * (n-2) * (n-3) /24</p><p>这时大家可能会想&nbsp;”啊，这个题目这么简单，怎么会有人拿他出来写博客！”</p><p>所以你就写出了下面的代码</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> n;<span class="hljs-keyword">int</span> outcome;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cin</span>&gt;&gt;n;    outcome=n*(n<span class="hljs-number">-1</span>)*(n<span class="hljs-number">-2</span>)*(n<span class="hljs-number">-3</span>)/<span class="hljs-number">24</span>;    <span class="hljs-built_in">cout</span>&lt;&lt;outcome&lt;&lt;<span class="hljs-built_in">endl</span>;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>结果</p><p><img src="/2020/09/28/%E6%AF%8F%E6%97%A5%E6%B4%9B%E8%B0%B7-9-28/%E7%BB%93%E6%9E%9C.png" alt="结果"></p><p><strong>再仔细阅读下题目，你会发现这道题会爆数据的…</strong></p><p><strong>所以你把int 全部换成了long long 或者unsigned long long ，并沾沾自喜，这么简单不会真有人拿出来写博客吧！</strong></p><p>结果你又发现出现了两个WA…（手动狗头）</p><p>这时你想到，我可以写高精求组合数啊</p><p><em>这无疑是一种很好的解题方法，但对于这样一道入门题来说，未免太…</em></p><p><strong>所以给出了一个很妙的写法</strong></p><p>那就是把 n * (n-1) * (n-2) * (n-3) /24写成 n * (n-1)/2 *(n-2) /3 *(n-3)/4</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> n;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> outcome;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-built_in">cin</span>&gt;&gt;n;    outcome=n*(n<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>*(n<span class="hljs-number">-2</span>)/<span class="hljs-number">3</span>*(n<span class="hljs-number">-3</span>)/<span class="hljs-number">4</span>;    <span class="hljs-built_in">cout</span>&lt;&lt;outcome&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;</code></pre><p>现在来分析一下为什么这样写是对的。</p><p>首先n * (n-1)中一定有一个是2的倍数，所以可以被2整除</p><p>n * (n-1) *(n-2)中一定有一个是3的倍数，所以可以被3整除</p><p>n * (n-1) * (n-2) * (n-3) 中一定有一个是4的倍数，所以可以被4整除</p><p>emmmmmmmmmmm，就差不多是这样了</p><p>溜了溜了，上课去。</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>欧几里得算法</title>
    <link href="/2020/09/22/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/"/>
    <url>/2020/09/22/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>昨天上算法课听到了这个算法，突发兴趣来写一篇blog。</p><a id="more"></a><h1 id="欧几里得算法的用处"><a href="#欧几里得算法的用处" class="headerlink" title="欧几里得算法的用处"></a>欧几里得算法的用处</h1><p>欧几里得算法也称为辗转相除法，是求解最大公约数的一种方法。</p><p>若有两个数a和b，求a和b的最大公约数，按照我们之前所学的东西，可能只会枚举a与b的因子，效率很低…</p><p>但欧几里得为我们提供了一个十分便捷的方法。</p><h1 id="一个强大的定理"><a href="#一个强大的定理" class="headerlink" title="一个强大的定理"></a>一个强大的定理</h1><p><strong>gcd(a,b) = gcd(b, a%b)</strong></p><p>下面给出证明</p><pre><code class="hljs cpp">设a与b的公约数为 k ，a=bx+y;则 k|a 且 k|b ，有 a%b=y又有y=a-bx, 所以 k|y。即 k|a%b再假设b 与 a%b的公约数为kk，得 kk|a，所以(a,b)与(b,a%b)的公约数相同，所以其最大公约数也相同。即gcd(a,b)==gcd(b,a%b);</code></pre><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>任何数与0的最大公约数都是他本身，且根据gcd(a,b)==gcd(b,a%b)可得知</p><p>当gcd中余数为0时，另一个数就是最大公约数。</p><p>所以代码如下</p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span><span class="hljs-function"></span>&#123;    <span class="hljs-keyword">int</span> outcome;    <span class="hljs-keyword">int</span> temp;    <span class="hljs-keyword">while</span>(b!=<span class="hljs-number">0</span>)    &#123;        temp=a%b;        a=b;        b=temp;    &#125;    outcome=a;    <span class="hljs-keyword">return</span> outcome;&#125;</code></pre><p><em>溜溜球，去学概率论了…</em></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>世界反法西斯战争胜利75周年有感</title>
    <link href="/2020/09/03/%E4%B8%96%E7%95%8C%E5%8F%8D%E6%B3%95%E8%A5%BF%E6%96%AF%E6%88%98%E4%BA%89%E8%83%9C%E5%88%A975%E5%91%A8%E5%B9%B4%E6%9C%89%E6%84%9F/"/>
    <url>/2020/09/03/%E4%B8%96%E7%95%8C%E5%8F%8D%E6%B3%95%E8%A5%BF%E6%96%AF%E6%88%98%E4%BA%89%E8%83%9C%E5%88%A975%E5%91%A8%E5%B9%B4%E6%9C%89%E6%84%9F/</url>
    
    <content type="html"><![CDATA[<p>​       这是我今年第三次流泪：第一次是在听《国际歌》的时候，第二次是在读《悲惨世界》的时候，今天是第三次。但这次除了流泪，我还有一些忧虑。</p><a id="more"></a><p>​        “为有牺牲多壮志，敢叫日月换新天”。法西斯的阴云在中华大地盘旋了十四年，三千五百万烈士在反法西斯战争中牺牲。他们在极度艰苦的环境中仍坚守心中理想，献身于保卫祖国的斗争，以自己的血肉之躯换来了中华民族的转折点，换来了现在的人民共和国，换来了民族运动的高潮。他们的事迹永世长存，他们的功绩永垂不朽。</p><p>​        中国人民的斗争无疑对世界法西斯主义进行了沉重的打击，但法西斯主义已经完全消散了吗？红色的太阳已经高悬了吗？</p><p>​        只怕这片阴云恐怕还在盘旋，太阳也才刚放出光芒。</p><p>​        世界经济形势低迷，势必会带来社会变革。而对于现在的出路只有两条：左转，马列主义；右转，法西斯主义。而资本主义的领头人——美国，目前地表最强的国家，正在带领着一众资本主义国家向右疾行。而随着苏联的解体，国际共运陷入了又一次低潮，资本主义国家人民的声音越来越小。</p><p>​        再加上最近美国对华动作不断：贸易战、对台动作、驱逐中国留学生……，这一系列动作不禁让我想起了纳粹德国，担心会出现一个新的“水晶之夜”。担心出现像拉斯科利尼科夫那样的人——一个自认为非凡的普通人。我们已经为旧的法西斯主义付出了三千五百万条生命的代价，我们不能再忍受这样沉痛的代价。</p><p>​        昔日的盟友已经在法西斯道路上渐行渐远，屠龙者已经成为了恶龙。我们更不应松开我们的反法西斯历史，成为世界下一座灯塔。</p><p>​        现在世界上除了我们，再也没有人能担起反法西斯战士的称号了！达瓦里氏，我们的前途是光明的，社会主义的又一次高潮即将出现在东方；我们的前途也是崎岖的，我们面对的是前所未有的强大的敌人——美国，一个远比纳粹德国强大的力量。</p><p>​        在黎明到来前，会有很多人倒下，但我们终将迎来光明。</p><p>​        达瓦里氏，你，愿意和我一起吗？</p>]]></content>
    
    
    <categories>
      
      <category>Socialism</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Thinking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>My Bucket List -- version 1</title>
    <link href="/2020/08/11/My-Bucket-List-version-1/"/>
    <url>/2020/08/11/My-Bucket-List-version-1/</url>
    
    <content type="html"><![CDATA[<p>0.希望能为国家突破一些技术障碍</p><a id="more"></a><p>1.去俄罗斯游玩，再去伦敦的马克思墓地</p><p>2.帮助一个陌生人</p><p>3.对一个女生表白 and 亲吻世界上最美的女生</p><p>4.跑完一次马拉松</p><p>5.写出一个属于自己的纪念app/网页</p><p>6.去当国际志愿者 and 去联合国转转</p><p>7.见勒布朗 詹姆斯一面</p><p>8.开一次枪、坐直升机跳伞</p><p>9.把自己都捐了</p><p>…</p><p>正在努力的事情：</p><p>9.阅读马列主义书籍及其他世界名著</p><p>10.编程，进入ACM队</p><p>11.复习…</p><p>12.坚持跑步、锻炼</p><p>13.捐款</p><p>14.成为党员</p><p>15.保研到THU</p><p>16.能为国家硬件/软件做出自己的贡献</p>]]></content>
    
    
    <categories>
      
      <category>Bucket List</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Life</tag>
      
      <tag>Thinking</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

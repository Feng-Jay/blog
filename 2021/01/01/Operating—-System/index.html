

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;light&#34;>

<!--浏览器搞笑标题-->
<script type="text/javascript" src="/js/FunnyTitle.js"></script>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/eye.png">
  <link rel="icon" type="image/png" href="/img/eye.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="A Website for record my learning process.">
  <meta name="author" content="Feng Jay">
  <meta name="keywords" content="Blog Study Computer-science">
  <title>Linux-进程 - 在知识海洋中狗刨</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/atom-one-dark.min.css" />
    
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>FFeng's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于我
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/article.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-01-01 11:32" pubdate>
        2021年1月1日 中午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      8.1k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      118
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">Linux-进程</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2 分钟前
                
              </p>
            
            <div class="markdown-body" id="post-body">
              <p>Basic knowledge about OS &amp;&amp; Linux. Solutions about MIT 6.828</p>
<a id="more"></a>

<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h2><p>进程是一个正在执行程序的实例，包括了程序代码和它当前的状态（寄存器…）</p>
<p>一个进程包括三个部分</p>
<p><img src="/2021/01/01/Operating%E2%80%94-System/Process.png" srcset="/img/loading.gif" alt="process contains"></p>
<p><em>Tips: The differences between process and program</em></p>
<p><em>Program is just the static text</em></p>
<p><em>Process is an dynamic entity being executed and has lifecycle</em></p>
<p><em>So if a program exec two times ,there should be two processes</em></p>
<h2 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h2><p>四种事件会导致进程的创建:</p>
<p>1.系统初始化</p>
<p>2.正在运行的程序执行了创建进程的系统调用</p>
<p>3.用户请求创建一个新进程</p>
<p>4.批处理作业的初始化</p>
<p>新进程都是由一个已存在的进程执行了一个用于创建进程的系统调用而创建。</p>
<p>在Linux中，只有fork这个系统调用可用来创建进程。</p>
<p>fork后，创建的子进程会和父进程拥有相同的内存映像、环境变量。通常，子进程会接着执行一个execve之类的系统调用来修改内存映像从而运行一个新的程序。</p>
<h2 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h2><p>进程终止的条件：</p>
<p>1.正常退出(自愿的)</p>
<p>2.出错退出(自愿的) 自愿时通常调用exit系统调用</p>
<p>3.严重错误(非自愿)</p>
<p>4.被其他进程杀死(非自愿)//在Linux和Windows中，如果一个进程被杀死，但他创建的进程不会被全部杀死</p>
<h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><p><img src="/2021/01/01/Operating%E2%80%94-System/%E7%8A%B6%E6%80%81.png" srcset="/img/loading.gif" alt="进程状态"></p>
<p>处于阻塞状态的进程不会参与进程调度，处在运行和就绪状态的进程会在就绪队列中。</p>
<p>Running-&gt;Block：进程需要等待数据(自发)</p>
<p>Running-&gt;Ready：调度程序造成(优先级调度、时间片流转…)</p>
<p>Ready-&gt;Running：调度程序造成</p>
<p>Block-&gt;Ready：1.进程发起。2.OS发起。</p>
<h2 id="进程的生命周期"><a href="#进程的生命周期" class="headerlink" title="进程的生命周期"></a>进程的生命周期</h2><img src="/2021/01/01/Operating%E2%80%94-System/lifeline.png" srcset="/img/loading.gif" alt="image-20201114151211842" style="zoom: 67%;">

<p><strong>I (Idle) state</strong>（空闲状态）</p>
<p>进程在被创造前需要在进程/线程表中申请一个空间，这时处于SNONE状态</p>
<p>进程正在被创作时，需要向内存申请存储空间，此时处于SIDL状态。</p>
<p><strong>A (active) state</strong>（活跃状态）</p>
<p>当进程处于A状态时，他会有一个或多个线程处于R(ready to run)状态。这些线程必须和其他处于R态的线程共用CPU。CPU同时只能跑一个线程(不考虑多处理器)</p>
<p>当线程需要等待事件发生或者输入输出时，为了不浪费CPU，他会进入sleep状态并且放弃CPU使用权。当输入/输出结束，线程会被唤醒进入R状态。</p>
<p>线程可能会被一些信号终止或者开启。当线程被挂起时，他处于T状态，无法执行。</p>
<p><strong>Z (zombie) state</strong>（僵尸状态）</p>
<p>当一个进程死亡(结束）时，他会变成僵尸进程。</p>
<p>僵尸进程除了进程/线程表外不占用其他资源。他只会存活很短的时间，直到他的父进程发出信号，清理进线程表。</p>
<p>但是当一个进程的父进程先于子进程死亡时/或者无法发出信号时，就会在OS中留下僵尸进程。</p>
<p>如果OS长时间运行，进程表可能会被僵尸进程塞满，无法再开启新的进程(重启系统)。</p>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="我们为什么需要线程？"><a href="#我们为什么需要线程？" class="headerlink" title="我们为什么需要线程？"></a>我们为什么需要线程？</h2><p>进程模型的抽象让我们不必再考虑CPU中断，时钟周期，上下文切换之类的底层内容，只要考虑并行进程即可。</p>
<p>但对于很多进程来说，他们还需要一种能够共享存储空间与数据的能力(例如word文档，他需要有定时保存，同时修改多页内容等功能)</p>
<p>而且使用线程后可以将某些阻塞的活动(IO)的时间用来进行其他功能，可增大CPU利用率。</p>
<p>而且线程相对于进程来说是一个更加轻量级的模型，更容易被创建、结束。</p>
<p>典型的例子就是word、web服务器…</p>
<hr>
<p>在没有多线程的情况下，我们通过有限状态机这样的设计实现Web服务器</p>
<p>即使用非阻塞版本的系统调用来进行IO，再有需求进来时，会进行新工作。</p>
<p>在这种设计中，“顺序进程”模型消失了，但进程每次切换工作时都要将先前内容进行存储。</p>
<p>可以认为我们模拟了线程及其堆栈。</p>
<table>
<thead>
<tr>
<th align="center">模型</th>
<th align="center">特性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">多线程</td>
<td align="center">并行、阻塞系统调用</td>
</tr>
<tr>
<td align="center">单线程进程</td>
<td align="center">无并行性、阻塞系统调用</td>
</tr>
<tr>
<td align="center">有限状态机</td>
<td align="center">并行性、非阻塞系统调用、中断</td>
</tr>
</tbody></table>
<h2 id="经典线程、POSIX线程"><a href="#经典线程、POSIX线程" class="headerlink" title="经典线程、POSIX线程"></a>经典线程、POSIX线程</h2><img src="/2021/01/01/Operating%E2%80%94-System/传统线程.png" srcset="/img/loading.gif" alt="传统线程" style="zoom: 67%;">

<p>在图a中可以看到三个传统的进程，每个进程有自己的地址空间和一个控制线程。</p>
<p>图b中可以看到一个进程拥有三个控制线程，且运行在同一地址空间。</p>
<p>在多线程进程中，所有线程都共享完全一样的地址空间，也就是共享同样的全局变量，且线程之间是不存在保护的。</p>
 <img src="/2021/01/01/Operating%E2%80%94-System/进线程内容.png" srcset="/img/loading.gif" style="zoom:67%;">

<p>上图给出了进线程中所包含的内容。</p>
<p>有了线程的概念后，<strong>可以把进程当作资源管理的单位，线程当做执行的单位</strong>。</p>
<hr>
<p><strong>每个线程都有自己的堆栈</strong></p>
<p>假设有下面这样的情况：过程X调用Y，Y调用Z，当Z执行时，XYZ使用的栈帧都会存在堆栈中。而每个线程往往会执行不同的过程，这就让他们有各自不同的历史，也就是每个线程都要有自己的堆栈。</p>
<p><em>线程也可以创造线程，且线程间一般不会存在父子关系</em></p>
<hr>
<p><strong>POSIX线程</strong></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/dreams_deng/article/details/104201715">POSIX提供了很多系统调用来实现线程</a></p>
<p> 通过一个求PI的程序来说明。    </p>
<div class="hljs"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pthread.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span>

<span class="hljs-keyword">double</span> PI;
<span class="hljs-keyword">long</span> num_thread;
<span class="hljs-keyword">long</span> N;
<span class="hljs-keyword">double</span> tim;
<span class="hljs-keyword">pthread_t</span>* threads;
<span class="hljs-keyword">pthread_mutex_t</span> lock;

<span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">thread</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* ID)</span></span>
<span class="hljs-function"></span>&#123;      
	<span class="hljs-keyword">long</span> id=(<span class="hljs-keyword">long</span>)ID;
	<span class="hljs-keyword">int</span> length=N/num_thread;
	<span class="hljs-keyword">int</span> i;
	pthread_mutex_lock(&amp;lock);
	<span class="hljs-keyword">for</span>(i=id*length;i&lt;(id+<span class="hljs-number">1</span>)*length;i++)
	&#123;
		PI+=(<span class="hljs-number">4.0</span>/N)*(<span class="hljs-number">1.0</span>/(<span class="hljs-number">1</span>+((i+<span class="hljs-number">0.5</span>)/N)*((i+<span class="hljs-number">0.5</span>)/N)));
	&#125;
	pthread_mutex_unlock(&amp;lock);
&#125;      	


<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;       
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Please input the num of threads\n&quot;</span>);
	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%ld&quot;</span>,&amp;num_thread);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Please input the N of calculator\n&quot;</span>);
	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%ld&quot;</span>,&amp;N);
	<span class="hljs-keyword">clock_t</span> start,<span class="hljs-built_in">end</span>;
	start=clock();
	threads=(<span class="hljs-keyword">pthread_t</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">pthread_t</span>)*num_thread);
	<span class="hljs-keyword">long</span> i;
	<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;num_thread;i++)
	&#123;
        pthread_create(&amp;threads[i],<span class="hljs-literal">NULL</span>,thread,(<span class="hljs-keyword">void</span>*)i);
	&#125;
	<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;num_thread;i++)
	&#123;
	pthread_join(threads[i],<span class="hljs-literal">NULL</span>);
	&#125;
	<span class="hljs-built_in">end</span>=clock();
	tim=(<span class="hljs-keyword">double</span>)(<span class="hljs-built_in">end</span>-start)/CLOCKS_PER_SEC;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Running Time: %fs\n&quot;</span>,tim);
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;PI= %.15f\n&quot;</span>,PI);
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;  
</code></pre></div>



<h2 id="在用户-内核中实现线程"><a href="#在用户-内核中实现线程" class="headerlink" title="在用户/内核中实现线程"></a>在用户/内核中实现线程</h2><p><strong>1.在用户空间实现线程</strong></p>
<p>此时内核并没有线程的概念，他仍然只会对进程进行调度。此时线程的实现需要用户级程序去完成。</p>
<p>其实现大都使用pthread的系统调用。</p>
<p>同时，在用户空间管理线程时，每个进程也要有对应的线程表来记录进程中的线程。</p>
<p><strong>优点：</strong></p>
<p><strong>1.线程间切换很快</strong></p>
<p>当一个线程引发了自己的阻塞，那么他就会存储自己的状态，并在线程表中查看可运行的线程，将新线程的保存值重新装入机器的寄存器中。</p>
<p>因此，只要堆栈指针和程序计数器一被切换，新的线程就会自动运行。</p>
<p>这样的切换要比陷入内核来说更快。</p>
<p><strong>2.每个进程可以有自己的调度算法，且扩展性强</strong></p>
<p>可让用户程序自定义线程的运行状态。内核线程需要一些固定的表格空间和堆栈，如果内核线程数量很大就会出现问题。</p>
<hr>
<p><strong>缺点：</strong></p>
<p>1.如何实现阻塞系统调用</p>
<p>线程的目标是允许每个线程使用阻塞调用，且要避免被阻塞的线程影响其他线程。</p>
<p>2.starvation问题</p>
<p>如果一个线程开始运行，那么在该进程中的其他线程都无法运行。除非该线程主动放弃CPU。</p>
<p>由于在进程中不会有中断的概念，所以无法使用轮转调度的方法调度线程。</p>
<p>3.最大问题出现在本身</p>
<p>程序员通常会在经常发生线程阻塞的应用中才希望使用多线程。</p>
<p>但在一个服务器中，线程一直在进行着系统调用，如果原有线程阻塞，就很难让内核进行线程切换。否则就一直使用select系统调用。</p>
<p>但这样的话多线程的意义就不大了，并没有什么实质性的好处。</p>
<h1 id="调度程序-Important"><a href="#调度程序-Important" class="headerlink" title="调度程序(Important)"></a>调度程序(Important)</h1><p>在计算机中，如果有多个进程处于就绪状态，而只有一个CPU可用，那么OS就必须对下一个要运行的进程进行选择。完成这个工作的就是调度程序。</p>
<p>早期的批处理系统中的调度程序就是：顺序执行磁带上的每一个作业。由于那时CPU是稀缺资源，所以调度程序的作用十分重要。</p>
<p>但随着PC的普及以及CPU速度的快速增长，OS中多数时间只有一个活动进程，而且时间大多花费在等待用户输入，而非等待CPU计算。</p>
<p>但在Web服务器中，经常会有多个进程抢占CPU，此时的调度程序又十分重要。</p>
<p><strong>为什么要好的调度程序？</strong></p>
<p>因为进程切换的代价是十分高昂的：要先从用户态切换到内核态；保存进程状态；调度选择新进程；将新进程的内存印象装入MMU，开始运行。</p>
<p>如果调度程序每秒切换进程次数太多，会耗费大量CPU时间。</p>
<h2 id="何时调度进程？"><a href="#何时调度进程？" class="headerlink" title="何时调度进程？"></a>何时调度进程？</h2><p>1.在创建一个新进程后，需要决定是运行父进程还是子进程</p>
<p>2.在一个进程退出时必须调度</p>
<p>3.进程阻塞时必须调度</p>
<p>4.一个IO中断发生时必须调度</p>
<h2 id="调度算法分类及其目标"><a href="#调度算法分类及其目标" class="headerlink" title="调度算法分类及其目标"></a>调度算法分类及其目标</h2><p>对于所有系统，使用调度程序的目标都是要实现：公平(每个进程有公平的CPU份额)、策略强制执行(规定的策略被执行)、平衡(系统的所有部分都忙碌)</p>
<p>在不同系统中，需要的调度程序的类型、目标也不同，可划分为三组环境：</p>
<p>1.批处理(Batch System)</p>
<p>其目标要实现：吞吐量、周转时间、CPU利用率的最优。</p>
<p>2.交互式(Interactive System)</p>
<p>其目标为：实现响应时间、均衡性的最优。</p>
<p>3.实时(Real-time System)</p>
<p>其目标为：满足截止时间(避免丢失数据)、可预测性</p>
<h2 id="批处理系统中的调度-Important"><a href="#批处理系统中的调度-Important" class="headerlink" title="批处理系统中的调度(Important)"></a><font color="red">批处理系统中的调度(Important)</font></h2><h3 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h3><p>按照进程请求CPU的顺序来使用CPU。类似于队列的FIFO机制，优点在于公平且思路简单。</p>
<p>但缺点也很明显：<strong>护航效应</strong>。</p>
<p>假如此时有一个CPU密集型和一个IO密集型的进程在就绪队列中，CPU密集型的进程在CPU中执行一段时间，进入IO；此时IO密集型进程进入CPU，执行很短很短的时间也进入IO；此时CPU空闲，CPU密集型进程再次进入就绪队列，IO进程又会等待CPU密集型进程完成。</p>
<p>可以看到，在这种情况下，IO进程总是在等待着计算密集型进程使用完CPU，从而导致运行时间很长。</p>
<p>如果有可能让IO进程直接单独抢占一段时间，那么运行时间会大大减少。</p>
<p><em>可通过下图理解进程执行的过程，并不是一直使用CPU然后一直使用IO就结束了，而是交错着的</em></p>
<img src="/2021/01/01/Operating%E2%80%94-System/密集型.png" srcset="/img/loading.gif" style="zoom:50%;">

<h3 id="最短作业优先"><a href="#最短作业优先" class="headerlink" title="最短作业优先"></a>最短作业优先</h3><p><em>由于需要知道运行时间，因此多用于专用OS，但可能出现starvation问题</em></p>
<h3 id="最短剩余时间优先"><a href="#最短剩余时间优先" class="headerlink" title="最短剩余时间优先"></a>最短剩余时间优先</h3><p><em>由于需要知道剩余运行时间，只能在专用OS使用</em></p>
<h3 id="高响应比优先"><a href="#高响应比优先" class="headerlink" title="高响应比优先"></a>高响应比优先</h3><p>响应比的计算:Response Radio = Turnaround time / Executing time = 1 + Waiting Time/ Executing Time</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>在一单道批处理系统中，一组作业的提交时刻和运行时间如下表所示。试计算一下三种作业调度算法的平均周转时间 T 和平均带权周转时间 W。 (1) 先来先服务; (2) 短作业优先 (3) 高响应比优先。作业提交时刻和运行时间如下表</p>
<p><img src="/2021/01/01/Operating%E2%80%94-System/%E4%BE%8B%E9%A2%98.png" srcset="/img/loading.gif" alt="例题"></p>
<p>1.先来先服务</p>
<p>根据题目可得到以下数据</p>
<table>
<thead>
<tr>
<th>作业</th>
<th>提交时刻</th>
<th>运行时间</th>
<th align="left">开始时间</th>
<th>完成时间</th>
<th>周转时间</th>
<th>带权周转时间</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>8.0</td>
<td>1.0</td>
<td align="left">8.0</td>
<td>9.0</td>
<td>1.0</td>
<td>1.0</td>
</tr>
<tr>
<td>2</td>
<td>8.5</td>
<td>0.5</td>
<td align="left">9.0</td>
<td>9.5</td>
<td>1.0</td>
<td>2.0</td>
</tr>
<tr>
<td>3</td>
<td>9.0</td>
<td>0.2</td>
<td align="left">9.5</td>
<td>9.7</td>
<td>0.7</td>
<td>3.5</td>
</tr>
<tr>
<td>4</td>
<td>9.1</td>
<td>0.1</td>
<td align="left">9.7</td>
<td>9.8</td>
<td>0.7</td>
<td>7.0</td>
</tr>
</tbody></table>
<p>所以平均周转时间T=(1.0+1.0+0.7+0.7)/4=0.85</p>
<p>平均带权周转时间W=(1.0+2.0+3.5+7.0)/4=3.375</p>
<p>2.短作业优先</p>
<p>可知在8.0时系统中只有作业1，所以作业1仍为第一个执行的。</p>
<p>作业1执行完成时间为9.0</p>
<p>此时系统中有作业2,3两个作业，短作业优先选择作业3</p>
<p>作业3执行完成时间为9.2</p>
<p>此时系统中有作业2,4两个作业，短作业优先选择作业4</p>
<p>作业4执行完成时间为9.3</p>
<p>此时只有作业2</p>
<p>作业2执行完成时间为9.8</p>
<p>表格如下</p>
<table>
<thead>
<tr>
<th>作业</th>
<th>提交时刻</th>
<th>运行时间</th>
<th align="left">开始时间</th>
<th>完成时间</th>
<th>周转时间</th>
<th>带权周转时间</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>8.0</td>
<td>1.0</td>
<td align="left">8.0</td>
<td>9.0</td>
<td>1.0</td>
<td>1.0</td>
</tr>
<tr>
<td>3</td>
<td>9.0</td>
<td>0.2</td>
<td align="left">9.0</td>
<td>9.2</td>
<td>0.2</td>
<td>1.0</td>
</tr>
<tr>
<td>4</td>
<td>9.1</td>
<td>0.1</td>
<td align="left">9.2</td>
<td>9.3</td>
<td>0.2</td>
<td>2.0</td>
</tr>
<tr>
<td>2</td>
<td>8.5</td>
<td>0.5</td>
<td align="left">9.3</td>
<td>9.8</td>
<td>1.3</td>
<td>2.6</td>
</tr>
</tbody></table>
<p>可以得到</p>
<p>平均周转时间T=(1+0.2+0.2+1.3)/4=0.675</p>
<p>平均带权周转时间W=(1.0+1.0+2.0+2.6)/4=1.65</p>
<p>3.高响应比优先</p>
<p>同样8.0时系统只有作业1，执行作业1</p>
<p>作业1执行完成时间为9.0</p>
<p>此时系统中有作业2,3</p>
<p>此时作业2 response radio=(1+0.5/0.5)=2; 作业3 response radio=1</p>
<p>所以先执行作业2</p>
<p>作业2执行完成时间为9.5</p>
<p>此时系统中有作业3,4</p>
<p>此时作业3的response radio=(1+0.5/0.2)=3.5</p>
<p>作业4的response radio =（1+0.4/0.1）=5</p>
<p>所以先执行作业4</p>
<p>作业4执行完时间为9.6</p>
<p>执行作业3</p>
<p>执行完成时间为9.8</p>
<p>可列为如下表格</p>
<table>
<thead>
<tr>
<th>作业</th>
<th>提交时刻</th>
<th>运行时间</th>
<th align="left">开始时间</th>
<th>完成时间</th>
<th>周转时间</th>
<th>带权周转时间</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>8.0</td>
<td>1.0</td>
<td align="left">8.0</td>
<td>9.0</td>
<td>1.0</td>
<td>1.0</td>
</tr>
<tr>
<td>2</td>
<td>8.5</td>
<td>0.5</td>
<td align="left">9.0</td>
<td>9.5</td>
<td>1.0</td>
<td>2.0</td>
</tr>
<tr>
<td>4</td>
<td>9.1</td>
<td>0.1</td>
<td align="left">9.5</td>
<td>9.6</td>
<td>0.5</td>
<td>5.0</td>
</tr>
<tr>
<td>3</td>
<td>9.0</td>
<td>0.2</td>
<td align="left">9.6</td>
<td>9.8</td>
<td>0.8</td>
<td>4.0</td>
</tr>
</tbody></table>
<p>可知平均周转时间T=(1+1+0.5+0.8)/4=0.825</p>
<p>平均带权周转时间W=(1+2+5+4)/4=3</p>
<h3 id="区分一下带权周转时间和响应比的概念"><a href="#区分一下带权周转时间和响应比的概念" class="headerlink" title="区分一下带权周转时间和响应比的概念"></a>区分一下带权周转时间和响应比的概念</h3><p><strong>二者虽然看上去计算公式相同，但他们的性质是不同的</strong></p>
<p><strong>带权周转时间是在调度完成后评价该调度程序的一个指标，是静态的</strong></p>
<p><strong>而响应比是作为调度的一个条件来使用的，每当调度一次后，每个作业的响应比都会变化。是动态的。</strong></p>
<h2 id="交互式系统中的调度-Important"><a href="#交互式系统中的调度-Important" class="headerlink" title="交互式系统中的调度(Important)"></a><font color="red">交互式系统中的调度(Important)</font></h2><h3 id="Round-robin-scheduling-轮转调度"><a href="#Round-robin-scheduling-轮转调度" class="headerlink" title="Round-robin scheduling (轮转调度)"></a>Round-robin scheduling (轮转调度)</h3><p>这是最简单、公平、使用最广的调度算法.</p>
<p>每个进程被分配一个<strong>时间片</strong>，即允许该进程在该时间段中运行。如果进程在时间片结束时还在运行，那就夺走CPU分配给下一个进程。如果进程在时间片结束前就完成或者阻塞，CPU就立即进行切换。</p>
<p>调度程序要做的就是维护一个可运行程序列表，并对使用完时间片的程序进行调整。</p>
<p><strong>唯一要考虑的就是时间片的长度</strong></p>
<p>时间片太短会导致进程切换过于频繁，降低CPU效率。太长又会引起对短的交互请求的不响应。</p>
<p>常将时间片设置在20~50ms之间</p>
<h3 id="Priority-scheduling-优先级调度"><a href="#Priority-scheduling-优先级调度" class="headerlink" title="Priority scheduling (优先级调度)"></a>Priority scheduling (优先级调度)</h3><p>在Round-robin中，我们把每个进程都看作同等重要，而优先级调度就是要改变这种想法，给每个进程赋予一个优先级，优先级高的进程会先运行。</p>
<p>为了防止高优先级进程一直运行下去，调度程序可能在每个时钟中断时降低其优先级，如果有高于其的进程，就开始调度。</p>
<p>也可以给每个进程设置一个允许允许的最大时间片，超过时间片后次高级进程就会运行。</p>
<img src="/2021/01/01/Operating%E2%80%94-System/优先级.png" srcset="/img/loading.gif" style="zoom:67%;">

<h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><h3 id="用户态线程"><a href="#用户态线程" class="headerlink" title="用户态线程"></a>用户态线程</h3><p>内核并不知道线程的存在，因此还是会直接对线程使用调度程序。</p>
<p>此时由进程中的线程调度程序来决定线程的运行。由于这里面并不存在时钟中断，所以线程可以按其意愿任意运行直到进程时间用完。</p>
<h3 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h3><p>此时内核选择特定的线程运行，且不用考虑线程属于哪个进程。可以分配时间…</p>
<p>&nbsp;</p>
<p>二者的差别主要在于性能。</p>
<p>用户级线程的切换只需要少量指令，但内核级线程切换需要上下文切换,修改内存，高速缓存…</p>
<p>但内核级线程如果阻塞，并不用直接将整个进程挂起。</p>
<p><em>另外，从A的线程切换到B的线程的代价高于在一个进程中切换线程，因此，在有多种选择的情况下，倾向于在相同进程中切换线程。</em></p>
<h1 id="进程间通信（Inter-Process-Communication-IPC）"><a href="#进程间通信（Inter-Process-Communication-IPC）" class="headerlink" title="进程间通信（Inter Process Communication, IPC）"></a><font color="red">进程间通信（Inter Process Communication, IPC）</font></h1><p>进程间往往需要相互传递信息（例如你使用shell中的管道，她将一个进程的输出传递给另一个进程）。</p>
<h2 id="IPC的三个问题"><a href="#IPC的三个问题" class="headerlink" title="IPC的三个问题"></a>IPC的三个问题</h2><ol>
<li>一个进程如何把信息传递给另一个。</li>
<li>如何确保两个/多个进程在关键活动中不会出现交叉。（比如12306的购票系统）</li>
<li>如何确保多个进程之间有正确的执行顺序（一个更改数据的操作和一个print操作，当数据更改后再print才是正确的）</li>
</ol>
<p><strong>下面我们来解决这三个问题</strong></p>
<h2 id="基础概念（竞争条件-amp-临界区）"><a href="#基础概念（竞争条件-amp-临界区）" class="headerlink" title="基础概念（竞争条件&amp;临界区）"></a>基础概念（竞争条件&amp;临界区）</h2><p><strong>竞争条件</strong>：<strong>多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序的情况</strong>。</p>
<p>我们要实现IPC就要思考如何避免竞争条件？</p>
<p>关键是使用一种方法来<strong>阻止多个进程同时读写共享的数据</strong>。即实现<strong>mutual exclusion</strong>（互斥）：一个进程使用共享数据时，其他进程不能做同样的操作。</p>
<p>我们可以把阻止多进程同时读写共享数据的问题进行抽象，把对共享内存进行访问的<strong>程序片段</strong>称为<strong>临界区域/临界区</strong>（critical region）。</p>
<p>All we need to do is 是<strong>两个进程不可能同时处于临界区。</strong></p>
<p>更进一步，为了确保进程能够正确且高效地协作，我们对于一个好的解决方法<strong>提出4个要求：</strong></p>
<p><strong>1）任何两个进程不能同时在临界区中</strong></p>
<p>2）不对CPU的速度和数量做任何假设</p>
<p><strong>3）临界区外运行的进程不得阻塞其他进程</strong></p>
<p>4）不得使进程无限期等待进入临界区</p>
<hr>
<h2 id="忙等待-busy-waiting-的互斥"><a href="#忙等待-busy-waiting-的互斥" class="headerlink" title="忙等待(busy waiting)的互斥"></a>忙等待(busy waiting)的互斥</h2><p>本部分可行的解决方案都有一个<strong>特征</strong>：在无法进入临界区时，他们都会<strong>持续地占据CPU时间直到被调度（不会主动放弃）</strong>。所以称为busy waiting。</p>
<h3 id="一、屏蔽中断"><a href="#一、屏蔽中断" class="headerlink" title="一、屏蔽中断"></a>一、屏蔽中断</h3><p><strong>这是最简单粗暴的方法</strong></p>
<p>对于单处理器来说，在进程进入临界区后立即屏蔽所有中断，在离开前打开中断是最直接的方法。因为屏蔽中断后，时钟中断也被屏蔽——CPU不会调度其他进程。</p>
<p>其<strong>缺点</strong>在于给了<strong>用户程序太大的权力</strong>，一旦一个进程不再打开中断，那么整个OS/多核中的一个核就会终止运行。</p>
<p>屏蔽中断对于OS来说很好，在更新数据时屏蔽中断可以确保短时间内完成，同时也确保执行的正确。</p>
<p>总的来说：屏蔽中断对OS来说很有用，但对于用户程序来说并不是一个明智的解决方法。</p>
<h3 id="二、锁变量"><a href="#二、锁变量" class="headerlink" title="二、锁变量"></a>二、锁变量</h3><p>一种软件解决方法。设置一个共享锁变量，进入临界区前要先开锁才能进入。</p>
<p>但这种解决方法是不行的，只是一个<strong>套娃的方法</strong>。设想下面的情况：</p>
<p>如果一个进程在读锁变量为0后，在准备将其<strong>设置为1之前被调度</strong>；新调度的<strong>进程将其设置为1</strong>，<strong>进入临界区</strong>。</p>
<p>此时再返回第一个进程，他也会将锁变量设为1，也进入临界区。</p>
<p>此时临界区中有两个程序。</p>
<p>So，这种方法只<strong>是转移了矛盾，并没有根本解决矛盾</strong>。</p>
<h3 id="三、严格轮换法"><a href="#三、严格轮换法" class="headerlink" title="三、严格轮换法"></a>三、严格轮换法</h3><div class="hljs"><pre><code class="hljs cpp">
<span class="hljs-keyword">int</span> turn=<span class="hljs-number">0</span>;
<span class="hljs-comment">/*进程 0*/</span>
<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)
&#123;
    <span class="hljs-keyword">while</span>(turn!=<span class="hljs-number">0</span>)
    critical_region();
    turn=<span class="hljs-number">1</span>;
    noncritical_region();
&#125;
<span class="hljs-comment">/*进程 1*/</span>
<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)
&#123;
    <span class="hljs-keyword">while</span>(turn!=<span class="hljs-number">1</span>)
    critical_region();
    turn=<span class="hljs-number">0</span>;
    noncritical_region();
&#125;</code></pre></div>

<p><em>功能描述：</em> 进程0首先检查turn为0，进入临界区；进程1检查turn为0，执行循环一直检查turn直至为1.（busy waiting!）</p>
<p><em>但这种解法也是存在问题的。</em></p>
<p>如果进程0是一个临界区密集型进程，进程1是一个非临界区密集型进程。</p>
<p>当进程0结束临界区操作，将turn设置为1。进程0迅速完成非临界区操作，而进程1正在忙于非临界区操作。此时进程0无法进入临界区(此时turn==1),进程1也不进入临界区。</p>
<p>这就<strong>违背了前面4个要求中的第3个：进程0被在临界区外的进程1阻塞无法进入临界区。</strong></p>
<p><strong>说明在一个进程比另一个慢得多的情况下，该严格轮换法并不太好。</strong></p>
<h3 id="四、Peterson解法-针对两个进程"><a href="#四、Peterson解法-针对两个进程" class="headerlink" title="四、Peterson解法   (针对两个进程)"></a>四、Peterson解法   (针对两个进程)</h3><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FALSE 0</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TRUE 1</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 2 <span class="hljs-comment">//进程数量</span></span>

<span class="hljs-keyword">int</span> turn; <span class="hljs-comment">//轮到谁？</span>

<span class="hljs-keyword">int</span> interested[N]=&#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">//所有值初始化为0</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enter_region</span><span class="hljs-params">(<span class="hljs-keyword">int</span> process)</span><span class="hljs-comment">/*进程号*/</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">int</span> other;					    <span class="hljs-comment">/*另一进程号*/</span>
    other=<span class="hljs-number">1</span>-process;				
    interested[process]=TRUE;		<span class="hljs-comment">/*表示感兴趣*/</span>
    turn = process;					<span class="hljs-comment">/*设置标志*/</span>
    <span class="hljs-keyword">while</span>(turn==process&amp;&amp;interested[other]==TRUE); <span class="hljs-comment">/*空语句*/</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">leave_region</span><span class="hljs-params">(<span class="hljs-keyword">int</span> process)</span> 		<span class="hljs-comment">/*离开的进程*/</span></span>
<span class="hljs-function"></span>&#123;
    interested[process]=FALSE;		<span class="hljs-comment">/*离开临界区*/</span>
&#125;</code></pre></div>

<p>在<strong>进入临界区之前</strong>，各个进程使用自己的进程号（0/1）**调用enter_region()**。</p>
<p>在<strong>完成临界区操作</strong>后，**调用leave_region()**。</p>
<p>即当turn==自己 且 另一个进程没有离开临界区时，自己不能进入。</p>
<p>如果两个进程几乎同时调用enter_region, 但进程0比1先存turn，那么最后turn==1。此时进程0可以进入临界区，进程1只能等待。</p>
<p><strong>Attention：enter_region中的 turn 和 interest 设置顺序不能颠倒</strong></p>
<p>假设现在已经颠倒 <em>变成酱紫 ↓↓↓</em></p>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enter_region</span><span class="hljs-params">(<span class="hljs-keyword">int</span> process)</span><span class="hljs-comment">/*进程号*/</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">int</span> other;					    <span class="hljs-comment">/*另一进程号*/</span>
    other=<span class="hljs-number">1</span>-process;			
    turn = process;					<span class="hljs-comment">/*设置标志*/</span>
    interested[process]=TRUE;		<span class="hljs-comment">/*表示感兴趣*/</span>
    <span class="hljs-keyword">while</span>(turn==process&amp;&amp;interested[other]==TRUE); <span class="hljs-comment">/*空语句*/</span>
&#125;</code></pre></div>

<p>如果进程0在将turn设置为0后被调度，进程1发现进程0没有interested，进入临界区。</p>
<p>此时调度回进程0，进程0发现turn！=0, 进入临界区。</p>
<p>此时有两个进程同时在临界区里，so… 出问题了。</p>
<p><strong>进一步，我们思考一下peterson算法背后的思想以及为什么交换顺序后就不行</strong></p>
<p>peterson算法的思想就是：类似孔融让梨，<strong>使用一个数组来表达每个进程想进入临界区的意图。每个进程要先表明自己的意图。最后一个进程要“让梨”，即如果turn是自己且对方想进入临界区，那自己就等待，让对方使用。</strong></p>
<p>那么我们交换顺序后，就会出现一种情况：对方还没来得及表明意图，另一个进程就抢先看自己让不让梨（有些虚伪的感觉），结果对方还没说话你就抢过来话筒当然就不用让了，直接进入临界区。但此时对方却认为另一个人会让梨，于是自己也进入临界区。</p>
<p>so…. 就出现了如此的尴尬局面。</p>
<h3 id="五、TSL指令"><a href="#五、TSL指令" class="headerlink" title="五、TSL指令"></a>五、TSL指令</h3><p><strong>这是一种硬件支持方案</strong></p>
<div class="hljs"><pre><code class="hljs bash">TSL RX, LOCK</code></pre></div>

<p>称为测试并加锁(test and set lock) 是一个<strong>原语操作</strong>，作用是将一个内存字lock读到寄存器RX中，同时写lock=1。然后在该内存地址上存一个非零值。</p>
<p>执行TSL指令的CPU将<strong>锁住内存总线</strong>，禁止其他CPU在本指令结束前访问内存。</p>
<div class="hljs"><pre><code class="hljs bash">enter_region:
	TSL REGISTER,LOCK		|复制锁到寄存器并将锁设为1
	CMP REGISTER,<span class="hljs-variable">$0</span>	 		|判断锁是否为0
	JNE enter_region		|若非0，说明锁已被设置，进入busy waiting的循环
	RET
leave_region:
	MOVE LOCK,<span class="hljs-variable">$0</span>			|锁中存0
	RET				        |<span class="hljs-built_in">return</span></code></pre></div>

<p>与peterson的使用类似</p>
<p>在进入临界区前，调用enter_region，将导致busy waiting直到锁空闲为止。</p>
<p>在离开临界区时，调用leave_region，将lock设置为0；</p>
<p>在intel的指令集中也有这样的操作：XCHG</p>
<h2 id="睡眠与唤醒（Sleep-and-wakeup）的互斥"><a href="#睡眠与唤醒（Sleep-and-wakeup）的互斥" class="headerlink" title="睡眠与唤醒（Sleep and wakeup）的互斥"></a>睡眠与唤醒（Sleep and wakeup）的互斥</h2><p>peterson算法和TSL解法都是正确的，但他们都有忙等待的缺点——不仅会浪费时间，还会可能引起意外的结果。</p>
<p>设想一台计算机有两个进程：H与L，H优先级高于L。调度规则是：只要H处于就绪状态就可运行。若此时，L在critical region 那么H就处于就绪态，开始busy waiting。但由于H就绪时，L不会被调度(OS认为H就绪时就会运行，而且H优先级高于L，因此OS也不会主动对运行的H进行调度)，L也就无法离开临界区。H将永远等待下去。</p>
<p>上述情况称为 <strong>优先级反转问题</strong>。</p>
<p>所以，我们需要一种新的不同于busy waiting的解决方案来进行IPC。</p>
<p><strong>所以有了sleep和wakeup这几条IPC原语，他们在无法进入临界区时将阻塞而不是busy waiting</strong></p>
<p>sleep是一个引起调用进程阻塞的系统调用，即背挂起，直到被其他进程唤醒。</p>
<p>wakeup就是唤醒的进程咯QWQ！</p>
<p><em>呜，2021/1/1日的早上图书馆是真没人啊，哈哈哈哈，好喜欢这种感觉！！！哈哈哈哈哈哈哈哈哈哈！</em></p>
<p>使用sleep和wakeup来解决一下生产者-消费者问题。</p>
<p>问题描述：两个进程共享一个公共的固定大小的缓冲区，其中一个是<strong>生产者</strong>：将信息放入缓冲区。另一个是<strong>消费者</strong>：从缓冲区中读取信息。</p>
<p>要解决的主要问题是<strong>当缓冲区已满，生产者无法在放入新数据，让他睡眠。当缓冲区为空时，消费者睡眠直到生产者向其中放入一些数据后再将其唤醒。</strong></p>
<p><em>code here ↓↓↓</em></p>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 100</span>
<span class="hljs-keyword">int</span> count=<span class="hljs-number">0</span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">producer</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">int</span> item;
    <span class="hljs-keyword">while</span>(TRUE)&#123;
        item=produce_item();
        <span class="hljs-keyword">if</span>(count==N)
        sleep();
        insert_item(item);
        count=count+<span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span>(count==<span class="hljs-number">1</span>)
        wakeup(consumer);
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">int</span> item;
    <span class="hljs-keyword">while</span>(TRUE)&#123;
        <span class="hljs-keyword">if</span>(count==<span class="hljs-number">0</span>)
        sleep();
        item=remove_item();
        count=count<span class="hljs-number">-1</span>;
        <span class="hljs-keyword">if</span>(count==N<span class="hljs-number">-1</span>)
        wakeup(producer);
        consume_item(item);
    &#125;
&#125;</code></pre></div>

<p><strong>但这里还是会有竞争条件的——因为没有对count访问加限制。</strong>设想下面这种情况：</p>
<p>缓冲区为空，消费者发现count==0，正准备sleep并叫醒生产者。但OS此时调度生产者，生产者产生数据，count=1。生产者认为消费者现在一定在sleep，于是wakeup他，但此时消费者并没有睡眠。所以造成了一个wakeup信号丢失。</p>
<p>当消费者下次运行时，直接睡眠，生产者在数据产生完后也睡眠。</p>
<p>emmm，他们就这样一起睡下去了。</p>
<p><em>一种简单的解决方法是给消费者加一个唤醒等待位。类似spooling，就是wakeup信号的一个存储区。</em></p>
<h1 id="信号量-Semaphore-的互斥与同步"><a href="#信号量-Semaphore-的互斥与同步" class="headerlink" title="信号量(Semaphore)的互斥与同步"></a><font color="red">信号量(Semaphore)的互斥与同步</font></h1><p>信号量是0或者大于0的整数。</p>
<p>信号量只能被PV操作控制 (初始化除外；即使只想要读信号量的值也要通过PV)</p>
<p><em>PV操作是原子操作</em>&emsp;</p>
<p>P操作检查信号量，若大于0则将其减1。若等于0，则进程睡眠。</p>
<p>V操作对信号量的值增加1。</p>
<p><strong>PV在睡眠—唤醒中的实现</strong></p>
<div class="hljs"><pre><code class="hljs c++"><span class="hljs-comment">/*P operation*/</span>
P(Semaphore S)
&#123;
	S=S<span class="hljs-number">-1</span>;
    <span class="hljs-keyword">if</span>(S&lt;<span class="hljs-number">0</span>)&#123;
        added to the semaphore<span class="hljs-number">&#x27;</span>s <span class="hljs-built_in">queue</span> <span class="hljs-keyword">and</span> sleep;
    &#125;
&#125;

<span class="hljs-comment">/*V operation*/</span>
V(Semaphore S)
&#123;
    S=S+<span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span>(S&lt;<span class="hljs-number">0</span>)&#123;
        wake up waiting <span class="hljs-built_in">process</span> in the semaphore<span class="hljs-number">&#x27;</span>s <span class="hljs-built_in">queue</span>;
    &#125;
&#125;</code></pre></div>

<p><strong>PV在忙等待中的实现</strong></p>
<div class="hljs"><pre><code class="hljs c++"><span class="hljs-comment">/*P operation*/</span>
P(Semaphore S)
&#123;
    <span class="hljs-keyword">while</span>(!S&gt;<span class="hljs-number">0</span>)
    <span class="hljs-built_in">yield</span> the CPU;
    S--;
&#125;

<span class="hljs-comment">/*V operation*/</span>
V(Semaphore S)
&#123;
    S++;
&#125;</code></pre></div>



<h1 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a><font color="red">生产者消费者问题</font></h1><p>两个进程共享一个公共的固定大小的缓冲区，其中一个是生产者：将信息放入缓冲区；另一个是消费者：从缓冲区中读取信息。主要是解决<strong>当缓冲区已满，生产者无法在放入新数据，让他睡眠。当缓冲区为空时，消费者睡眠直到生产者向其中放入一些数据后再将其唤醒。</strong></p>
<p>下面给出一份使用信号量的代码</p>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 100</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> semaphore;

semaphore mutex=<span class="hljs-number">1</span>;
semaphore empty=N;
semaphore full=<span class="hljs-number">0</span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">producer</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">int</span> item;
    <span class="hljs-keyword">while</span>(TRUE)&#123;
        item=prodece_item();<span class="hljs-comment">//产生数据</span>
        P(&amp;empty);			<span class="hljs-comment">//空槽--</span>
        P(&amp;mutex);			<span class="hljs-comment">//进入临界区</span>
        inster_item();		<span class="hljs-comment">//数据放入临界区</span>
        V(&amp;mutex);			<span class="hljs-comment">//离开临界区</span>
        V(&amp;full);			<span class="hljs-comment">//满槽++</span>
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">int</span> item;
    <span class="hljs-keyword">while</span>(TRUE)&#123;
        P(&amp;full);		<span class="hljs-comment">//满槽--</span>
        P(&amp;mutex);		<span class="hljs-comment">//进入临界区</span>
        item=remove_item();		<span class="hljs-comment">//从缓冲区读出数据</span>
        V(&amp;mutex);		<span class="hljs-comment">//离开临界区</span>
        V(&amp;empty);		<span class="hljs-comment">//空槽++</span>
        consume_item(item);		<span class="hljs-comment">//处理数据</span>
    &#125;
&#125;</code></pre></div>



<h1 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a><font color="red">哲学家就餐问题</font></h1><div class="hljs"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 5 <span class="hljs-comment">/*哲学家数目*/</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LEFT (i+N-1)%N <span class="hljs-comment">/*i的左邻居编号*/</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> RIGHT (i+1)%N <span class="hljs-comment">/*i的右邻居编号*/</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> THINKING 0 <span class="hljs-comment">/*哲学家在思考*/</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> HUNGRY 1 <span class="hljs-comment">/*哲学家试图拿起叉子*/</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> EATING 2 <span class="hljs-comment">/*哲学家进餐*/</span></span>

<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> semaphore;

<span class="hljs-keyword">int</span> state[N];<span class="hljs-comment">/*记录每位哲学家的状态*/</span>
semaphore mutex=<span class="hljs-number">1</span>;<span class="hljs-comment">/*临界区互斥*/</span>
semaphore s[N];<span class="hljs-comment">/*每个哲学家一个信号量*/</span>

<span class="hljs-comment">/*检查哲学家是否可以就餐*/</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i<span class="hljs-comment">/*每个哲学家编号*/</span>)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">if</span>(state[i]==HUNGRY&amp;&amp;state[LEFT]!=EATING&amp;&amp;state[RIGHT]!=EATING)&#123;
        state[i]=EATING;
        V(&amp;s[i]);
    &#125;
&#125;
<span class="hljs-comment">/*拿叉子，一次拿两个*/</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">take_forks</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>
<span class="hljs-function"></span>&#123;
    P(&amp;mutex);
    state[i]=HUNGRY;<span class="hljs-comment">/*记录哲学家i处于饥饿状态*/</span>
    test(i);	<span class="hljs-comment">/*尝试获取两把叉子*/</span>
    V(&amp;mutex);	
    P(&amp;s[i]);	<span class="hljs-comment">/*得不到需要的叉子就阻塞*/</span>
&#125;
<span class="hljs-comment">/*放下叉子*/</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">put_forks</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>
<span class="hljs-function"></span>&#123;
    P(&amp;mutex);
    state[i]=THINKING;<span class="hljs-comment">/*哲学家就餐完毕*/</span>
    test(LEFT);
    test(RIGHT);<span class="hljs-comment">/*检查左右是否可吃*/</span>
    V(&amp;mutex);
&#125;

<span class="hljs-comment">/*主函数*/</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">philosopher</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;
        think();
        take_forks(i);<span class="hljs-comment">/*获取两把叉子或阻塞*/</span>
        eat();
        put_forks(i);<span class="hljs-comment">/*放回两把叉子*/</span>
    &#125;
&#125;</code></pre></div>

<h1 id="读者—写者问题"><a href="#读者—写者问题" class="headerlink" title="读者—写者问题"></a><font color="red">读者—写者问题</font></h1><p>解决多个进程读写数据的情况：读者无互斥，读写，写写，有互斥。</p>
<div class="hljs"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> semaphore;
semaphore mutex=<span class="hljs-number">1</span>;<span class="hljs-comment">/*控制对reader的访问*/</span>
semaphore database=<span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> reader=<span class="hljs-number">0</span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reader</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>
<span class="hljs-function"></span>&#123;
	<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)
	&#123;
		P(&amp;mutex);
		reader++;
		<span class="hljs-keyword">if</span>(reader==<span class="hljs-number">1</span>)<span class="hljs-comment">//只需要让第一个读者获取数据库访问权限，其他读者仅需要reader++即可</span>
		P(&amp;database);
		V(&amp;mutex);
		read_database();
		P(mutex);
		reader--;
		<span class="hljs-keyword">if</span>(reader==<span class="hljs-number">0</span>)
		V(&amp;database);
		V(&amp;mutex);
		use_data();
	&#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">writer</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>
<span class="hljs-function"></span>&#123;
	<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)
	&#123;
		P(&amp;database);<span class="hljs-comment">//写者只关心数据库权限是否拥有即可。</span>
		write_data();
		V(&amp;database);
	&#125;
&#125;</code></pre></div>

<p><strong>只需要让第一个读者获取数据库访问权限</strong>，<strong>其他读者仅需要</strong> <strong>reader++</strong> <strong>即可</strong>。</p>
<p>而写者关心的问题就比较少了，只需要看是否有其他进程有数据库权限即可(写者和写者、读者间都要互斥)</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Operating-System/">Operating System</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/C-C/">C/C++</a>
                    
                      <a class="hover-with-bg" href="/tags/OS/">OS</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/12/31/2020%E5%B9%B4%E7%BB%88%E5%9B%9E%E9%A1%BE/">
                        <span class="hidden-mobile">2020：迷雾中的一场奔赴</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                <script src="https://utteranc.es/client.js"
        repo="Feng-Jay/commit-utterance"
        issue-term="title"
        theme="github-dark"
        crossorigin="anonymous"
        async>
</script>
              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Linux-进程&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "rigth",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>












  

  

  

  

  

  




<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date(); 
    function createtime() { 
        var grt= new Date("8/9/2020 17:38:00");//在此处修改你的建站时间，格式：月/日/年 时:分:秒
        now.setTime(now.getTime()+250); 
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; 
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
    } 
setInterval("createtime()",250);
</script>


</body>
</html>

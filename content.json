{"pages":[{"title":"about","text":"我将在这里持续发布关于学习和生活的内容 [I will continue to publish content about learning and life here] You can contact me by github account orz . &emsp;&emsp;还有什么想说的？ &emsp;&emsp;好像没有。 &emsp;&emsp;那么…再见！ &emsp;&emsp;","link":"/about/index.html"}],"posts":[{"title":"NEMU","text":"","link":"/2020/11/10/NEMU/"},{"title":"Dynamic Programming","text":"Share and review my study process. 引论个人理解动态规划应该是一种设计技巧，和分治法类似，但DP更关心子问题的重叠。 动态规划是一种在各个不同大小(size)的子问题的优化值之间建立递归关系并求解的过程. 能使用动态规划求解的问题必须满足优化原理： 优化解包含的子问题的解也是最优的 即可利用优化原理，使用枚举法建立不同长度子问题优化值之间的递归关系—动态规划方程。 注意，动态规划算法得出的解为精确解，子问题的数目决定了该算法的复杂度. Ps: 尽量不要用递归 经典的0/1背包给定 n 种物品和一个容量为 C 的背包，物品 i 的重量是 wi，其价值为 vi 。 问：应该如何选择装入背包的物品，使得装入背包中的物品的总价值最大？ &emsp; 在学习DP算法之前，我们面对01背包问题有的思路就是贪心和穷举： 不管是对价值排序还是对价值密度排序，只是改变了贪心策略，但还是贪心算法，也就意味着我们只能求解一个近似解，无法得到精确解。 而穷举法的开销太大了，在很多情况下复杂且不适用。 既然贪心法在理论上是无法得到精确解的，那我们能否在穷举的基础上进行优化呢？ 来一个具体的例子n=5,c=10,w=[2,2,6,5,4],p=[6,3,5,4,6]. 可知此时的优化解为(1,1,0,0,1),即装1,2,5物品 想要用DP算法，首先要判断问题是否满足优化原理 即优化解包含的子问题的解是否最优。 当我们先装物品1时。 物品1装入，子问题为n=4,c’=c-2(物品1的重量),物品为2,3,4,5 可以看到子问题的优化解为(1,0,0,1) 与优化解相同 可以得知01背包问题满足优化原理。 DP的思路分析面对n个物品，我们并不知道该拿哪几个才是最优解，那么就使用计算机最擅长的技能：计算(遍历) 只不过我们会对遍历进行一些操作 设函数 f(i,y)表示当背包容量为y时，面对 i，i+1,…，n物品时的最优解。 可以知道f(1,c)就是我们最终要求的答案 求 f(1,c)遇到的第一个问题就是物品1拿不拿？ 答案是：不知道。&emsp; 但我们可以根据子问题推出来物品1拿不拿。 f(1,c)=max{f(2,c), f(2,c-w1)+p1} 这样我们的思路就出来了：建立一个父问题与子问题递归式。即在最后一个物品时返回两种情况：拿或不拿。再一路返回到第一种情况，判断物品1拿不拿。 下面是递归算法和非递归算法 递归法12345678910111213141516171819202122232425262728293031323334353637383940//递归算法#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int content;int num_things;int weightt[101];int value[101];int dp(int thing,int content){ int dp1=0; int dp2; if(thing==num_things-1) { if(content&lt;weightt[num_things-1]) return 0; else { return value[num_things-1]; } } if(content&gt;=weightt[thing]) dp1=dp(thing+1,content-weightt[thing])+value[thing]; dp2=dp(thing+1,content); return max(dp1,dp2);}int main(){ cin&gt;&gt;content&gt;&gt;num_things; for(int i=0;i&lt;num_things;i++) cin&gt;&gt;weightt[i]; for(int i=0;i&lt;num_things;i++) cin&gt;&gt;value[i]; cout&lt;&lt;dp(0,content)&lt;&lt;endl; return 0;} 由于递归算法开销很大，所以我们使用元组法来实现DP 元组法仔细回想我们的01背包问题，是否有这样一个感觉，效益值=f(i,y)是一个分段函数，且每一段都是效益值不变的水平直线。 那么我们只要记住分段函数的跳跃点，是否就可以对输入的每种情况进行还原(和数据结构中稀疏矩阵的存储相似) &emsp; 由于f(i, y)=max{ f(i+1,y),f(i+1,y-wi)+pi } 设f(i,y)对应元组P(i), f(i+1,y-wi)+pi对应元组Q 我们想要得到的是P(i)，所以我们需要求P(i+1)和Q。 由于f(i+1,y-wi)+pi可看作f(i+1,y)向右向上平移，所以P中每个元组(a,b)对应Q中的(a+wi,b+pi) &emsp; 求出P(i+1)和Q后，使用类似于merge排序的方法把两个元组中的点合并 合并规则： 合并时使用以下支配(选优)规则: 设(a,b)和(u,v)是来自P(i+1)和Q的元组,若a≥u且b＜v,则称(a,b)受(u,v) 支配. 因为 (a,b)代表以容量a得到效益值b的方案, 而(u,v)代表以较少的容量u得到较大效益值v的装包方案. (可以想象为两个分段函数一直取x相等时二者y值最大的一段) &emsp; 得到P(2)后我们可以不求P(1) 直接利用w1和P(2)来求出满足w1+w&lt;C的最后一个元组（w,v） 将v+p1与原来P(2)中最后一个满足条件的效益值比较，取最大的那个。","link":"/2020/11/07/Dynamic-Programming/"},{"title":"人这一辈子，最不能透支的是什么？","text":"午觉起来看到知乎一个高赞回答，分享一下，与君共勉。 作者：简在我心链接：知乎链接来源：知乎 生命力。 今天上午给学生讲解电影《死亡诗社》，对这个问题正好深有感触。 这个影片里，反复提到一些词：热情，激情，爱，浪漫，强有力，奋斗，寻觅，发现，呐喊…… 人类这个物种有个很大的优势就是对新鲜事物的好奇性。 我们喜欢探奇历险，喜欢学习研究。但是这种行为具有风险。 所以长辈或管理者为了安全需要和管理方便，会制定各种规则，把那个内心里生动活泼的小人儿关进牢笼里。 不让你玩水，不让你玩火，不让你爬树，不让你恋爱，不让你问为什么，不让你做这个做那个。 美其名曰：为你好。 然后你的生命力就会在种种禁锢中持续性流失和透支。 你变得对生活失去了热情，对世界失去了探索的欲望，你没有了学习的兴趣，没有了爱的能力…… 失去生命力的表现： 你刷着抖音，停不下来，哪怕已经厌倦，也还是忍不住继续滑动手指。 你躺在床上，睡到头疼，浑身无力，不想再躺下去了，却依然缺乏起床的动力。 你玩着游戏，玩到疲惫不堪，但依然百无聊赖地点着鼠标，两眼无光。 你频繁和五姑娘交谈，谈到昏昏沉沉，依然不想松开她。 你失去了对自己的生命的强有力的感觉。 你沦丧于无聊的重复的形式中，无力自拔。 失去了生命的热情和希望。 失去了对于自我身体的掌控。 失去了对事物的感知能力。 你疲惫，疲软，无力，无感，靠反复的刺激来提醒自己好像还活着。 我认为这就是生命力透支的表现，是最糟糕的生活状态，没有之一。 我为什么感受那么深？ 最近跟学生交流，发现他们很多人都已经处于这种生命力透支的状态。 你问他还有什么理想、希望或想做的事情。好像没有，或即便有也是缺乏可持续性。 所以他们只能浑浑噩噩地混日子。 为什么那么多人抑郁、自杀或躺平？ 因为他们的生命力已经透支了，枯竭了，对生活已经没有了热情，没有了希望，也没有了信心。 才不到二十岁的年纪，就失去了狂野、野心、激情、欲望。 这是一个多么令人痛心的事实。 所以别说什么成才，就是过好自己平凡一生都很难了。 这将是一个个了无生趣的生命。 这就是不重视人文教育的后果。 生命需要呵护，需要个性的张扬和奔放，需要自由的空气，才能健康成长，才能抵御现实的风霜雪剑。 可是我们以爱的名义，剥夺了孩子们的生命力，使得他们还没绽放，就已经枯萎了。","link":"/2020/11/03/%E5%85%B1%E5%8B%89/"},{"title":"Operating System","text":"Basic knowledge about OS and Linux. Solutions about MIT 6.828 Processes进程是一个正在执行程序的实例，包括了程序代码和它当前的状态（寄存器…） 一个进程包括三个部分 Tips: The differences between process and program Program is just the static text Process is an dynamic entity being executed and has lifecycle","link":"/2020/10/27/Operating%E2%80%94-System/"},{"title":"贪心算法&amp;&amp;优化问题","text":"Record key point And write code for some problems. 优化问题优化问题的概念即通过一定条件约束，对一组变量进行操作，使目标到达最优值。 优化问题的一般描述优化问题的描述： 1.问题的解为一复杂结构 (x1,x2,…,xn) xi∈Si（可选的方式） 2.约束条件：B(x1,x2…,xn)，使B为true的元组称为可行解 3.目标函数f(x1,…,xn) 优化解即指使目标函数取得最值的可行解，对应的目标函数值称为优化值 贪心算法是求近似解的一种主要途径。 贪心算法的思想及要点思想&emsp;&emsp;贪心算法是一种多步求解的方法，每步按一种局部最优的策略选择解的一个分量，算法以第n步结束时构造出问题的解。他也是一种寻找最优解的方法，即在使用时要把整个问题分解为若干步，在每一步中都会选择当前最优的解法，然后将每一步的解合并成为整个问题的最终解。 &emsp;&emsp;该算法问题在于：因为其的贪婪的短视导致在很多情况下都会错过最优解，因为贪心算法不会从整体上对问题进行思考，只会闷头于当前情况。所以贪心算法不能用来求最大最小值、无法保证最后的解是最优的、只能求某些特定的解。 &emsp;&emsp;所以实际上可以用贪心算法求得最优解的情况很少，所以我们要证明每一步所作的贪心选择最终能导出问题最优解（举几组数据即可）。 &emsp;&emsp;听起来贪心算法似乎很复杂，但他其实并没有太多的技巧。唯一的考验就在于制定你的贪心策略(主要是要有这个思想) 让你的算法 真正的只关心当下，不去关心后续情况或者先前情况。 特点 不回溯 局部优化策略可以减小开销，但不保证得到精确优化解 不同贪心策略得到不同算法 常使用使目标函数有最大增量的策略为贪心策略 例题下面我们来看一个很简单的例题 例 Loading Problem 设有n个集装箱,集装箱大小一样，第i个设有n个集装箱,集装箱大小一样，第i个集装箱的重量为wi(1≤i≤n),设船的载重量为c.试设计一装船的方法使得装入的集装箱数目最多 &emsp; 这是一道很基础的贪心算法题目，我们先按照优化问题的格式来描述一下他： 令问题的解为(x1,x2,…,xn) &nbsp;xi={0,1}//代表第i个箱子是否装载。 问题的约束条件是Σi=1,n wixi&lt;=c; //装载箱子的总重量小于等于C 目标函数为 Σi=1,n xi； //装载的集装箱个数 我们的目标是极大化目标函数。 因为目标函数是所装的集装箱数目，所以按照我们的常规思想，那么一定先装重量轻的集装箱。 所以可以写出代码如下 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n,c;int weight[100]={0};int countt=0;int tem_weight=0;int main(){ cin&gt;&gt;n; cin&gt;&gt;c; for(int i=0;i&lt;n;i++) cin&gt;&gt;weight[i]; sort(weight,weight+n); for(int i=0;i&lt;n;i++) { if(tem_weight+weight[i]&lt;=c) { tem_weight+=weight[i]; countt++; } else {break;} } cout&lt;&lt;countt&lt;&lt;endl; return 0;} 这时你可能对这种贪心策略存疑，先装载重量低的箱子一定能得到最优解吗？ 下面给出证明 证明: 设问题最优解为(y1,y2,…,yn) 如最优解不含箱子1，将箱子1替换优化解中某一个箱子得到一个新的解 1.替换是必须的：若1还能装入船中，则(y1,y2,…,yn)不是优化的 2.因为1是最轻的，所以替换后的解仍是可行的 3.替换后的解装入的箱子数==优化的箱子数，它仍是优化解 4.替换后新的优化解和贪心解都有箱子1 反复替换得到一个优化解，优化解==贪心解 替换次数是有穷的。 这就确定了在这道题目里，我们的贪心解一定是优化解。 针对这个问题也引出一点：贪心解虽然在一种策略下只有一个，但问题的真正最优解可能有多个。","link":"/2020/10/11/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"},{"title":"每日洛谷_9.28","text":"今天刷洛谷基础题看到一个很好的题，分享一下。 ​ 原题链接 题目描述对于一个 n 个顶点的凸多边形，它的任何三条对角线都不会交于一点。请求出图形中对角线交点的个数。 例如，6 边形： 输入格式输入只有一行一个整数 nnn，代表边数。 输出格式输出一行一个整数代表答案。 输入输出样例输入 #1 &nbsp;&emsp;输入#2 3 &nbsp; &emsp;&nbsp; 6 输出#2 &nbsp; &emsp; 输入#2 0 &nbsp; &emsp; &nbsp;15 说明与提示 对于 50%50 %50% 的数据，保证 3≤n≤100。 对于 100%100 %100% 的数据，保证 3≤n≤10^5。 题解首先看题目中一句任何三条对角线都不会交于一点，所以给定一个交点，可以确定两条对角线——也就意味着确定了四个角 所以这道题就变成了一个排列问题 即求Cn4的组合数问题 ：就是求 n * (n-1) * (n-2) * (n-3) /24 这时大家可能会想&nbsp;”啊，这个题目这么简单，怎么会有人拿他出来写博客！” 所以你就写出了下面的代码 123456789101112131415#include &lt;iostream&gt;using namespace std;int n;int outcome;int main(){ cin&gt;&gt;n; outcome=n*(n-1)*(n-2)*(n-3)/24; cout&lt;&lt;outcome&lt;&lt;endl; return 0;} 结果 再仔细阅读下题目，你会发现这道题会爆数据的… 所以你把int 全部换成了long long 或者unsigned long long ，并沾沾自喜，这么简单不会真有人拿出来写博客吧！ 结果你又发现出现了两个WA…（手动狗头） 这时你想到，我可以写高精求组合数啊 这无疑是一种很好的解题方法，但对于这样一道入门题来说，未免太… 所以给出了一个很妙的写法 那就是把 n * (n-1) * (n-2) * (n-3) /24写成 n * (n-1)/2 *(n-2) /3 *(n-3)/4 123456789101112131415#include &lt;iostream&gt;using namespace std;unsigned long long n;unsigned long long outcome;int main(){ cin&gt;&gt;n; outcome=n*(n-1)/2*(n-2)/3*(n-3)/4; cout&lt;&lt;outcome&lt;&lt;endl;} 现在来分析一下为什么这样写是对的。 首先n * (n-1)中一定有一个是2的倍数，所以可以被2整除 n * (n-1) *(n-2)中一定有一个是3的倍数，所以可以被3整除 n * (n-1) * (n-2) * (n-3) 中一定有一个是4的倍数，所以可以被4整除 emmmmmmmmmmm，就差不多是这样了 溜了溜了，上课去。","link":"/2020/09/28/%E6%AF%8F%E6%97%A5%E6%B4%9B%E8%B0%B7-9-28/"},{"title":"欧几里得算法","text":"昨天上算法课听到了这个算法，突发兴趣来写一篇blog。 欧几里得算法的用处欧几里得算法也称为辗转相除法，是求解最大公约数的一种方法。 若有两个数a和b，求a和b的最大公约数，按照我们之前所学的东西，可能只会枚举a与b的因子，效率很低… 但欧几里得为我们提供了一个十分便捷的方法。 一个强大的定理gcd(a,b) = gcd(b, a%b) 下面给出证明 12345678设a与b的公约数为 k ，a=bx+y;则 k|a 且 k|b ，有 a%b=y又有y=a-bx, 所以 k|y。即 k|a%b再假设b 与 a%b的公约数为kk，得 kk|a，所以(a,b)与(b,a%b)的公约数相同，所以其最大公约数也相同。即gcd(a,b)==gcd(b,a%b); 代码实现任何数与0的最大公约数都是他本身，且根据gcd(a,b)==gcd(b,a%b)可得知 当gcd中余数为0时，另一个数就是最大公约数。 所以代码如下 12345678910111213int gcd(int a,int b){ int outcome; int temp; while(b!=0) { temp=a%b; a=b; b=temp; } outcome=a; return outcome;} 溜溜球，去学概率论了…","link":"/2020/09/22/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/"},{"title":"世界反法西斯战争胜利75周年有感","text":"​ 这是我今年第三次流泪：第一次是在听《国际歌》的时候，第二次是在读《悲惨世界》的时候，今天是第三次。但这次除了流泪，我还有一些忧虑。 ​ “为有牺牲多壮志，敢叫日月换新天”。法西斯的阴云在中华大地盘旋了十四年，三千五百万烈士在反法西斯战争中牺牲。他们在极度艰苦的环境中仍坚守心中理想，献身于保卫祖国的斗争，以自己的血肉之躯换来了中华民族的转折点，换来了现在的人民共和国，换来了民族运动的高潮。他们的事迹永世长存，他们的功绩永垂不朽。 ​ 中国人民的斗争无疑对世界法西斯主义进行了沉重的打击，但法西斯主义已经完全消散了吗？红色的太阳已经高悬了吗？ ​ 只怕这片阴云恐怕还在盘旋，太阳也才刚放出光芒。 ​ 世界经济形势低迷，势必会带来社会变革。而对于现在的出路只有两条：左转，马列主义；右转，法西斯主义。而资本主义的领头人——美国，目前地表最强的国家，正在带领着一众资本主义国家向右疾行。而随着苏联的解体，国际共运陷入了又一次低潮，资本主义国家人民的声音越来越小。 ​ 再加上最近美国对华动作不断：贸易战、对台动作、驱逐中国留学生……，这一系列动作不禁让我想起了纳粹德国，担心会出现一个新的“水晶之夜”。担心出现像拉斯科利尼科夫那样的人——一个自认为非凡的普通人。我们已经为旧的法西斯主义付出了三千五百万条生命的代价，我们不能再忍受这样沉痛的代价。 ​ 昔日的盟友已经在法西斯道路上渐行渐远，屠龙者已经成为了恶龙。我们更不应松开我们的反法西斯历史，成为世界下一座灯塔。 ​ 现在世界上除了我们，再也没有人能担起反法西斯战士的称号了！达瓦里氏，我们的前途是光明的，社会主义的又一次高潮即将出现在东方；我们的前途也是崎岖的，我们面对的是前所未有的强大的敌人——美国，一个远比纳粹德国强大的力量。 ​ 在黎明到来前，会有很多人倒下，但我们终将迎来光明。 ​ 达瓦里氏，你，愿意和我一起吗？","link":"/2020/09/03/%E4%B8%96%E7%95%8C%E5%8F%8D%E6%B3%95%E8%A5%BF%E6%96%AF%E6%88%98%E4%BA%89%E8%83%9C%E5%88%A975%E5%91%A8%E5%B9%B4%E6%9C%89%E6%84%9F/"},{"title":"My Bucket List -- version 1","text":"0.希望能为国家突破一些技术障碍 1.去俄罗斯游玩，再去伦敦的马克思墓地 2.帮助一个陌生人 3.对一个女生表白 and 亲吻世界上最美的女生 4.跑完一次马拉松 5.写出一个属于自己的纪念app/网页 6.去当国际志愿者 and 去联合国转转 7.见勒布朗 詹姆斯一面 8.开一次枪、坐直升机跳伞 9.把自己都捐了 … 正在努力的事情： 9.阅读马列主义书籍及其他世界名著 10.编程，进入ACM队 11.复习… 12.坚持跑步、锻炼 13.捐款 14.成为党员 15.保研到THU 16.能为国家硬件/软件做出自己的贡献","link":"/2020/08/11/My-Bucket-List-version-1/"}],"tags":[{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Life","slug":"Life","link":"/tags/Life/"},{"name":"Thinking","slug":"Thinking","link":"/tags/Thinking/"},{"name":"Operating System","slug":"Operating-System","link":"/tags/Operating-System/"}],"categories":[{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"Bucket List","slug":"Bucket-List","link":"/categories/Bucket-List/"},{"name":"Operating System","slug":"Operating-System","link":"/categories/Operating-System/"},{"name":"Socialism","slug":"Socialism","link":"/categories/Socialism/"},{"name":"Life","slug":"Life","link":"/categories/Life/"}]}